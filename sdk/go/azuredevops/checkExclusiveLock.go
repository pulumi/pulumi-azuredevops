// Code generated by the Pulumi Terraform Bridge (tfgen) Tool DO NOT EDIT.
// *** WARNING: Do not edit by hand unless you're certain you know what you are doing! ***

package azuredevops

import (
	"context"
	"reflect"

	"errors"
	"github.com/pulumi/pulumi-azuredevops/sdk/v2/go/azuredevops/internal"
	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
	"github.com/pulumi/pulumi/sdk/v3/go/pulumix"
)

// Manages a Exclusive Lock Check.
//
// Adding an exclusive lock will only allow a single stage to utilize this resource at a time. If multiple stages are waiting on the lock, only the latest will run. All others will be canceled.
//
// ## Example Usage
// ### Add Exclusive Lock to an environment
//
// ```go
// package main
//
// import (
//
//	"github.com/pulumi/pulumi-azuredevops/sdk/v2/go/azuredevops"
//	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
//
// )
//
//	func main() {
//		pulumi.Run(func(ctx *pulumi.Context) error {
//			exampleProject, err := azuredevops.NewProject(ctx, "exampleProject", nil)
//			if err != nil {
//				return err
//			}
//			exampleServiceEndpointGeneric, err := azuredevops.NewServiceEndpointGeneric(ctx, "exampleServiceEndpointGeneric", &azuredevops.ServiceEndpointGenericArgs{
//				ProjectId:           exampleProject.ID(),
//				ServerUrl:           pulumi.String("https://some-server.example.com"),
//				Username:            pulumi.String("username"),
//				Password:            pulumi.String("password"),
//				ServiceEndpointName: pulumi.String("Example Generic"),
//				Description:         pulumi.String("Managed by Terraform"),
//			})
//			if err != nil {
//				return err
//			}
//			_, err = azuredevops.NewCheckExclusiveLock(ctx, "exampleCheckExclusiveLock", &azuredevops.CheckExclusiveLockArgs{
//				ProjectId:          exampleProject.ID(),
//				TargetResourceId:   exampleServiceEndpointGeneric.ID(),
//				TargetResourceType: pulumi.String("endpoint"),
//				Timeout:            pulumi.Int(43200),
//			})
//			if err != nil {
//				return err
//			}
//			return nil
//		})
//	}
//
// ```
// ### Protect an environment
//
// ```go
// package main
//
// import (
//
//	"github.com/pulumi/pulumi-azuredevops/sdk/v2/go/azuredevops"
//	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
//
// )
//
//	func main() {
//		pulumi.Run(func(ctx *pulumi.Context) error {
//			exampleProject, err := azuredevops.NewProject(ctx, "exampleProject", nil)
//			if err != nil {
//				return err
//			}
//			exampleEnvironment, err := azuredevops.NewEnvironment(ctx, "exampleEnvironment", &azuredevops.EnvironmentArgs{
//				ProjectId: exampleProject.ID(),
//			})
//			if err != nil {
//				return err
//			}
//			_, err = azuredevops.NewCheckExclusiveLock(ctx, "exampleCheckExclusiveLock", &azuredevops.CheckExclusiveLockArgs{
//				ProjectId:          exampleProject.ID(),
//				TargetResourceId:   exampleEnvironment.ID(),
//				TargetResourceType: pulumi.String("environment"),
//				Timeout:            pulumi.Int(43200),
//			})
//			if err != nil {
//				return err
//			}
//			return nil
//		})
//	}
//
// ```
//
// ## Import
//
// Importing this resource is not supported.
type CheckExclusiveLock struct {
	pulumi.CustomResourceState

	// The project ID. Changing this forces a new Exclusive Lock Check to be created.
	ProjectId pulumi.StringOutput `pulumi:"projectId"`
	// The ID of the resource being protected by the check. Changing this forces a new Exclusive Lock to be created.
	TargetResourceId pulumi.StringOutput `pulumi:"targetResourceId"`
	// The type of resource being protected by the check. Valid values: `endpoint`, `environment`, `queue`, `repository`, `securefile`, `variablegroup`. Changing this forces a new Exclusive Lock to be created.
	TargetResourceType pulumi.StringOutput `pulumi:"targetResourceType"`
	// The timeout in minutes for the exclusive lock. Defaults to `43200`.
	Timeout pulumi.IntPtrOutput `pulumi:"timeout"`
}

// NewCheckExclusiveLock registers a new resource with the given unique name, arguments, and options.
func NewCheckExclusiveLock(ctx *pulumi.Context,
	name string, args *CheckExclusiveLockArgs, opts ...pulumi.ResourceOption) (*CheckExclusiveLock, error) {
	if args == nil {
		return nil, errors.New("missing one or more required arguments")
	}

	if args.ProjectId == nil {
		return nil, errors.New("invalid value for required argument 'ProjectId'")
	}
	if args.TargetResourceId == nil {
		return nil, errors.New("invalid value for required argument 'TargetResourceId'")
	}
	if args.TargetResourceType == nil {
		return nil, errors.New("invalid value for required argument 'TargetResourceType'")
	}
	opts = internal.PkgResourceDefaultOpts(opts)
	var resource CheckExclusiveLock
	err := ctx.RegisterResource("azuredevops:index/checkExclusiveLock:CheckExclusiveLock", name, args, &resource, opts...)
	if err != nil {
		return nil, err
	}
	return &resource, nil
}

// GetCheckExclusiveLock gets an existing CheckExclusiveLock resource's state with the given name, ID, and optional
// state properties that are used to uniquely qualify the lookup (nil if not required).
func GetCheckExclusiveLock(ctx *pulumi.Context,
	name string, id pulumi.IDInput, state *CheckExclusiveLockState, opts ...pulumi.ResourceOption) (*CheckExclusiveLock, error) {
	var resource CheckExclusiveLock
	err := ctx.ReadResource("azuredevops:index/checkExclusiveLock:CheckExclusiveLock", name, id, state, &resource, opts...)
	if err != nil {
		return nil, err
	}
	return &resource, nil
}

// Input properties used for looking up and filtering CheckExclusiveLock resources.
type checkExclusiveLockState struct {
	// The project ID. Changing this forces a new Exclusive Lock Check to be created.
	ProjectId *string `pulumi:"projectId"`
	// The ID of the resource being protected by the check. Changing this forces a new Exclusive Lock to be created.
	TargetResourceId *string `pulumi:"targetResourceId"`
	// The type of resource being protected by the check. Valid values: `endpoint`, `environment`, `queue`, `repository`, `securefile`, `variablegroup`. Changing this forces a new Exclusive Lock to be created.
	TargetResourceType *string `pulumi:"targetResourceType"`
	// The timeout in minutes for the exclusive lock. Defaults to `43200`.
	Timeout *int `pulumi:"timeout"`
}

type CheckExclusiveLockState struct {
	// The project ID. Changing this forces a new Exclusive Lock Check to be created.
	ProjectId pulumi.StringPtrInput
	// The ID of the resource being protected by the check. Changing this forces a new Exclusive Lock to be created.
	TargetResourceId pulumi.StringPtrInput
	// The type of resource being protected by the check. Valid values: `endpoint`, `environment`, `queue`, `repository`, `securefile`, `variablegroup`. Changing this forces a new Exclusive Lock to be created.
	TargetResourceType pulumi.StringPtrInput
	// The timeout in minutes for the exclusive lock. Defaults to `43200`.
	Timeout pulumi.IntPtrInput
}

func (CheckExclusiveLockState) ElementType() reflect.Type {
	return reflect.TypeOf((*checkExclusiveLockState)(nil)).Elem()
}

type checkExclusiveLockArgs struct {
	// The project ID. Changing this forces a new Exclusive Lock Check to be created.
	ProjectId string `pulumi:"projectId"`
	// The ID of the resource being protected by the check. Changing this forces a new Exclusive Lock to be created.
	TargetResourceId string `pulumi:"targetResourceId"`
	// The type of resource being protected by the check. Valid values: `endpoint`, `environment`, `queue`, `repository`, `securefile`, `variablegroup`. Changing this forces a new Exclusive Lock to be created.
	TargetResourceType string `pulumi:"targetResourceType"`
	// The timeout in minutes for the exclusive lock. Defaults to `43200`.
	Timeout *int `pulumi:"timeout"`
}

// The set of arguments for constructing a CheckExclusiveLock resource.
type CheckExclusiveLockArgs struct {
	// The project ID. Changing this forces a new Exclusive Lock Check to be created.
	ProjectId pulumi.StringInput
	// The ID of the resource being protected by the check. Changing this forces a new Exclusive Lock to be created.
	TargetResourceId pulumi.StringInput
	// The type of resource being protected by the check. Valid values: `endpoint`, `environment`, `queue`, `repository`, `securefile`, `variablegroup`. Changing this forces a new Exclusive Lock to be created.
	TargetResourceType pulumi.StringInput
	// The timeout in minutes for the exclusive lock. Defaults to `43200`.
	Timeout pulumi.IntPtrInput
}

func (CheckExclusiveLockArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*checkExclusiveLockArgs)(nil)).Elem()
}

type CheckExclusiveLockInput interface {
	pulumi.Input

	ToCheckExclusiveLockOutput() CheckExclusiveLockOutput
	ToCheckExclusiveLockOutputWithContext(ctx context.Context) CheckExclusiveLockOutput
}

func (*CheckExclusiveLock) ElementType() reflect.Type {
	return reflect.TypeOf((**CheckExclusiveLock)(nil)).Elem()
}

func (i *CheckExclusiveLock) ToCheckExclusiveLockOutput() CheckExclusiveLockOutput {
	return i.ToCheckExclusiveLockOutputWithContext(context.Background())
}

func (i *CheckExclusiveLock) ToCheckExclusiveLockOutputWithContext(ctx context.Context) CheckExclusiveLockOutput {
	return pulumi.ToOutputWithContext(ctx, i).(CheckExclusiveLockOutput)
}

func (i *CheckExclusiveLock) ToOutput(ctx context.Context) pulumix.Output[*CheckExclusiveLock] {
	return pulumix.Output[*CheckExclusiveLock]{
		OutputState: i.ToCheckExclusiveLockOutputWithContext(ctx).OutputState,
	}
}

// CheckExclusiveLockArrayInput is an input type that accepts CheckExclusiveLockArray and CheckExclusiveLockArrayOutput values.
// You can construct a concrete instance of `CheckExclusiveLockArrayInput` via:
//
//	CheckExclusiveLockArray{ CheckExclusiveLockArgs{...} }
type CheckExclusiveLockArrayInput interface {
	pulumi.Input

	ToCheckExclusiveLockArrayOutput() CheckExclusiveLockArrayOutput
	ToCheckExclusiveLockArrayOutputWithContext(context.Context) CheckExclusiveLockArrayOutput
}

type CheckExclusiveLockArray []CheckExclusiveLockInput

func (CheckExclusiveLockArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]*CheckExclusiveLock)(nil)).Elem()
}

func (i CheckExclusiveLockArray) ToCheckExclusiveLockArrayOutput() CheckExclusiveLockArrayOutput {
	return i.ToCheckExclusiveLockArrayOutputWithContext(context.Background())
}

func (i CheckExclusiveLockArray) ToCheckExclusiveLockArrayOutputWithContext(ctx context.Context) CheckExclusiveLockArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(CheckExclusiveLockArrayOutput)
}

func (i CheckExclusiveLockArray) ToOutput(ctx context.Context) pulumix.Output[[]*CheckExclusiveLock] {
	return pulumix.Output[[]*CheckExclusiveLock]{
		OutputState: i.ToCheckExclusiveLockArrayOutputWithContext(ctx).OutputState,
	}
}

// CheckExclusiveLockMapInput is an input type that accepts CheckExclusiveLockMap and CheckExclusiveLockMapOutput values.
// You can construct a concrete instance of `CheckExclusiveLockMapInput` via:
//
//	CheckExclusiveLockMap{ "key": CheckExclusiveLockArgs{...} }
type CheckExclusiveLockMapInput interface {
	pulumi.Input

	ToCheckExclusiveLockMapOutput() CheckExclusiveLockMapOutput
	ToCheckExclusiveLockMapOutputWithContext(context.Context) CheckExclusiveLockMapOutput
}

type CheckExclusiveLockMap map[string]CheckExclusiveLockInput

func (CheckExclusiveLockMap) ElementType() reflect.Type {
	return reflect.TypeOf((*map[string]*CheckExclusiveLock)(nil)).Elem()
}

func (i CheckExclusiveLockMap) ToCheckExclusiveLockMapOutput() CheckExclusiveLockMapOutput {
	return i.ToCheckExclusiveLockMapOutputWithContext(context.Background())
}

func (i CheckExclusiveLockMap) ToCheckExclusiveLockMapOutputWithContext(ctx context.Context) CheckExclusiveLockMapOutput {
	return pulumi.ToOutputWithContext(ctx, i).(CheckExclusiveLockMapOutput)
}

func (i CheckExclusiveLockMap) ToOutput(ctx context.Context) pulumix.Output[map[string]*CheckExclusiveLock] {
	return pulumix.Output[map[string]*CheckExclusiveLock]{
		OutputState: i.ToCheckExclusiveLockMapOutputWithContext(ctx).OutputState,
	}
}

type CheckExclusiveLockOutput struct{ *pulumi.OutputState }

func (CheckExclusiveLockOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**CheckExclusiveLock)(nil)).Elem()
}

func (o CheckExclusiveLockOutput) ToCheckExclusiveLockOutput() CheckExclusiveLockOutput {
	return o
}

func (o CheckExclusiveLockOutput) ToCheckExclusiveLockOutputWithContext(ctx context.Context) CheckExclusiveLockOutput {
	return o
}

func (o CheckExclusiveLockOutput) ToOutput(ctx context.Context) pulumix.Output[*CheckExclusiveLock] {
	return pulumix.Output[*CheckExclusiveLock]{
		OutputState: o.OutputState,
	}
}

// The project ID. Changing this forces a new Exclusive Lock Check to be created.
func (o CheckExclusiveLockOutput) ProjectId() pulumi.StringOutput {
	return o.ApplyT(func(v *CheckExclusiveLock) pulumi.StringOutput { return v.ProjectId }).(pulumi.StringOutput)
}

// The ID of the resource being protected by the check. Changing this forces a new Exclusive Lock to be created.
func (o CheckExclusiveLockOutput) TargetResourceId() pulumi.StringOutput {
	return o.ApplyT(func(v *CheckExclusiveLock) pulumi.StringOutput { return v.TargetResourceId }).(pulumi.StringOutput)
}

// The type of resource being protected by the check. Valid values: `endpoint`, `environment`, `queue`, `repository`, `securefile`, `variablegroup`. Changing this forces a new Exclusive Lock to be created.
func (o CheckExclusiveLockOutput) TargetResourceType() pulumi.StringOutput {
	return o.ApplyT(func(v *CheckExclusiveLock) pulumi.StringOutput { return v.TargetResourceType }).(pulumi.StringOutput)
}

// The timeout in minutes for the exclusive lock. Defaults to `43200`.
func (o CheckExclusiveLockOutput) Timeout() pulumi.IntPtrOutput {
	return o.ApplyT(func(v *CheckExclusiveLock) pulumi.IntPtrOutput { return v.Timeout }).(pulumi.IntPtrOutput)
}

type CheckExclusiveLockArrayOutput struct{ *pulumi.OutputState }

func (CheckExclusiveLockArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]*CheckExclusiveLock)(nil)).Elem()
}

func (o CheckExclusiveLockArrayOutput) ToCheckExclusiveLockArrayOutput() CheckExclusiveLockArrayOutput {
	return o
}

func (o CheckExclusiveLockArrayOutput) ToCheckExclusiveLockArrayOutputWithContext(ctx context.Context) CheckExclusiveLockArrayOutput {
	return o
}

func (o CheckExclusiveLockArrayOutput) ToOutput(ctx context.Context) pulumix.Output[[]*CheckExclusiveLock] {
	return pulumix.Output[[]*CheckExclusiveLock]{
		OutputState: o.OutputState,
	}
}

func (o CheckExclusiveLockArrayOutput) Index(i pulumi.IntInput) CheckExclusiveLockOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) *CheckExclusiveLock {
		return vs[0].([]*CheckExclusiveLock)[vs[1].(int)]
	}).(CheckExclusiveLockOutput)
}

type CheckExclusiveLockMapOutput struct{ *pulumi.OutputState }

func (CheckExclusiveLockMapOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*map[string]*CheckExclusiveLock)(nil)).Elem()
}

func (o CheckExclusiveLockMapOutput) ToCheckExclusiveLockMapOutput() CheckExclusiveLockMapOutput {
	return o
}

func (o CheckExclusiveLockMapOutput) ToCheckExclusiveLockMapOutputWithContext(ctx context.Context) CheckExclusiveLockMapOutput {
	return o
}

func (o CheckExclusiveLockMapOutput) ToOutput(ctx context.Context) pulumix.Output[map[string]*CheckExclusiveLock] {
	return pulumix.Output[map[string]*CheckExclusiveLock]{
		OutputState: o.OutputState,
	}
}

func (o CheckExclusiveLockMapOutput) MapIndex(k pulumi.StringInput) CheckExclusiveLockOutput {
	return pulumi.All(o, k).ApplyT(func(vs []interface{}) *CheckExclusiveLock {
		return vs[0].(map[string]*CheckExclusiveLock)[vs[1].(string)]
	}).(CheckExclusiveLockOutput)
}

func init() {
	pulumi.RegisterInputType(reflect.TypeOf((*CheckExclusiveLockInput)(nil)).Elem(), &CheckExclusiveLock{})
	pulumi.RegisterInputType(reflect.TypeOf((*CheckExclusiveLockArrayInput)(nil)).Elem(), CheckExclusiveLockArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*CheckExclusiveLockMapInput)(nil)).Elem(), CheckExclusiveLockMap{})
	pulumi.RegisterOutputType(CheckExclusiveLockOutput{})
	pulumi.RegisterOutputType(CheckExclusiveLockArrayOutput{})
	pulumi.RegisterOutputType(CheckExclusiveLockMapOutput{})
}
