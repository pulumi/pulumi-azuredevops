// *** WARNING: this file was generated by pulumi-java-gen. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

package com.pulumi.azuredevops.inputs;

import com.pulumi.azuredevops.inputs.BranchPolicyBuildValidationSettingsScopeArgs;
import com.pulumi.core.Output;
import com.pulumi.core.annotations.Import;
import com.pulumi.exceptions.MissingRequiredPropertyException;
import java.lang.Boolean;
import java.lang.Integer;
import java.lang.String;
import java.util.List;
import java.util.Objects;
import java.util.Optional;
import javax.annotation.Nullable;


public final class BranchPolicyBuildValidationSettingsArgs extends com.pulumi.resources.ResourceArgs {

    public static final BranchPolicyBuildValidationSettingsArgs Empty = new BranchPolicyBuildValidationSettingsArgs();

    /**
     * The ID of the build to monitor for the policy.
     * 
     */
    @Import(name="buildDefinitionId", required=true)
    private Output<Integer> buildDefinitionId;

    /**
     * @return The ID of the build to monitor for the policy.
     * 
     */
    public Output<Integer> buildDefinitionId() {
        return this.buildDefinitionId;
    }

    /**
     * The display name for the policy.
     * 
     */
    @Import(name="displayName", required=true)
    private Output<String> displayName;

    /**
     * @return The display name for the policy.
     * 
     */
    public Output<String> displayName() {
        return this.displayName;
    }

    /**
     * If a path filter is set, the policy will only apply when files which match the filter are changes. Not setting this field means that the policy will always apply. You can specify absolute paths and wildcards. Example: `[&#34;/WebApp/Models/Data.cs&#34;, &#34;/WebApp/*&#34;, &#34;*.cs&#34;]`. Paths prefixed with &#34;!&#34; are excluded. Example: `[&#34;/WebApp/*&#34;, &#34;!/WebApp/Tests/*&#34;]`. Order is significant.
     * 
     */
    @Import(name="filenamePatterns")
    private @Nullable Output<List<String>> filenamePatterns;

    /**
     * @return If a path filter is set, the policy will only apply when files which match the filter are changes. Not setting this field means that the policy will always apply. You can specify absolute paths and wildcards. Example: `[&#34;/WebApp/Models/Data.cs&#34;, &#34;/WebApp/*&#34;, &#34;*.cs&#34;]`. Paths prefixed with &#34;!&#34; are excluded. Example: `[&#34;/WebApp/*&#34;, &#34;!/WebApp/Tests/*&#34;]`. Order is significant.
     * 
     */
    public Optional<Output<List<String>>> filenamePatterns() {
        return Optional.ofNullable(this.filenamePatterns);
    }

    /**
     * If set to true, the build will need to be manually queued. Defaults to `false`
     * 
     */
    @Import(name="manualQueueOnly")
    private @Nullable Output<Boolean> manualQueueOnly;

    /**
     * @return If set to true, the build will need to be manually queued. Defaults to `false`
     * 
     */
    public Optional<Output<Boolean>> manualQueueOnly() {
        return Optional.ofNullable(this.manualQueueOnly);
    }

    /**
     * True if the build should queue on source updates only. Defaults to `true`.
     * 
     */
    @Import(name="queueOnSourceUpdateOnly")
    private @Nullable Output<Boolean> queueOnSourceUpdateOnly;

    /**
     * @return True if the build should queue on source updates only. Defaults to `true`.
     * 
     */
    public Optional<Output<Boolean>> queueOnSourceUpdateOnly() {
        return Optional.ofNullable(this.queueOnSourceUpdateOnly);
    }

    /**
     * Controls which repositories and branches the policy will be enabled for. This block must be defined at least once.
     * 
     */
    @Import(name="scopes", required=true)
    private Output<List<BranchPolicyBuildValidationSettingsScopeArgs>> scopes;

    /**
     * @return Controls which repositories and branches the policy will be enabled for. This block must be defined at least once.
     * 
     */
    public Output<List<BranchPolicyBuildValidationSettingsScopeArgs>> scopes() {
        return this.scopes;
    }

    /**
     * The number of minutes for which the build is valid. If `0`, the build will not expire. Defaults to `720` (12 hours).
     * 
     */
    @Import(name="validDuration")
    private @Nullable Output<Integer> validDuration;

    /**
     * @return The number of minutes for which the build is valid. If `0`, the build will not expire. Defaults to `720` (12 hours).
     * 
     */
    public Optional<Output<Integer>> validDuration() {
        return Optional.ofNullable(this.validDuration);
    }

    private BranchPolicyBuildValidationSettingsArgs() {}

    private BranchPolicyBuildValidationSettingsArgs(BranchPolicyBuildValidationSettingsArgs $) {
        this.buildDefinitionId = $.buildDefinitionId;
        this.displayName = $.displayName;
        this.filenamePatterns = $.filenamePatterns;
        this.manualQueueOnly = $.manualQueueOnly;
        this.queueOnSourceUpdateOnly = $.queueOnSourceUpdateOnly;
        this.scopes = $.scopes;
        this.validDuration = $.validDuration;
    }

    public static Builder builder() {
        return new Builder();
    }
    public static Builder builder(BranchPolicyBuildValidationSettingsArgs defaults) {
        return new Builder(defaults);
    }

    public static final class Builder {
        private BranchPolicyBuildValidationSettingsArgs $;

        public Builder() {
            $ = new BranchPolicyBuildValidationSettingsArgs();
        }

        public Builder(BranchPolicyBuildValidationSettingsArgs defaults) {
            $ = new BranchPolicyBuildValidationSettingsArgs(Objects.requireNonNull(defaults));
        }

        /**
         * @param buildDefinitionId The ID of the build to monitor for the policy.
         * 
         * @return builder
         * 
         */
        public Builder buildDefinitionId(Output<Integer> buildDefinitionId) {
            $.buildDefinitionId = buildDefinitionId;
            return this;
        }

        /**
         * @param buildDefinitionId The ID of the build to monitor for the policy.
         * 
         * @return builder
         * 
         */
        public Builder buildDefinitionId(Integer buildDefinitionId) {
            return buildDefinitionId(Output.of(buildDefinitionId));
        }

        /**
         * @param displayName The display name for the policy.
         * 
         * @return builder
         * 
         */
        public Builder displayName(Output<String> displayName) {
            $.displayName = displayName;
            return this;
        }

        /**
         * @param displayName The display name for the policy.
         * 
         * @return builder
         * 
         */
        public Builder displayName(String displayName) {
            return displayName(Output.of(displayName));
        }

        /**
         * @param filenamePatterns If a path filter is set, the policy will only apply when files which match the filter are changes. Not setting this field means that the policy will always apply. You can specify absolute paths and wildcards. Example: `[&#34;/WebApp/Models/Data.cs&#34;, &#34;/WebApp/*&#34;, &#34;*.cs&#34;]`. Paths prefixed with &#34;!&#34; are excluded. Example: `[&#34;/WebApp/*&#34;, &#34;!/WebApp/Tests/*&#34;]`. Order is significant.
         * 
         * @return builder
         * 
         */
        public Builder filenamePatterns(@Nullable Output<List<String>> filenamePatterns) {
            $.filenamePatterns = filenamePatterns;
            return this;
        }

        /**
         * @param filenamePatterns If a path filter is set, the policy will only apply when files which match the filter are changes. Not setting this field means that the policy will always apply. You can specify absolute paths and wildcards. Example: `[&#34;/WebApp/Models/Data.cs&#34;, &#34;/WebApp/*&#34;, &#34;*.cs&#34;]`. Paths prefixed with &#34;!&#34; are excluded. Example: `[&#34;/WebApp/*&#34;, &#34;!/WebApp/Tests/*&#34;]`. Order is significant.
         * 
         * @return builder
         * 
         */
        public Builder filenamePatterns(List<String> filenamePatterns) {
            return filenamePatterns(Output.of(filenamePatterns));
        }

        /**
         * @param filenamePatterns If a path filter is set, the policy will only apply when files which match the filter are changes. Not setting this field means that the policy will always apply. You can specify absolute paths and wildcards. Example: `[&#34;/WebApp/Models/Data.cs&#34;, &#34;/WebApp/*&#34;, &#34;*.cs&#34;]`. Paths prefixed with &#34;!&#34; are excluded. Example: `[&#34;/WebApp/*&#34;, &#34;!/WebApp/Tests/*&#34;]`. Order is significant.
         * 
         * @return builder
         * 
         */
        public Builder filenamePatterns(String... filenamePatterns) {
            return filenamePatterns(List.of(filenamePatterns));
        }

        /**
         * @param manualQueueOnly If set to true, the build will need to be manually queued. Defaults to `false`
         * 
         * @return builder
         * 
         */
        public Builder manualQueueOnly(@Nullable Output<Boolean> manualQueueOnly) {
            $.manualQueueOnly = manualQueueOnly;
            return this;
        }

        /**
         * @param manualQueueOnly If set to true, the build will need to be manually queued. Defaults to `false`
         * 
         * @return builder
         * 
         */
        public Builder manualQueueOnly(Boolean manualQueueOnly) {
            return manualQueueOnly(Output.of(manualQueueOnly));
        }

        /**
         * @param queueOnSourceUpdateOnly True if the build should queue on source updates only. Defaults to `true`.
         * 
         * @return builder
         * 
         */
        public Builder queueOnSourceUpdateOnly(@Nullable Output<Boolean> queueOnSourceUpdateOnly) {
            $.queueOnSourceUpdateOnly = queueOnSourceUpdateOnly;
            return this;
        }

        /**
         * @param queueOnSourceUpdateOnly True if the build should queue on source updates only. Defaults to `true`.
         * 
         * @return builder
         * 
         */
        public Builder queueOnSourceUpdateOnly(Boolean queueOnSourceUpdateOnly) {
            return queueOnSourceUpdateOnly(Output.of(queueOnSourceUpdateOnly));
        }

        /**
         * @param scopes Controls which repositories and branches the policy will be enabled for. This block must be defined at least once.
         * 
         * @return builder
         * 
         */
        public Builder scopes(Output<List<BranchPolicyBuildValidationSettingsScopeArgs>> scopes) {
            $.scopes = scopes;
            return this;
        }

        /**
         * @param scopes Controls which repositories and branches the policy will be enabled for. This block must be defined at least once.
         * 
         * @return builder
         * 
         */
        public Builder scopes(List<BranchPolicyBuildValidationSettingsScopeArgs> scopes) {
            return scopes(Output.of(scopes));
        }

        /**
         * @param scopes Controls which repositories and branches the policy will be enabled for. This block must be defined at least once.
         * 
         * @return builder
         * 
         */
        public Builder scopes(BranchPolicyBuildValidationSettingsScopeArgs... scopes) {
            return scopes(List.of(scopes));
        }

        /**
         * @param validDuration The number of minutes for which the build is valid. If `0`, the build will not expire. Defaults to `720` (12 hours).
         * 
         * @return builder
         * 
         */
        public Builder validDuration(@Nullable Output<Integer> validDuration) {
            $.validDuration = validDuration;
            return this;
        }

        /**
         * @param validDuration The number of minutes for which the build is valid. If `0`, the build will not expire. Defaults to `720` (12 hours).
         * 
         * @return builder
         * 
         */
        public Builder validDuration(Integer validDuration) {
            return validDuration(Output.of(validDuration));
        }

        public BranchPolicyBuildValidationSettingsArgs build() {
            if ($.buildDefinitionId == null) {
                throw new MissingRequiredPropertyException("BranchPolicyBuildValidationSettingsArgs", "buildDefinitionId");
            }
            if ($.displayName == null) {
                throw new MissingRequiredPropertyException("BranchPolicyBuildValidationSettingsArgs", "displayName");
            }
            if ($.scopes == null) {
                throw new MissingRequiredPropertyException("BranchPolicyBuildValidationSettingsArgs", "scopes");
            }
            return $;
        }
    }

}
