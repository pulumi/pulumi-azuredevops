# coding=utf-8
# *** WARNING: this file was generated by the Pulumi Terraform Bridge (tfgen) Tool. ***
# *** Do not edit by hand unless you're certain you know what you are doing! ***

import copy
import warnings
import pulumi
import pulumi.runtime
from typing import Any, Callable, Mapping, Optional, Sequence, Union, overload
from .. import _utilities

__all__ = [
    'AzureRMCredentials',
    'GitHubAuthOauth',
    'GitHubAuthPersonal',
    'KubernetesAzureSubscription',
    'KubernetesKubeconfig',
    'KubernetesServiceAccount',
]

@pulumi.output_type
class AzureRMCredentials(dict):
    def __init__(__self__, *,
                 serviceprincipalid: str,
                 serviceprincipalkey: Optional[str] = None):
        """
        :param str serviceprincipalid: The service principal application Id
        :param str serviceprincipalkey: The service principal secret. This not required if `service_endpoint_authentication_scheme` is set to `WorkloadIdentityFederation`.
        """
        AzureRMCredentials._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            serviceprincipalid=serviceprincipalid,
            serviceprincipalkey=serviceprincipalkey,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             serviceprincipalid: Optional[str] = None,
             serviceprincipalkey: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if serviceprincipalid is None:
            raise TypeError("Missing 'serviceprincipalid' argument")

        _setter("serviceprincipalid", serviceprincipalid)
        if serviceprincipalkey is not None:
            _setter("serviceprincipalkey", serviceprincipalkey)

    @property
    @pulumi.getter
    def serviceprincipalid(self) -> str:
        """
        The service principal application Id
        """
        return pulumi.get(self, "serviceprincipalid")

    @property
    @pulumi.getter
    def serviceprincipalkey(self) -> Optional[str]:
        """
        The service principal secret. This not required if `service_endpoint_authentication_scheme` is set to `WorkloadIdentityFederation`.
        """
        return pulumi.get(self, "serviceprincipalkey")


@pulumi.output_type
class GitHubAuthOauth(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "oauthConfigurationId":
            suggest = "oauth_configuration_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in GitHubAuthOauth. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        GitHubAuthOauth.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        GitHubAuthOauth.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 oauth_configuration_id: str):
        GitHubAuthOauth._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            oauth_configuration_id=oauth_configuration_id,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             oauth_configuration_id: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if oauth_configuration_id is None and 'oauthConfigurationId' in kwargs:
            oauth_configuration_id = kwargs['oauthConfigurationId']
        if oauth_configuration_id is None:
            raise TypeError("Missing 'oauth_configuration_id' argument")

        _setter("oauth_configuration_id", oauth_configuration_id)

    @property
    @pulumi.getter(name="oauthConfigurationId")
    def oauth_configuration_id(self) -> str:
        return pulumi.get(self, "oauth_configuration_id")


@pulumi.output_type
class GitHubAuthPersonal(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "personalAccessToken":
            suggest = "personal_access_token"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in GitHubAuthPersonal. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        GitHubAuthPersonal.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        GitHubAuthPersonal.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 personal_access_token: str):
        """
        :param str personal_access_token: The Personal Access Token for GitHub.
        """
        GitHubAuthPersonal._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            personal_access_token=personal_access_token,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             personal_access_token: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if personal_access_token is None and 'personalAccessToken' in kwargs:
            personal_access_token = kwargs['personalAccessToken']
        if personal_access_token is None:
            raise TypeError("Missing 'personal_access_token' argument")

        _setter("personal_access_token", personal_access_token)

    @property
    @pulumi.getter(name="personalAccessToken")
    def personal_access_token(self) -> str:
        """
        The Personal Access Token for GitHub.
        """
        return pulumi.get(self, "personal_access_token")


@pulumi.output_type
class KubernetesAzureSubscription(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "clusterName":
            suggest = "cluster_name"
        elif key == "resourcegroupId":
            suggest = "resourcegroup_id"
        elif key == "subscriptionId":
            suggest = "subscription_id"
        elif key == "subscriptionName":
            suggest = "subscription_name"
        elif key == "tenantId":
            suggest = "tenant_id"
        elif key == "azureEnvironment":
            suggest = "azure_environment"
        elif key == "clusterAdmin":
            suggest = "cluster_admin"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in KubernetesAzureSubscription. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        KubernetesAzureSubscription.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        KubernetesAzureSubscription.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 cluster_name: str,
                 resourcegroup_id: str,
                 subscription_id: str,
                 subscription_name: str,
                 tenant_id: str,
                 azure_environment: Optional[str] = None,
                 cluster_admin: Optional[bool] = None,
                 namespace: Optional[str] = None):
        """
        :param str cluster_name: The name of the Kubernetes cluster.
        :param str resourcegroup_id: The resource group name, to which the Kubernetes cluster is deployed.
        :param str subscription_id: The id of the Azure subscription.
        :param str subscription_name: The name of the Azure subscription.
        :param str tenant_id: The id of the tenant used by the subscription.
        :param str azure_environment: Azure environment refers to whether the public cloud offering or domestic (government) clouds are being used. Currently, only the public cloud is supported. The value must be AzureCloud. This is also the default-value.
        :param bool cluster_admin: Set this option to allow use cluster admin credentials.
        :param str namespace: The Kubernetes namespace. Default value is "default".
        """
        KubernetesAzureSubscription._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            cluster_name=cluster_name,
            resourcegroup_id=resourcegroup_id,
            subscription_id=subscription_id,
            subscription_name=subscription_name,
            tenant_id=tenant_id,
            azure_environment=azure_environment,
            cluster_admin=cluster_admin,
            namespace=namespace,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             cluster_name: Optional[str] = None,
             resourcegroup_id: Optional[str] = None,
             subscription_id: Optional[str] = None,
             subscription_name: Optional[str] = None,
             tenant_id: Optional[str] = None,
             azure_environment: Optional[str] = None,
             cluster_admin: Optional[bool] = None,
             namespace: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if cluster_name is None and 'clusterName' in kwargs:
            cluster_name = kwargs['clusterName']
        if cluster_name is None:
            raise TypeError("Missing 'cluster_name' argument")
        if resourcegroup_id is None and 'resourcegroupId' in kwargs:
            resourcegroup_id = kwargs['resourcegroupId']
        if resourcegroup_id is None:
            raise TypeError("Missing 'resourcegroup_id' argument")
        if subscription_id is None and 'subscriptionId' in kwargs:
            subscription_id = kwargs['subscriptionId']
        if subscription_id is None:
            raise TypeError("Missing 'subscription_id' argument")
        if subscription_name is None and 'subscriptionName' in kwargs:
            subscription_name = kwargs['subscriptionName']
        if subscription_name is None:
            raise TypeError("Missing 'subscription_name' argument")
        if tenant_id is None and 'tenantId' in kwargs:
            tenant_id = kwargs['tenantId']
        if tenant_id is None:
            raise TypeError("Missing 'tenant_id' argument")
        if azure_environment is None and 'azureEnvironment' in kwargs:
            azure_environment = kwargs['azureEnvironment']
        if cluster_admin is None and 'clusterAdmin' in kwargs:
            cluster_admin = kwargs['clusterAdmin']

        _setter("cluster_name", cluster_name)
        _setter("resourcegroup_id", resourcegroup_id)
        _setter("subscription_id", subscription_id)
        _setter("subscription_name", subscription_name)
        _setter("tenant_id", tenant_id)
        if azure_environment is not None:
            _setter("azure_environment", azure_environment)
        if cluster_admin is not None:
            _setter("cluster_admin", cluster_admin)
        if namespace is not None:
            _setter("namespace", namespace)

    @property
    @pulumi.getter(name="clusterName")
    def cluster_name(self) -> str:
        """
        The name of the Kubernetes cluster.
        """
        return pulumi.get(self, "cluster_name")

    @property
    @pulumi.getter(name="resourcegroupId")
    def resourcegroup_id(self) -> str:
        """
        The resource group name, to which the Kubernetes cluster is deployed.
        """
        return pulumi.get(self, "resourcegroup_id")

    @property
    @pulumi.getter(name="subscriptionId")
    def subscription_id(self) -> str:
        """
        The id of the Azure subscription.
        """
        return pulumi.get(self, "subscription_id")

    @property
    @pulumi.getter(name="subscriptionName")
    def subscription_name(self) -> str:
        """
        The name of the Azure subscription.
        """
        return pulumi.get(self, "subscription_name")

    @property
    @pulumi.getter(name="tenantId")
    def tenant_id(self) -> str:
        """
        The id of the tenant used by the subscription.
        """
        return pulumi.get(self, "tenant_id")

    @property
    @pulumi.getter(name="azureEnvironment")
    def azure_environment(self) -> Optional[str]:
        """
        Azure environment refers to whether the public cloud offering or domestic (government) clouds are being used. Currently, only the public cloud is supported. The value must be AzureCloud. This is also the default-value.
        """
        return pulumi.get(self, "azure_environment")

    @property
    @pulumi.getter(name="clusterAdmin")
    def cluster_admin(self) -> Optional[bool]:
        """
        Set this option to allow use cluster admin credentials.
        """
        return pulumi.get(self, "cluster_admin")

    @property
    @pulumi.getter
    def namespace(self) -> Optional[str]:
        """
        The Kubernetes namespace. Default value is "default".
        """
        return pulumi.get(self, "namespace")


@pulumi.output_type
class KubernetesKubeconfig(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "kubeConfig":
            suggest = "kube_config"
        elif key == "acceptUntrustedCerts":
            suggest = "accept_untrusted_certs"
        elif key == "clusterContext":
            suggest = "cluster_context"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in KubernetesKubeconfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        KubernetesKubeconfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        KubernetesKubeconfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 kube_config: str,
                 accept_untrusted_certs: Optional[bool] = None,
                 cluster_context: Optional[str] = None):
        """
        :param str kube_config: The content of the kubeconfig in yaml notation to be used to communicate with the API-Server of Kubernetes.
        :param bool accept_untrusted_certs: Set this option to allow clients to accept a self-signed certificate.
        :param str cluster_context: Context within the kubeconfig file that is to be used for identifying the cluster. Default value is the current-context set in kubeconfig.
        """
        KubernetesKubeconfig._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            kube_config=kube_config,
            accept_untrusted_certs=accept_untrusted_certs,
            cluster_context=cluster_context,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             kube_config: Optional[str] = None,
             accept_untrusted_certs: Optional[bool] = None,
             cluster_context: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if kube_config is None and 'kubeConfig' in kwargs:
            kube_config = kwargs['kubeConfig']
        if kube_config is None:
            raise TypeError("Missing 'kube_config' argument")
        if accept_untrusted_certs is None and 'acceptUntrustedCerts' in kwargs:
            accept_untrusted_certs = kwargs['acceptUntrustedCerts']
        if cluster_context is None and 'clusterContext' in kwargs:
            cluster_context = kwargs['clusterContext']

        _setter("kube_config", kube_config)
        if accept_untrusted_certs is not None:
            _setter("accept_untrusted_certs", accept_untrusted_certs)
        if cluster_context is not None:
            _setter("cluster_context", cluster_context)

    @property
    @pulumi.getter(name="kubeConfig")
    def kube_config(self) -> str:
        """
        The content of the kubeconfig in yaml notation to be used to communicate with the API-Server of Kubernetes.
        """
        return pulumi.get(self, "kube_config")

    @property
    @pulumi.getter(name="acceptUntrustedCerts")
    def accept_untrusted_certs(self) -> Optional[bool]:
        """
        Set this option to allow clients to accept a self-signed certificate.
        """
        return pulumi.get(self, "accept_untrusted_certs")

    @property
    @pulumi.getter(name="clusterContext")
    def cluster_context(self) -> Optional[str]:
        """
        Context within the kubeconfig file that is to be used for identifying the cluster. Default value is the current-context set in kubeconfig.
        """
        return pulumi.get(self, "cluster_context")


@pulumi.output_type
class KubernetesServiceAccount(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "caCert":
            suggest = "ca_cert"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in KubernetesServiceAccount. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        KubernetesServiceAccount.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        KubernetesServiceAccount.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 ca_cert: str,
                 token: str):
        """
        :param str ca_cert: The certificate from a Kubernetes secret object.
        :param str token: The token from a Kubernetes secret object.
        """
        KubernetesServiceAccount._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            ca_cert=ca_cert,
            token=token,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             ca_cert: Optional[str] = None,
             token: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if ca_cert is None and 'caCert' in kwargs:
            ca_cert = kwargs['caCert']
        if ca_cert is None:
            raise TypeError("Missing 'ca_cert' argument")
        if token is None:
            raise TypeError("Missing 'token' argument")

        _setter("ca_cert", ca_cert)
        _setter("token", token)

    @property
    @pulumi.getter(name="caCert")
    def ca_cert(self) -> str:
        """
        The certificate from a Kubernetes secret object.
        """
        return pulumi.get(self, "ca_cert")

    @property
    @pulumi.getter
    def token(self) -> str:
        """
        The token from a Kubernetes secret object.
        """
        return pulumi.get(self, "token")


