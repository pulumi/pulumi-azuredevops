# coding=utf-8
# *** WARNING: this file was generated by the Pulumi Terraform Bridge (tfgen) Tool. ***
# *** Do not edit by hand unless you're certain you know what you are doing! ***

import warnings
import pulumi
import pulumi.runtime
from typing import Any, Mapping, Optional, Sequence, Union, overload
from . import _utilities

__all__ = [
    'BranchPolicyAutoReviewersSettingsArgs',
    'BranchPolicyAutoReviewersSettingsScopeArgs',
    'BranchPolicyBuildValidationSettingsArgs',
    'BranchPolicyBuildValidationSettingsScopeArgs',
    'BranchPolicyCommentResolutionSettingsArgs',
    'BranchPolicyCommentResolutionSettingsScopeArgs',
    'BranchPolicyMergeTypesSettingsArgs',
    'BranchPolicyMergeTypesSettingsScopeArgs',
    'BranchPolicyMinReviewersSettingsArgs',
    'BranchPolicyMinReviewersSettingsScopeArgs',
    'BranchPolicyWorkItemLinkingSettingsArgs',
    'BranchPolicyWorkItemLinkingSettingsScopeArgs',
    'BuildDefinitionCiTriggerArgs',
    'BuildDefinitionCiTriggerOverrideArgs',
    'BuildDefinitionCiTriggerOverrideBranchFilterArgs',
    'BuildDefinitionCiTriggerOverridePathFilterArgs',
    'BuildDefinitionPullRequestTriggerArgs',
    'BuildDefinitionPullRequestTriggerForksArgs',
    'BuildDefinitionPullRequestTriggerOverrideArgs',
    'BuildDefinitionPullRequestTriggerOverrideBranchFilterArgs',
    'BuildDefinitionPullRequestTriggerOverridePathFilterArgs',
    'BuildDefinitionRepositoryArgs',
    'BuildDefinitionVariableArgs',
    'GitInitializationArgs',
    'ServiceEndpointArtifactoryAuthenticationBasicArgs',
    'ServiceEndpointArtifactoryAuthenticationTokenArgs',
    'ServiceEndpointAzureRMCredentialsArgs',
    'ServiceEndpointGitHubAuthOauthArgs',
    'ServiceEndpointGitHubAuthPersonalArgs',
    'ServiceEndpointKubernetesAzureSubscriptionArgs',
    'ServiceEndpointKubernetesKubeconfigArgs',
    'ServiceEndpointKubernetesServiceAccountArgs',
    'ServiceEndpointPipelineAuthPersonalArgs',
    'VariableGroupKeyVaultArgs',
    'VariableGroupVariableArgs',
]

@pulumi.input_type
class BranchPolicyAutoReviewersSettingsArgs:
    def __init__(__self__, *,
                 auto_reviewer_ids: pulumi.Input[Sequence[pulumi.Input[str]]],
                 scopes: pulumi.Input[Sequence[pulumi.Input['BranchPolicyAutoReviewersSettingsScopeArgs']]],
                 message: Optional[pulumi.Input[str]] = None,
                 path_filters: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 submitter_can_vote: Optional[pulumi.Input[bool]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input[str]]] auto_reviewer_ids: Required reviewers ids. Supports multiples user Ids.
        :param pulumi.Input[Sequence[pulumi.Input['BranchPolicyAutoReviewersSettingsScopeArgs']]] scopes: Controls which repositories and branches the policy will be enabled for. This block must be defined at least once.
        :param pulumi.Input[str] message: Activity feed message, Message will appear in the activity feed of pull requests with automatically added reviewers.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] path_filters: Filter path(s) on which the policy is applied. Supports absolute paths, wildcards and multiple paths. Example: /WebApp/Models/Data.cs, /WebApp/* or *.cs,/WebApp/Models/Data.cs;ClientApp/Models/Data.cs.
        :param pulumi.Input[bool] submitter_can_vote: Controls whether or not the submitter's vote counts. Defaults to `false`.
        """
        pulumi.set(__self__, "auto_reviewer_ids", auto_reviewer_ids)
        pulumi.set(__self__, "scopes", scopes)
        if message is not None:
            pulumi.set(__self__, "message", message)
        if path_filters is not None:
            pulumi.set(__self__, "path_filters", path_filters)
        if submitter_can_vote is not None:
            pulumi.set(__self__, "submitter_can_vote", submitter_can_vote)

    @property
    @pulumi.getter(name="autoReviewerIds")
    def auto_reviewer_ids(self) -> pulumi.Input[Sequence[pulumi.Input[str]]]:
        """
        Required reviewers ids. Supports multiples user Ids.
        """
        return pulumi.get(self, "auto_reviewer_ids")

    @auto_reviewer_ids.setter
    def auto_reviewer_ids(self, value: pulumi.Input[Sequence[pulumi.Input[str]]]):
        pulumi.set(self, "auto_reviewer_ids", value)

    @property
    @pulumi.getter
    def scopes(self) -> pulumi.Input[Sequence[pulumi.Input['BranchPolicyAutoReviewersSettingsScopeArgs']]]:
        """
        Controls which repositories and branches the policy will be enabled for. This block must be defined at least once.
        """
        return pulumi.get(self, "scopes")

    @scopes.setter
    def scopes(self, value: pulumi.Input[Sequence[pulumi.Input['BranchPolicyAutoReviewersSettingsScopeArgs']]]):
        pulumi.set(self, "scopes", value)

    @property
    @pulumi.getter
    def message(self) -> Optional[pulumi.Input[str]]:
        """
        Activity feed message, Message will appear in the activity feed of pull requests with automatically added reviewers.
        """
        return pulumi.get(self, "message")

    @message.setter
    def message(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "message", value)

    @property
    @pulumi.getter(name="pathFilters")
    def path_filters(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Filter path(s) on which the policy is applied. Supports absolute paths, wildcards and multiple paths. Example: /WebApp/Models/Data.cs, /WebApp/* or *.cs,/WebApp/Models/Data.cs;ClientApp/Models/Data.cs.
        """
        return pulumi.get(self, "path_filters")

    @path_filters.setter
    def path_filters(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "path_filters", value)

    @property
    @pulumi.getter(name="submitterCanVote")
    def submitter_can_vote(self) -> Optional[pulumi.Input[bool]]:
        """
        Controls whether or not the submitter's vote counts. Defaults to `false`.
        """
        return pulumi.get(self, "submitter_can_vote")

    @submitter_can_vote.setter
    def submitter_can_vote(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "submitter_can_vote", value)


@pulumi.input_type
class BranchPolicyAutoReviewersSettingsScopeArgs:
    def __init__(__self__, *,
                 match_type: Optional[pulumi.Input[str]] = None,
                 repository_id: Optional[pulumi.Input[str]] = None,
                 repository_ref: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] match_type: The match type to use when applying the policy. Supported values are `Exact` (default) or `Prefix`.
        :param pulumi.Input[str] repository_id: The repository ID. Needed only if the scope of the policy will be limited to a single repository.
        :param pulumi.Input[str] repository_ref: The ref pattern to use for the match. If `match_type` is `Exact`, this should be a qualified ref such as `refs/heads/master`. If `match_type` is `Prefix`, this should be a ref path such as `refs/heads/releases`.
        """
        if match_type is not None:
            pulumi.set(__self__, "match_type", match_type)
        if repository_id is not None:
            pulumi.set(__self__, "repository_id", repository_id)
        if repository_ref is not None:
            pulumi.set(__self__, "repository_ref", repository_ref)

    @property
    @pulumi.getter(name="matchType")
    def match_type(self) -> Optional[pulumi.Input[str]]:
        """
        The match type to use when applying the policy. Supported values are `Exact` (default) or `Prefix`.
        """
        return pulumi.get(self, "match_type")

    @match_type.setter
    def match_type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "match_type", value)

    @property
    @pulumi.getter(name="repositoryId")
    def repository_id(self) -> Optional[pulumi.Input[str]]:
        """
        The repository ID. Needed only if the scope of the policy will be limited to a single repository.
        """
        return pulumi.get(self, "repository_id")

    @repository_id.setter
    def repository_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "repository_id", value)

    @property
    @pulumi.getter(name="repositoryRef")
    def repository_ref(self) -> Optional[pulumi.Input[str]]:
        """
        The ref pattern to use for the match. If `match_type` is `Exact`, this should be a qualified ref such as `refs/heads/master`. If `match_type` is `Prefix`, this should be a ref path such as `refs/heads/releases`.
        """
        return pulumi.get(self, "repository_ref")

    @repository_ref.setter
    def repository_ref(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "repository_ref", value)


@pulumi.input_type
class BranchPolicyBuildValidationSettingsArgs:
    def __init__(__self__, *,
                 build_definition_id: pulumi.Input[int],
                 display_name: pulumi.Input[str],
                 scopes: pulumi.Input[Sequence[pulumi.Input['BranchPolicyBuildValidationSettingsScopeArgs']]],
                 filename_patterns: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 manual_queue_only: Optional[pulumi.Input[bool]] = None,
                 queue_on_source_update_only: Optional[pulumi.Input[bool]] = None,
                 valid_duration: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input[int] build_definition_id: The ID of the build to monitor for the policy.
        :param pulumi.Input[str] display_name: The display name for the policy.
        :param pulumi.Input[Sequence[pulumi.Input['BranchPolicyBuildValidationSettingsScopeArgs']]] scopes: Controls which repositories and branches the policy will be enabled for. This block must be defined at least once.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] filename_patterns: If a path filter is set, the policy wil only apply when files which match the filter are changes. Not setting this field means that the policy will always apply. You can specify absolute paths and wildcards. Example: `["/WebApp/Models/Data.cs", "/WebApp/*", "*.cs"]`. Paths prefixed with "!" are excluded. Example: `["/WebApp/*", "!/WebApp/Tests/*"]`. Order is significant.
        :param pulumi.Input[bool] manual_queue_only: If set to true, the build will need to be manually queued. Defaults to `false`
        :param pulumi.Input[bool] queue_on_source_update_only: True if the build should queue on source updates only. Defaults to `true`.
        :param pulumi.Input[int] valid_duration: The number of minutes for which the build is valid. If `0`, the build will not expire. Defaults to `720` (12 hours).
        """
        pulumi.set(__self__, "build_definition_id", build_definition_id)
        pulumi.set(__self__, "display_name", display_name)
        pulumi.set(__self__, "scopes", scopes)
        if filename_patterns is not None:
            pulumi.set(__self__, "filename_patterns", filename_patterns)
        if manual_queue_only is not None:
            pulumi.set(__self__, "manual_queue_only", manual_queue_only)
        if queue_on_source_update_only is not None:
            pulumi.set(__self__, "queue_on_source_update_only", queue_on_source_update_only)
        if valid_duration is not None:
            pulumi.set(__self__, "valid_duration", valid_duration)

    @property
    @pulumi.getter(name="buildDefinitionId")
    def build_definition_id(self) -> pulumi.Input[int]:
        """
        The ID of the build to monitor for the policy.
        """
        return pulumi.get(self, "build_definition_id")

    @build_definition_id.setter
    def build_definition_id(self, value: pulumi.Input[int]):
        pulumi.set(self, "build_definition_id", value)

    @property
    @pulumi.getter(name="displayName")
    def display_name(self) -> pulumi.Input[str]:
        """
        The display name for the policy.
        """
        return pulumi.get(self, "display_name")

    @display_name.setter
    def display_name(self, value: pulumi.Input[str]):
        pulumi.set(self, "display_name", value)

    @property
    @pulumi.getter
    def scopes(self) -> pulumi.Input[Sequence[pulumi.Input['BranchPolicyBuildValidationSettingsScopeArgs']]]:
        """
        Controls which repositories and branches the policy will be enabled for. This block must be defined at least once.
        """
        return pulumi.get(self, "scopes")

    @scopes.setter
    def scopes(self, value: pulumi.Input[Sequence[pulumi.Input['BranchPolicyBuildValidationSettingsScopeArgs']]]):
        pulumi.set(self, "scopes", value)

    @property
    @pulumi.getter(name="filenamePatterns")
    def filename_patterns(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        If a path filter is set, the policy wil only apply when files which match the filter are changes. Not setting this field means that the policy will always apply. You can specify absolute paths and wildcards. Example: `["/WebApp/Models/Data.cs", "/WebApp/*", "*.cs"]`. Paths prefixed with "!" are excluded. Example: `["/WebApp/*", "!/WebApp/Tests/*"]`. Order is significant.
        """
        return pulumi.get(self, "filename_patterns")

    @filename_patterns.setter
    def filename_patterns(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "filename_patterns", value)

    @property
    @pulumi.getter(name="manualQueueOnly")
    def manual_queue_only(self) -> Optional[pulumi.Input[bool]]:
        """
        If set to true, the build will need to be manually queued. Defaults to `false`
        """
        return pulumi.get(self, "manual_queue_only")

    @manual_queue_only.setter
    def manual_queue_only(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "manual_queue_only", value)

    @property
    @pulumi.getter(name="queueOnSourceUpdateOnly")
    def queue_on_source_update_only(self) -> Optional[pulumi.Input[bool]]:
        """
        True if the build should queue on source updates only. Defaults to `true`.
        """
        return pulumi.get(self, "queue_on_source_update_only")

    @queue_on_source_update_only.setter
    def queue_on_source_update_only(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "queue_on_source_update_only", value)

    @property
    @pulumi.getter(name="validDuration")
    def valid_duration(self) -> Optional[pulumi.Input[int]]:
        """
        The number of minutes for which the build is valid. If `0`, the build will not expire. Defaults to `720` (12 hours).
        """
        return pulumi.get(self, "valid_duration")

    @valid_duration.setter
    def valid_duration(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "valid_duration", value)


@pulumi.input_type
class BranchPolicyBuildValidationSettingsScopeArgs:
    def __init__(__self__, *,
                 match_type: Optional[pulumi.Input[str]] = None,
                 repository_id: Optional[pulumi.Input[str]] = None,
                 repository_ref: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] match_type: The match type to use when applying the policy. Supported values are `Exact` (default) or `Prefix`.
        :param pulumi.Input[str] repository_id: The repository ID. Needed only if the scope of the policy will be limited to a single repository.
        :param pulumi.Input[str] repository_ref: The ref pattern to use for the match. If `match_type` is `Exact`, this should be a qualified ref such as `refs/heads/master`. If `match_type` is `Prefix`, this should be a ref path such as `refs/heads/releases`.
        """
        if match_type is not None:
            pulumi.set(__self__, "match_type", match_type)
        if repository_id is not None:
            pulumi.set(__self__, "repository_id", repository_id)
        if repository_ref is not None:
            pulumi.set(__self__, "repository_ref", repository_ref)

    @property
    @pulumi.getter(name="matchType")
    def match_type(self) -> Optional[pulumi.Input[str]]:
        """
        The match type to use when applying the policy. Supported values are `Exact` (default) or `Prefix`.
        """
        return pulumi.get(self, "match_type")

    @match_type.setter
    def match_type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "match_type", value)

    @property
    @pulumi.getter(name="repositoryId")
    def repository_id(self) -> Optional[pulumi.Input[str]]:
        """
        The repository ID. Needed only if the scope of the policy will be limited to a single repository.
        """
        return pulumi.get(self, "repository_id")

    @repository_id.setter
    def repository_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "repository_id", value)

    @property
    @pulumi.getter(name="repositoryRef")
    def repository_ref(self) -> Optional[pulumi.Input[str]]:
        """
        The ref pattern to use for the match. If `match_type` is `Exact`, this should be a qualified ref such as `refs/heads/master`. If `match_type` is `Prefix`, this should be a ref path such as `refs/heads/releases`.
        """
        return pulumi.get(self, "repository_ref")

    @repository_ref.setter
    def repository_ref(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "repository_ref", value)


@pulumi.input_type
class BranchPolicyCommentResolutionSettingsArgs:
    def __init__(__self__, *,
                 scopes: pulumi.Input[Sequence[pulumi.Input['BranchPolicyCommentResolutionSettingsScopeArgs']]]):
        """
        :param pulumi.Input[Sequence[pulumi.Input['BranchPolicyCommentResolutionSettingsScopeArgs']]] scopes: Controls which repositories and branches the policy will be enabled for. This block must be defined at least once.
        """
        pulumi.set(__self__, "scopes", scopes)

    @property
    @pulumi.getter
    def scopes(self) -> pulumi.Input[Sequence[pulumi.Input['BranchPolicyCommentResolutionSettingsScopeArgs']]]:
        """
        Controls which repositories and branches the policy will be enabled for. This block must be defined at least once.
        """
        return pulumi.get(self, "scopes")

    @scopes.setter
    def scopes(self, value: pulumi.Input[Sequence[pulumi.Input['BranchPolicyCommentResolutionSettingsScopeArgs']]]):
        pulumi.set(self, "scopes", value)


@pulumi.input_type
class BranchPolicyCommentResolutionSettingsScopeArgs:
    def __init__(__self__, *,
                 match_type: Optional[pulumi.Input[str]] = None,
                 repository_id: Optional[pulumi.Input[str]] = None,
                 repository_ref: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] match_type: The match type to use when applying the policy. Supported values are `Exact` (default) or `Prefix`.
        :param pulumi.Input[str] repository_id: The repository ID. Needed only if the scope of the policy will be limited to a single repository.
        :param pulumi.Input[str] repository_ref: The ref pattern to use for the match. If `match_type` is `Exact`, this should be a qualified ref such as `refs/heads/master`. If `match_type` is `Prefix`, this should be a ref path such as `refs/heads/releases`.
        """
        if match_type is not None:
            pulumi.set(__self__, "match_type", match_type)
        if repository_id is not None:
            pulumi.set(__self__, "repository_id", repository_id)
        if repository_ref is not None:
            pulumi.set(__self__, "repository_ref", repository_ref)

    @property
    @pulumi.getter(name="matchType")
    def match_type(self) -> Optional[pulumi.Input[str]]:
        """
        The match type to use when applying the policy. Supported values are `Exact` (default) or `Prefix`.
        """
        return pulumi.get(self, "match_type")

    @match_type.setter
    def match_type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "match_type", value)

    @property
    @pulumi.getter(name="repositoryId")
    def repository_id(self) -> Optional[pulumi.Input[str]]:
        """
        The repository ID. Needed only if the scope of the policy will be limited to a single repository.
        """
        return pulumi.get(self, "repository_id")

    @repository_id.setter
    def repository_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "repository_id", value)

    @property
    @pulumi.getter(name="repositoryRef")
    def repository_ref(self) -> Optional[pulumi.Input[str]]:
        """
        The ref pattern to use for the match. If `match_type` is `Exact`, this should be a qualified ref such as `refs/heads/master`. If `match_type` is `Prefix`, this should be a ref path such as `refs/heads/releases`.
        """
        return pulumi.get(self, "repository_ref")

    @repository_ref.setter
    def repository_ref(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "repository_ref", value)


@pulumi.input_type
class BranchPolicyMergeTypesSettingsArgs:
    def __init__(__self__, *,
                 scopes: pulumi.Input[Sequence[pulumi.Input['BranchPolicyMergeTypesSettingsScopeArgs']]],
                 allow_basic_no_fast_forward: Optional[pulumi.Input[bool]] = None,
                 allow_rebase_and_fast_forward: Optional[pulumi.Input[bool]] = None,
                 allow_rebase_with_merge: Optional[pulumi.Input[bool]] = None,
                 allow_squash: Optional[pulumi.Input[bool]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input['BranchPolicyMergeTypesSettingsScopeArgs']]] scopes: Controls which repositories and branches the policy will be enabled for. This block must be defined at least once.
        :param pulumi.Input[bool] allow_basic_no_fast_forward: Allow basic merge with no fast forward. Defaults to `false`.
        :param pulumi.Input[bool] allow_rebase_and_fast_forward: Allow rebase with fast forward. Defaults to `false`.
        :param pulumi.Input[bool] allow_rebase_with_merge: Allow rebase with merge commit. Defaults to `false`.
        :param pulumi.Input[bool] allow_squash: Allow squash merge. Defaults to `false`
        """
        pulumi.set(__self__, "scopes", scopes)
        if allow_basic_no_fast_forward is not None:
            pulumi.set(__self__, "allow_basic_no_fast_forward", allow_basic_no_fast_forward)
        if allow_rebase_and_fast_forward is not None:
            pulumi.set(__self__, "allow_rebase_and_fast_forward", allow_rebase_and_fast_forward)
        if allow_rebase_with_merge is not None:
            pulumi.set(__self__, "allow_rebase_with_merge", allow_rebase_with_merge)
        if allow_squash is not None:
            pulumi.set(__self__, "allow_squash", allow_squash)

    @property
    @pulumi.getter
    def scopes(self) -> pulumi.Input[Sequence[pulumi.Input['BranchPolicyMergeTypesSettingsScopeArgs']]]:
        """
        Controls which repositories and branches the policy will be enabled for. This block must be defined at least once.
        """
        return pulumi.get(self, "scopes")

    @scopes.setter
    def scopes(self, value: pulumi.Input[Sequence[pulumi.Input['BranchPolicyMergeTypesSettingsScopeArgs']]]):
        pulumi.set(self, "scopes", value)

    @property
    @pulumi.getter(name="allowBasicNoFastForward")
    def allow_basic_no_fast_forward(self) -> Optional[pulumi.Input[bool]]:
        """
        Allow basic merge with no fast forward. Defaults to `false`.
        """
        return pulumi.get(self, "allow_basic_no_fast_forward")

    @allow_basic_no_fast_forward.setter
    def allow_basic_no_fast_forward(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "allow_basic_no_fast_forward", value)

    @property
    @pulumi.getter(name="allowRebaseAndFastForward")
    def allow_rebase_and_fast_forward(self) -> Optional[pulumi.Input[bool]]:
        """
        Allow rebase with fast forward. Defaults to `false`.
        """
        return pulumi.get(self, "allow_rebase_and_fast_forward")

    @allow_rebase_and_fast_forward.setter
    def allow_rebase_and_fast_forward(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "allow_rebase_and_fast_forward", value)

    @property
    @pulumi.getter(name="allowRebaseWithMerge")
    def allow_rebase_with_merge(self) -> Optional[pulumi.Input[bool]]:
        """
        Allow rebase with merge commit. Defaults to `false`.
        """
        return pulumi.get(self, "allow_rebase_with_merge")

    @allow_rebase_with_merge.setter
    def allow_rebase_with_merge(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "allow_rebase_with_merge", value)

    @property
    @pulumi.getter(name="allowSquash")
    def allow_squash(self) -> Optional[pulumi.Input[bool]]:
        """
        Allow squash merge. Defaults to `false`
        """
        return pulumi.get(self, "allow_squash")

    @allow_squash.setter
    def allow_squash(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "allow_squash", value)


@pulumi.input_type
class BranchPolicyMergeTypesSettingsScopeArgs:
    def __init__(__self__, *,
                 match_type: Optional[pulumi.Input[str]] = None,
                 repository_id: Optional[pulumi.Input[str]] = None,
                 repository_ref: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] match_type: The match type to use when applying the policy. Supported values are `Exact` (default) or `Prefix`.
        :param pulumi.Input[str] repository_id: The repository ID. Needed only if the scope of the policy will be limited to a single repository.
        :param pulumi.Input[str] repository_ref: The ref pattern to use for the match. If `match_type` is `Exact`, this should be a qualified ref such as `refs/heads/master`. If `match_type` is `Prefix`, this should be a ref path such as `refs/heads/releases`.
        """
        if match_type is not None:
            pulumi.set(__self__, "match_type", match_type)
        if repository_id is not None:
            pulumi.set(__self__, "repository_id", repository_id)
        if repository_ref is not None:
            pulumi.set(__self__, "repository_ref", repository_ref)

    @property
    @pulumi.getter(name="matchType")
    def match_type(self) -> Optional[pulumi.Input[str]]:
        """
        The match type to use when applying the policy. Supported values are `Exact` (default) or `Prefix`.
        """
        return pulumi.get(self, "match_type")

    @match_type.setter
    def match_type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "match_type", value)

    @property
    @pulumi.getter(name="repositoryId")
    def repository_id(self) -> Optional[pulumi.Input[str]]:
        """
        The repository ID. Needed only if the scope of the policy will be limited to a single repository.
        """
        return pulumi.get(self, "repository_id")

    @repository_id.setter
    def repository_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "repository_id", value)

    @property
    @pulumi.getter(name="repositoryRef")
    def repository_ref(self) -> Optional[pulumi.Input[str]]:
        """
        The ref pattern to use for the match. If `match_type` is `Exact`, this should be a qualified ref such as `refs/heads/master`. If `match_type` is `Prefix`, this should be a ref path such as `refs/heads/releases`.
        """
        return pulumi.get(self, "repository_ref")

    @repository_ref.setter
    def repository_ref(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "repository_ref", value)


@pulumi.input_type
class BranchPolicyMinReviewersSettingsArgs:
    def __init__(__self__, *,
                 scopes: pulumi.Input[Sequence[pulumi.Input['BranchPolicyMinReviewersSettingsScopeArgs']]],
                 allow_completion_with_rejects_or_waits: Optional[pulumi.Input[bool]] = None,
                 last_pusher_cannot_approve: Optional[pulumi.Input[bool]] = None,
                 on_last_iteration_require_vote: Optional[pulumi.Input[bool]] = None,
                 on_push_reset_all_votes: Optional[pulumi.Input[bool]] = None,
                 on_push_reset_approved_votes: Optional[pulumi.Input[bool]] = None,
                 reviewer_count: Optional[pulumi.Input[int]] = None,
                 submitter_can_vote: Optional[pulumi.Input[bool]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input['BranchPolicyMinReviewersSettingsScopeArgs']]] scopes: Controls which repositories and branches the policy will be enabled for. This block must be defined at least once.
        :param pulumi.Input[bool] allow_completion_with_rejects_or_waits: Allow completion even if some reviewers vote to wait or reject. Defaults to `false`.
        :param pulumi.Input[bool] last_pusher_cannot_approve: Prohibit the most recent pusher from approving their own changes. Defaults to `false`.
        :param pulumi.Input[bool] on_last_iteration_require_vote: On last iteration require vote. Defaults to `false`.
        :param pulumi.Input[bool] on_push_reset_all_votes: When new changes are pushed reset all code reviewer votes. Defaults to `false`.
        :param pulumi.Input[bool] on_push_reset_approved_votes: When new changes are pushed reset all approval votes (does not reset votes to reject or wait). Defaults to `false`.
        :param pulumi.Input[int] reviewer_count: The number of reviewers needed to approve.
        :param pulumi.Input[bool] submitter_can_vote: Allow requesters to approve their own changes. Defaults to `false`.
        """
        pulumi.set(__self__, "scopes", scopes)
        if allow_completion_with_rejects_or_waits is not None:
            pulumi.set(__self__, "allow_completion_with_rejects_or_waits", allow_completion_with_rejects_or_waits)
        if last_pusher_cannot_approve is not None:
            pulumi.set(__self__, "last_pusher_cannot_approve", last_pusher_cannot_approve)
        if on_last_iteration_require_vote is not None:
            pulumi.set(__self__, "on_last_iteration_require_vote", on_last_iteration_require_vote)
        if on_push_reset_all_votes is not None:
            pulumi.set(__self__, "on_push_reset_all_votes", on_push_reset_all_votes)
        if on_push_reset_approved_votes is not None:
            pulumi.set(__self__, "on_push_reset_approved_votes", on_push_reset_approved_votes)
        if reviewer_count is not None:
            pulumi.set(__self__, "reviewer_count", reviewer_count)
        if submitter_can_vote is not None:
            pulumi.set(__self__, "submitter_can_vote", submitter_can_vote)

    @property
    @pulumi.getter
    def scopes(self) -> pulumi.Input[Sequence[pulumi.Input['BranchPolicyMinReviewersSettingsScopeArgs']]]:
        """
        Controls which repositories and branches the policy will be enabled for. This block must be defined at least once.
        """
        return pulumi.get(self, "scopes")

    @scopes.setter
    def scopes(self, value: pulumi.Input[Sequence[pulumi.Input['BranchPolicyMinReviewersSettingsScopeArgs']]]):
        pulumi.set(self, "scopes", value)

    @property
    @pulumi.getter(name="allowCompletionWithRejectsOrWaits")
    def allow_completion_with_rejects_or_waits(self) -> Optional[pulumi.Input[bool]]:
        """
        Allow completion even if some reviewers vote to wait or reject. Defaults to `false`.
        """
        return pulumi.get(self, "allow_completion_with_rejects_or_waits")

    @allow_completion_with_rejects_or_waits.setter
    def allow_completion_with_rejects_or_waits(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "allow_completion_with_rejects_or_waits", value)

    @property
    @pulumi.getter(name="lastPusherCannotApprove")
    def last_pusher_cannot_approve(self) -> Optional[pulumi.Input[bool]]:
        """
        Prohibit the most recent pusher from approving their own changes. Defaults to `false`.
        """
        return pulumi.get(self, "last_pusher_cannot_approve")

    @last_pusher_cannot_approve.setter
    def last_pusher_cannot_approve(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "last_pusher_cannot_approve", value)

    @property
    @pulumi.getter(name="onLastIterationRequireVote")
    def on_last_iteration_require_vote(self) -> Optional[pulumi.Input[bool]]:
        """
        On last iteration require vote. Defaults to `false`.
        """
        return pulumi.get(self, "on_last_iteration_require_vote")

    @on_last_iteration_require_vote.setter
    def on_last_iteration_require_vote(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "on_last_iteration_require_vote", value)

    @property
    @pulumi.getter(name="onPushResetAllVotes")
    def on_push_reset_all_votes(self) -> Optional[pulumi.Input[bool]]:
        """
        When new changes are pushed reset all code reviewer votes. Defaults to `false`.
        """
        return pulumi.get(self, "on_push_reset_all_votes")

    @on_push_reset_all_votes.setter
    def on_push_reset_all_votes(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "on_push_reset_all_votes", value)

    @property
    @pulumi.getter(name="onPushResetApprovedVotes")
    def on_push_reset_approved_votes(self) -> Optional[pulumi.Input[bool]]:
        """
        When new changes are pushed reset all approval votes (does not reset votes to reject or wait). Defaults to `false`.
        """
        return pulumi.get(self, "on_push_reset_approved_votes")

    @on_push_reset_approved_votes.setter
    def on_push_reset_approved_votes(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "on_push_reset_approved_votes", value)

    @property
    @pulumi.getter(name="reviewerCount")
    def reviewer_count(self) -> Optional[pulumi.Input[int]]:
        """
        The number of reviewers needed to approve.
        """
        return pulumi.get(self, "reviewer_count")

    @reviewer_count.setter
    def reviewer_count(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "reviewer_count", value)

    @property
    @pulumi.getter(name="submitterCanVote")
    def submitter_can_vote(self) -> Optional[pulumi.Input[bool]]:
        """
        Allow requesters to approve their own changes. Defaults to `false`.
        """
        return pulumi.get(self, "submitter_can_vote")

    @submitter_can_vote.setter
    def submitter_can_vote(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "submitter_can_vote", value)


@pulumi.input_type
class BranchPolicyMinReviewersSettingsScopeArgs:
    def __init__(__self__, *,
                 match_type: Optional[pulumi.Input[str]] = None,
                 repository_id: Optional[pulumi.Input[str]] = None,
                 repository_ref: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] match_type: The match type to use when applying the policy. Supported values are `Exact` (default) or `Prefix`.
        :param pulumi.Input[str] repository_id: The repository ID. Needed only if the scope of the policy will be limited to a single repository.
        :param pulumi.Input[str] repository_ref: The ref pattern to use for the match. If `match_type` is `Exact`, this should be a qualified ref such as `refs/heads/master`. If `match_type` is `Prefix`, this should be a ref path such as `refs/heads/releases`.
        """
        if match_type is not None:
            pulumi.set(__self__, "match_type", match_type)
        if repository_id is not None:
            pulumi.set(__self__, "repository_id", repository_id)
        if repository_ref is not None:
            pulumi.set(__self__, "repository_ref", repository_ref)

    @property
    @pulumi.getter(name="matchType")
    def match_type(self) -> Optional[pulumi.Input[str]]:
        """
        The match type to use when applying the policy. Supported values are `Exact` (default) or `Prefix`.
        """
        return pulumi.get(self, "match_type")

    @match_type.setter
    def match_type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "match_type", value)

    @property
    @pulumi.getter(name="repositoryId")
    def repository_id(self) -> Optional[pulumi.Input[str]]:
        """
        The repository ID. Needed only if the scope of the policy will be limited to a single repository.
        """
        return pulumi.get(self, "repository_id")

    @repository_id.setter
    def repository_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "repository_id", value)

    @property
    @pulumi.getter(name="repositoryRef")
    def repository_ref(self) -> Optional[pulumi.Input[str]]:
        """
        The ref pattern to use for the match. If `match_type` is `Exact`, this should be a qualified ref such as `refs/heads/master`. If `match_type` is `Prefix`, this should be a ref path such as `refs/heads/releases`.
        """
        return pulumi.get(self, "repository_ref")

    @repository_ref.setter
    def repository_ref(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "repository_ref", value)


@pulumi.input_type
class BranchPolicyWorkItemLinkingSettingsArgs:
    def __init__(__self__, *,
                 scopes: pulumi.Input[Sequence[pulumi.Input['BranchPolicyWorkItemLinkingSettingsScopeArgs']]]):
        """
        :param pulumi.Input[Sequence[pulumi.Input['BranchPolicyWorkItemLinkingSettingsScopeArgs']]] scopes: Controls which repositories and branches the policy will be enabled for. This block must be defined at least once.
        """
        pulumi.set(__self__, "scopes", scopes)

    @property
    @pulumi.getter
    def scopes(self) -> pulumi.Input[Sequence[pulumi.Input['BranchPolicyWorkItemLinkingSettingsScopeArgs']]]:
        """
        Controls which repositories and branches the policy will be enabled for. This block must be defined at least once.
        """
        return pulumi.get(self, "scopes")

    @scopes.setter
    def scopes(self, value: pulumi.Input[Sequence[pulumi.Input['BranchPolicyWorkItemLinkingSettingsScopeArgs']]]):
        pulumi.set(self, "scopes", value)


@pulumi.input_type
class BranchPolicyWorkItemLinkingSettingsScopeArgs:
    def __init__(__self__, *,
                 match_type: Optional[pulumi.Input[str]] = None,
                 repository_id: Optional[pulumi.Input[str]] = None,
                 repository_ref: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] match_type: The match type to use when applying the policy. Supported values are `Exact` (default) or `Prefix`.
        :param pulumi.Input[str] repository_id: The repository ID. Needed only if the scope of the policy will be limited to a single repository.
        :param pulumi.Input[str] repository_ref: The ref pattern to use for the match. If `match_type` is `Exact`, this should be a qualified ref such as `refs/heads/master`. If `match_type` is `Prefix`, this should be a ref path such as `refs/heads/releases`.
        """
        if match_type is not None:
            pulumi.set(__self__, "match_type", match_type)
        if repository_id is not None:
            pulumi.set(__self__, "repository_id", repository_id)
        if repository_ref is not None:
            pulumi.set(__self__, "repository_ref", repository_ref)

    @property
    @pulumi.getter(name="matchType")
    def match_type(self) -> Optional[pulumi.Input[str]]:
        """
        The match type to use when applying the policy. Supported values are `Exact` (default) or `Prefix`.
        """
        return pulumi.get(self, "match_type")

    @match_type.setter
    def match_type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "match_type", value)

    @property
    @pulumi.getter(name="repositoryId")
    def repository_id(self) -> Optional[pulumi.Input[str]]:
        """
        The repository ID. Needed only if the scope of the policy will be limited to a single repository.
        """
        return pulumi.get(self, "repository_id")

    @repository_id.setter
    def repository_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "repository_id", value)

    @property
    @pulumi.getter(name="repositoryRef")
    def repository_ref(self) -> Optional[pulumi.Input[str]]:
        """
        The ref pattern to use for the match. If `match_type` is `Exact`, this should be a qualified ref such as `refs/heads/master`. If `match_type` is `Prefix`, this should be a ref path such as `refs/heads/releases`.
        """
        return pulumi.get(self, "repository_ref")

    @repository_ref.setter
    def repository_ref(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "repository_ref", value)


@pulumi.input_type
class BuildDefinitionCiTriggerArgs:
    def __init__(__self__, *,
                 override: Optional[pulumi.Input['BuildDefinitionCiTriggerOverrideArgs']] = None,
                 use_yaml: Optional[pulumi.Input[bool]] = None):
        """
        :param pulumi.Input['BuildDefinitionCiTriggerOverrideArgs'] override: Override the azure-pipeline file and use a this configuration for all builds.
        :param pulumi.Input[bool] use_yaml: Use the azure-pipeline file for the build configuration. Defaults to `false`.
        """
        if override is not None:
            pulumi.set(__self__, "override", override)
        if use_yaml is not None:
            pulumi.set(__self__, "use_yaml", use_yaml)

    @property
    @pulumi.getter
    def override(self) -> Optional[pulumi.Input['BuildDefinitionCiTriggerOverrideArgs']]:
        """
        Override the azure-pipeline file and use a this configuration for all builds.
        """
        return pulumi.get(self, "override")

    @override.setter
    def override(self, value: Optional[pulumi.Input['BuildDefinitionCiTriggerOverrideArgs']]):
        pulumi.set(self, "override", value)

    @property
    @pulumi.getter(name="useYaml")
    def use_yaml(self) -> Optional[pulumi.Input[bool]]:
        """
        Use the azure-pipeline file for the build configuration. Defaults to `false`.
        """
        return pulumi.get(self, "use_yaml")

    @use_yaml.setter
    def use_yaml(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "use_yaml", value)


@pulumi.input_type
class BuildDefinitionCiTriggerOverrideArgs:
    def __init__(__self__, *,
                 batch: Optional[pulumi.Input[bool]] = None,
                 branch_filters: Optional[pulumi.Input[Sequence[pulumi.Input['BuildDefinitionCiTriggerOverrideBranchFilterArgs']]]] = None,
                 max_concurrent_builds_per_branch: Optional[pulumi.Input[int]] = None,
                 path_filters: Optional[pulumi.Input[Sequence[pulumi.Input['BuildDefinitionCiTriggerOverridePathFilterArgs']]]] = None,
                 polling_interval: Optional[pulumi.Input[int]] = None,
                 polling_job_id: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[bool] batch: If you set batch to true, when a pipeline is running, the system waits until the run is completed, then starts another run with all changes that have not yet been built. Defaults to `true`.
        :param pulumi.Input[Sequence[pulumi.Input['BuildDefinitionCiTriggerOverrideBranchFilterArgs']]] branch_filters: The branches to include and exclude from the trigger.
        :param pulumi.Input[int] max_concurrent_builds_per_branch: The number of max builds per branch. Defaults to `1`.
        :param pulumi.Input[Sequence[pulumi.Input['BuildDefinitionCiTriggerOverridePathFilterArgs']]] path_filters: Specify file paths to include or exclude. Note that the wildcard syntax is different between branches/tags and file paths.
        :param pulumi.Input[int] polling_interval: How often the external repository is polled. Defaults to `0`.
        :param pulumi.Input[str] polling_job_id: This is the ID of the polling job that polls the external repository. Once the build definition is saved/updated, this value is set.
        """
        if batch is not None:
            pulumi.set(__self__, "batch", batch)
        if branch_filters is not None:
            pulumi.set(__self__, "branch_filters", branch_filters)
        if max_concurrent_builds_per_branch is not None:
            pulumi.set(__self__, "max_concurrent_builds_per_branch", max_concurrent_builds_per_branch)
        if path_filters is not None:
            pulumi.set(__self__, "path_filters", path_filters)
        if polling_interval is not None:
            pulumi.set(__self__, "polling_interval", polling_interval)
        if polling_job_id is not None:
            pulumi.set(__self__, "polling_job_id", polling_job_id)

    @property
    @pulumi.getter
    def batch(self) -> Optional[pulumi.Input[bool]]:
        """
        If you set batch to true, when a pipeline is running, the system waits until the run is completed, then starts another run with all changes that have not yet been built. Defaults to `true`.
        """
        return pulumi.get(self, "batch")

    @batch.setter
    def batch(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "batch", value)

    @property
    @pulumi.getter(name="branchFilters")
    def branch_filters(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['BuildDefinitionCiTriggerOverrideBranchFilterArgs']]]]:
        """
        The branches to include and exclude from the trigger.
        """
        return pulumi.get(self, "branch_filters")

    @branch_filters.setter
    def branch_filters(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['BuildDefinitionCiTriggerOverrideBranchFilterArgs']]]]):
        pulumi.set(self, "branch_filters", value)

    @property
    @pulumi.getter(name="maxConcurrentBuildsPerBranch")
    def max_concurrent_builds_per_branch(self) -> Optional[pulumi.Input[int]]:
        """
        The number of max builds per branch. Defaults to `1`.
        """
        return pulumi.get(self, "max_concurrent_builds_per_branch")

    @max_concurrent_builds_per_branch.setter
    def max_concurrent_builds_per_branch(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "max_concurrent_builds_per_branch", value)

    @property
    @pulumi.getter(name="pathFilters")
    def path_filters(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['BuildDefinitionCiTriggerOverridePathFilterArgs']]]]:
        """
        Specify file paths to include or exclude. Note that the wildcard syntax is different between branches/tags and file paths.
        """
        return pulumi.get(self, "path_filters")

    @path_filters.setter
    def path_filters(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['BuildDefinitionCiTriggerOverridePathFilterArgs']]]]):
        pulumi.set(self, "path_filters", value)

    @property
    @pulumi.getter(name="pollingInterval")
    def polling_interval(self) -> Optional[pulumi.Input[int]]:
        """
        How often the external repository is polled. Defaults to `0`.
        """
        return pulumi.get(self, "polling_interval")

    @polling_interval.setter
    def polling_interval(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "polling_interval", value)

    @property
    @pulumi.getter(name="pollingJobId")
    def polling_job_id(self) -> Optional[pulumi.Input[str]]:
        """
        This is the ID of the polling job that polls the external repository. Once the build definition is saved/updated, this value is set.
        """
        return pulumi.get(self, "polling_job_id")

    @polling_job_id.setter
    def polling_job_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "polling_job_id", value)


@pulumi.input_type
class BuildDefinitionCiTriggerOverrideBranchFilterArgs:
    def __init__(__self__, *,
                 excludes: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 includes: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input[str]]] excludes: List of branch patterns to exclude.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] includes: List of branch patterns to include.
        """
        if excludes is not None:
            pulumi.set(__self__, "excludes", excludes)
        if includes is not None:
            pulumi.set(__self__, "includes", includes)

    @property
    @pulumi.getter
    def excludes(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        List of branch patterns to exclude.
        """
        return pulumi.get(self, "excludes")

    @excludes.setter
    def excludes(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "excludes", value)

    @property
    @pulumi.getter
    def includes(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        List of branch patterns to include.
        """
        return pulumi.get(self, "includes")

    @includes.setter
    def includes(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "includes", value)


@pulumi.input_type
class BuildDefinitionCiTriggerOverridePathFilterArgs:
    def __init__(__self__, *,
                 excludes: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 includes: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input[str]]] excludes: List of branch patterns to exclude.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] includes: List of branch patterns to include.
        """
        if excludes is not None:
            pulumi.set(__self__, "excludes", excludes)
        if includes is not None:
            pulumi.set(__self__, "includes", includes)

    @property
    @pulumi.getter
    def excludes(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        List of branch patterns to exclude.
        """
        return pulumi.get(self, "excludes")

    @excludes.setter
    def excludes(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "excludes", value)

    @property
    @pulumi.getter
    def includes(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        List of branch patterns to include.
        """
        return pulumi.get(self, "includes")

    @includes.setter
    def includes(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "includes", value)


@pulumi.input_type
class BuildDefinitionPullRequestTriggerArgs:
    def __init__(__self__, *,
                 forks: pulumi.Input['BuildDefinitionPullRequestTriggerForksArgs'],
                 comment_required: Optional[pulumi.Input[str]] = None,
                 initial_branch: Optional[pulumi.Input[str]] = None,
                 override: Optional[pulumi.Input['BuildDefinitionPullRequestTriggerOverrideArgs']] = None,
                 use_yaml: Optional[pulumi.Input[bool]] = None):
        """
        :param pulumi.Input['BuildDefinitionPullRequestTriggerForksArgs'] forks: Set permissions for Forked repositories.
        :param pulumi.Input['BuildDefinitionPullRequestTriggerOverrideArgs'] override: Override the azure-pipeline file and use this configuration for all builds.
        :param pulumi.Input[bool] use_yaml: Use the azure-pipeline file for the build configuration. Defaults to `false`.
        """
        pulumi.set(__self__, "forks", forks)
        if comment_required is not None:
            pulumi.set(__self__, "comment_required", comment_required)
        if initial_branch is not None:
            pulumi.set(__self__, "initial_branch", initial_branch)
        if override is not None:
            pulumi.set(__self__, "override", override)
        if use_yaml is not None:
            pulumi.set(__self__, "use_yaml", use_yaml)

    @property
    @pulumi.getter
    def forks(self) -> pulumi.Input['BuildDefinitionPullRequestTriggerForksArgs']:
        """
        Set permissions for Forked repositories.
        """
        return pulumi.get(self, "forks")

    @forks.setter
    def forks(self, value: pulumi.Input['BuildDefinitionPullRequestTriggerForksArgs']):
        pulumi.set(self, "forks", value)

    @property
    @pulumi.getter(name="commentRequired")
    def comment_required(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "comment_required")

    @comment_required.setter
    def comment_required(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "comment_required", value)

    @property
    @pulumi.getter(name="initialBranch")
    def initial_branch(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "initial_branch")

    @initial_branch.setter
    def initial_branch(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "initial_branch", value)

    @property
    @pulumi.getter
    def override(self) -> Optional[pulumi.Input['BuildDefinitionPullRequestTriggerOverrideArgs']]:
        """
        Override the azure-pipeline file and use this configuration for all builds.
        """
        return pulumi.get(self, "override")

    @override.setter
    def override(self, value: Optional[pulumi.Input['BuildDefinitionPullRequestTriggerOverrideArgs']]):
        pulumi.set(self, "override", value)

    @property
    @pulumi.getter(name="useYaml")
    def use_yaml(self) -> Optional[pulumi.Input[bool]]:
        """
        Use the azure-pipeline file for the build configuration. Defaults to `false`.
        """
        return pulumi.get(self, "use_yaml")

    @use_yaml.setter
    def use_yaml(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "use_yaml", value)


@pulumi.input_type
class BuildDefinitionPullRequestTriggerForksArgs:
    def __init__(__self__, *,
                 enabled: pulumi.Input[bool],
                 share_secrets: pulumi.Input[bool]):
        """
        :param pulumi.Input[bool] enabled: Build pull requests form forms of this repository.
        :param pulumi.Input[bool] share_secrets: Make secrets available to builds of forks.
        """
        pulumi.set(__self__, "enabled", enabled)
        pulumi.set(__self__, "share_secrets", share_secrets)

    @property
    @pulumi.getter
    def enabled(self) -> pulumi.Input[bool]:
        """
        Build pull requests form forms of this repository.
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: pulumi.Input[bool]):
        pulumi.set(self, "enabled", value)

    @property
    @pulumi.getter(name="shareSecrets")
    def share_secrets(self) -> pulumi.Input[bool]:
        """
        Make secrets available to builds of forks.
        """
        return pulumi.get(self, "share_secrets")

    @share_secrets.setter
    def share_secrets(self, value: pulumi.Input[bool]):
        pulumi.set(self, "share_secrets", value)


@pulumi.input_type
class BuildDefinitionPullRequestTriggerOverrideArgs:
    def __init__(__self__, *,
                 auto_cancel: Optional[pulumi.Input[bool]] = None,
                 branch_filters: Optional[pulumi.Input[Sequence[pulumi.Input['BuildDefinitionPullRequestTriggerOverrideBranchFilterArgs']]]] = None,
                 path_filters: Optional[pulumi.Input[Sequence[pulumi.Input['BuildDefinitionPullRequestTriggerOverridePathFilterArgs']]]] = None):
        """
        :param pulumi.Input[bool] auto_cancel: . Defaults to `true`.
        :param pulumi.Input[Sequence[pulumi.Input['BuildDefinitionPullRequestTriggerOverrideBranchFilterArgs']]] branch_filters: The branches to include and exclude from the trigger.
        :param pulumi.Input[Sequence[pulumi.Input['BuildDefinitionPullRequestTriggerOverridePathFilterArgs']]] path_filters: Specify file paths to include or exclude. Note that the wildcard syntax is different between branches/tags and file paths.
        """
        if auto_cancel is not None:
            pulumi.set(__self__, "auto_cancel", auto_cancel)
        if branch_filters is not None:
            pulumi.set(__self__, "branch_filters", branch_filters)
        if path_filters is not None:
            pulumi.set(__self__, "path_filters", path_filters)

    @property
    @pulumi.getter(name="autoCancel")
    def auto_cancel(self) -> Optional[pulumi.Input[bool]]:
        """
        . Defaults to `true`.
        """
        return pulumi.get(self, "auto_cancel")

    @auto_cancel.setter
    def auto_cancel(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "auto_cancel", value)

    @property
    @pulumi.getter(name="branchFilters")
    def branch_filters(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['BuildDefinitionPullRequestTriggerOverrideBranchFilterArgs']]]]:
        """
        The branches to include and exclude from the trigger.
        """
        return pulumi.get(self, "branch_filters")

    @branch_filters.setter
    def branch_filters(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['BuildDefinitionPullRequestTriggerOverrideBranchFilterArgs']]]]):
        pulumi.set(self, "branch_filters", value)

    @property
    @pulumi.getter(name="pathFilters")
    def path_filters(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['BuildDefinitionPullRequestTriggerOverridePathFilterArgs']]]]:
        """
        Specify file paths to include or exclude. Note that the wildcard syntax is different between branches/tags and file paths.
        """
        return pulumi.get(self, "path_filters")

    @path_filters.setter
    def path_filters(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['BuildDefinitionPullRequestTriggerOverridePathFilterArgs']]]]):
        pulumi.set(self, "path_filters", value)


@pulumi.input_type
class BuildDefinitionPullRequestTriggerOverrideBranchFilterArgs:
    def __init__(__self__, *,
                 excludes: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 includes: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input[str]]] excludes: List of branch patterns to exclude.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] includes: List of branch patterns to include.
        """
        if excludes is not None:
            pulumi.set(__self__, "excludes", excludes)
        if includes is not None:
            pulumi.set(__self__, "includes", includes)

    @property
    @pulumi.getter
    def excludes(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        List of branch patterns to exclude.
        """
        return pulumi.get(self, "excludes")

    @excludes.setter
    def excludes(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "excludes", value)

    @property
    @pulumi.getter
    def includes(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        List of branch patterns to include.
        """
        return pulumi.get(self, "includes")

    @includes.setter
    def includes(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "includes", value)


@pulumi.input_type
class BuildDefinitionPullRequestTriggerOverridePathFilterArgs:
    def __init__(__self__, *,
                 excludes: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 includes: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input[str]]] excludes: List of branch patterns to exclude.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] includes: List of branch patterns to include.
        """
        if excludes is not None:
            pulumi.set(__self__, "excludes", excludes)
        if includes is not None:
            pulumi.set(__self__, "includes", includes)

    @property
    @pulumi.getter
    def excludes(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        List of branch patterns to exclude.
        """
        return pulumi.get(self, "excludes")

    @excludes.setter
    def excludes(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "excludes", value)

    @property
    @pulumi.getter
    def includes(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        List of branch patterns to include.
        """
        return pulumi.get(self, "includes")

    @includes.setter
    def includes(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "includes", value)


@pulumi.input_type
class BuildDefinitionRepositoryArgs:
    def __init__(__self__, *,
                 repo_id: pulumi.Input[str],
                 repo_type: pulumi.Input[str],
                 yml_path: pulumi.Input[str],
                 branch_name: Optional[pulumi.Input[str]] = None,
                 github_enterprise_url: Optional[pulumi.Input[str]] = None,
                 report_build_status: Optional[pulumi.Input[bool]] = None,
                 service_connection_id: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] repo_id: The id of the repository. For `TfsGit` repos, this is simply the ID of the repository. For `Github` repos, this will take the form of `<GitHub Org>/<Repo Name>`. For `Bitbucket` repos, this will take the form of `<Workspace ID>/<Repo Name>`.
        :param pulumi.Input[str] repo_type: The repository type. Valid values: `GitHub` or `TfsGit` or `Bitbucket` or `GitHub Enterprise`. Defaults to `GitHub`. If `repo_type` is `GitHubEnterprise`, must use existing project and GitHub Enterprise service connection.
        :param pulumi.Input[str] yml_path: The path of the Yaml file describing the build definition.
        :param pulumi.Input[str] branch_name: The branch name for which builds are triggered. Defaults to `master`.
        :param pulumi.Input[str] github_enterprise_url: The Github Enterprise URL. Used if `repo_type` is `GithubEnterprise`.
        :param pulumi.Input[bool] report_build_status: Report build status. Default is true.
        :param pulumi.Input[str] service_connection_id: The service connection ID. Used if the `repo_type` is `GitHub` or `GitHubEnterprise`.
        """
        pulumi.set(__self__, "repo_id", repo_id)
        pulumi.set(__self__, "repo_type", repo_type)
        pulumi.set(__self__, "yml_path", yml_path)
        if branch_name is not None:
            pulumi.set(__self__, "branch_name", branch_name)
        if github_enterprise_url is not None:
            pulumi.set(__self__, "github_enterprise_url", github_enterprise_url)
        if report_build_status is not None:
            pulumi.set(__self__, "report_build_status", report_build_status)
        if service_connection_id is not None:
            pulumi.set(__self__, "service_connection_id", service_connection_id)

    @property
    @pulumi.getter(name="repoId")
    def repo_id(self) -> pulumi.Input[str]:
        """
        The id of the repository. For `TfsGit` repos, this is simply the ID of the repository. For `Github` repos, this will take the form of `<GitHub Org>/<Repo Name>`. For `Bitbucket` repos, this will take the form of `<Workspace ID>/<Repo Name>`.
        """
        return pulumi.get(self, "repo_id")

    @repo_id.setter
    def repo_id(self, value: pulumi.Input[str]):
        pulumi.set(self, "repo_id", value)

    @property
    @pulumi.getter(name="repoType")
    def repo_type(self) -> pulumi.Input[str]:
        """
        The repository type. Valid values: `GitHub` or `TfsGit` or `Bitbucket` or `GitHub Enterprise`. Defaults to `GitHub`. If `repo_type` is `GitHubEnterprise`, must use existing project and GitHub Enterprise service connection.
        """
        return pulumi.get(self, "repo_type")

    @repo_type.setter
    def repo_type(self, value: pulumi.Input[str]):
        pulumi.set(self, "repo_type", value)

    @property
    @pulumi.getter(name="ymlPath")
    def yml_path(self) -> pulumi.Input[str]:
        """
        The path of the Yaml file describing the build definition.
        """
        return pulumi.get(self, "yml_path")

    @yml_path.setter
    def yml_path(self, value: pulumi.Input[str]):
        pulumi.set(self, "yml_path", value)

    @property
    @pulumi.getter(name="branchName")
    def branch_name(self) -> Optional[pulumi.Input[str]]:
        """
        The branch name for which builds are triggered. Defaults to `master`.
        """
        return pulumi.get(self, "branch_name")

    @branch_name.setter
    def branch_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "branch_name", value)

    @property
    @pulumi.getter(name="githubEnterpriseUrl")
    def github_enterprise_url(self) -> Optional[pulumi.Input[str]]:
        """
        The Github Enterprise URL. Used if `repo_type` is `GithubEnterprise`.
        """
        return pulumi.get(self, "github_enterprise_url")

    @github_enterprise_url.setter
    def github_enterprise_url(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "github_enterprise_url", value)

    @property
    @pulumi.getter(name="reportBuildStatus")
    def report_build_status(self) -> Optional[pulumi.Input[bool]]:
        """
        Report build status. Default is true.
        """
        return pulumi.get(self, "report_build_status")

    @report_build_status.setter
    def report_build_status(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "report_build_status", value)

    @property
    @pulumi.getter(name="serviceConnectionId")
    def service_connection_id(self) -> Optional[pulumi.Input[str]]:
        """
        The service connection ID. Used if the `repo_type` is `GitHub` or `GitHubEnterprise`.
        """
        return pulumi.get(self, "service_connection_id")

    @service_connection_id.setter
    def service_connection_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "service_connection_id", value)


@pulumi.input_type
class BuildDefinitionVariableArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[str],
                 allow_override: Optional[pulumi.Input[bool]] = None,
                 is_secret: Optional[pulumi.Input[bool]] = None,
                 secret_value: Optional[pulumi.Input[str]] = None,
                 value: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] name: The name of the variable.
        :param pulumi.Input[bool] allow_override: True if the variable can be overridden. Defaults to `true`.
        :param pulumi.Input[bool] is_secret: True if the variable is a secret. Defaults to `false`.
        :param pulumi.Input[str] secret_value: The secret value of the variable. Used when `is_secret` set to `true`.
        :param pulumi.Input[str] value: The value of the variable.
        """
        pulumi.set(__self__, "name", name)
        if allow_override is not None:
            pulumi.set(__self__, "allow_override", allow_override)
        if is_secret is not None:
            pulumi.set(__self__, "is_secret", is_secret)
        if secret_value is not None:
            pulumi.set(__self__, "secret_value", secret_value)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        The name of the variable.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter(name="allowOverride")
    def allow_override(self) -> Optional[pulumi.Input[bool]]:
        """
        True if the variable can be overridden. Defaults to `true`.
        """
        return pulumi.get(self, "allow_override")

    @allow_override.setter
    def allow_override(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "allow_override", value)

    @property
    @pulumi.getter(name="isSecret")
    def is_secret(self) -> Optional[pulumi.Input[bool]]:
        """
        True if the variable is a secret. Defaults to `false`.
        """
        return pulumi.get(self, "is_secret")

    @is_secret.setter
    def is_secret(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "is_secret", value)

    @property
    @pulumi.getter(name="secretValue")
    def secret_value(self) -> Optional[pulumi.Input[str]]:
        """
        The secret value of the variable. Used when `is_secret` set to `true`.
        """
        return pulumi.get(self, "secret_value")

    @secret_value.setter
    def secret_value(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "secret_value", value)

    @property
    @pulumi.getter
    def value(self) -> Optional[pulumi.Input[str]]:
        """
        The value of the variable.
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "value", value)


@pulumi.input_type
class GitInitializationArgs:
    def __init__(__self__, *,
                 init_type: pulumi.Input[str],
                 source_type: Optional[pulumi.Input[str]] = None,
                 source_url: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] init_type: The type of repository to create. Valid values: `Uninitialized`, `Clean` or `Import`. Defaults to `Uninitialized`.
        :param pulumi.Input[str] source_type: Type of the source repository. Used if the `init_type` is `Import`. Valid values: `Git`.
        :param pulumi.Input[str] source_url: The URL of the source repository. Used if the `init_type` is `Import`.
        """
        pulumi.set(__self__, "init_type", init_type)
        if source_type is not None:
            pulumi.set(__self__, "source_type", source_type)
        if source_url is not None:
            pulumi.set(__self__, "source_url", source_url)

    @property
    @pulumi.getter(name="initType")
    def init_type(self) -> pulumi.Input[str]:
        """
        The type of repository to create. Valid values: `Uninitialized`, `Clean` or `Import`. Defaults to `Uninitialized`.
        """
        return pulumi.get(self, "init_type")

    @init_type.setter
    def init_type(self, value: pulumi.Input[str]):
        pulumi.set(self, "init_type", value)

    @property
    @pulumi.getter(name="sourceType")
    def source_type(self) -> Optional[pulumi.Input[str]]:
        """
        Type of the source repository. Used if the `init_type` is `Import`. Valid values: `Git`.
        """
        return pulumi.get(self, "source_type")

    @source_type.setter
    def source_type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "source_type", value)

    @property
    @pulumi.getter(name="sourceUrl")
    def source_url(self) -> Optional[pulumi.Input[str]]:
        """
        The URL of the source repository. Used if the `init_type` is `Import`.
        """
        return pulumi.get(self, "source_url")

    @source_url.setter
    def source_url(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "source_url", value)


@pulumi.input_type
class ServiceEndpointArtifactoryAuthenticationBasicArgs:
    def __init__(__self__, *,
                 password: pulumi.Input[str],
                 username: pulumi.Input[str],
                 password_hash: Optional[pulumi.Input[str]] = None,
                 username_hash: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] password: Artifactory Password.
        :param pulumi.Input[str] username: Artifactory Username.
        """
        pulumi.set(__self__, "password", password)
        pulumi.set(__self__, "username", username)
        if password_hash is not None:
            pulumi.set(__self__, "password_hash", password_hash)
        if username_hash is not None:
            pulumi.set(__self__, "username_hash", username_hash)

    @property
    @pulumi.getter
    def password(self) -> pulumi.Input[str]:
        """
        Artifactory Password.
        """
        return pulumi.get(self, "password")

    @password.setter
    def password(self, value: pulumi.Input[str]):
        pulumi.set(self, "password", value)

    @property
    @pulumi.getter
    def username(self) -> pulumi.Input[str]:
        """
        Artifactory Username.
        """
        return pulumi.get(self, "username")

    @username.setter
    def username(self, value: pulumi.Input[str]):
        pulumi.set(self, "username", value)

    @property
    @pulumi.getter(name="passwordHash")
    def password_hash(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "password_hash")

    @password_hash.setter
    def password_hash(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "password_hash", value)

    @property
    @pulumi.getter(name="usernameHash")
    def username_hash(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "username_hash")

    @username_hash.setter
    def username_hash(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "username_hash", value)


@pulumi.input_type
class ServiceEndpointArtifactoryAuthenticationTokenArgs:
    def __init__(__self__, *,
                 token: pulumi.Input[str],
                 token_hash: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] token: Authentication Token generated through Artifactory.
               * `authentication_basic`
        """
        pulumi.set(__self__, "token", token)
        if token_hash is not None:
            pulumi.set(__self__, "token_hash", token_hash)

    @property
    @pulumi.getter
    def token(self) -> pulumi.Input[str]:
        """
        Authentication Token generated through Artifactory.
        * `authentication_basic`
        """
        return pulumi.get(self, "token")

    @token.setter
    def token(self, value: pulumi.Input[str]):
        pulumi.set(self, "token", value)

    @property
    @pulumi.getter(name="tokenHash")
    def token_hash(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "token_hash")

    @token_hash.setter
    def token_hash(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "token_hash", value)


@pulumi.input_type
class ServiceEndpointAzureRMCredentialsArgs:
    def __init__(__self__, *,
                 serviceprincipalid: pulumi.Input[str],
                 serviceprincipalkey: pulumi.Input[str],
                 serviceprincipalkey_hash: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] serviceprincipalid: The service principal application Id
        :param pulumi.Input[str] serviceprincipalkey: The service principal secret.
        """
        pulumi.set(__self__, "serviceprincipalid", serviceprincipalid)
        pulumi.set(__self__, "serviceprincipalkey", serviceprincipalkey)
        if serviceprincipalkey_hash is not None:
            pulumi.set(__self__, "serviceprincipalkey_hash", serviceprincipalkey_hash)

    @property
    @pulumi.getter
    def serviceprincipalid(self) -> pulumi.Input[str]:
        """
        The service principal application Id
        """
        return pulumi.get(self, "serviceprincipalid")

    @serviceprincipalid.setter
    def serviceprincipalid(self, value: pulumi.Input[str]):
        pulumi.set(self, "serviceprincipalid", value)

    @property
    @pulumi.getter
    def serviceprincipalkey(self) -> pulumi.Input[str]:
        """
        The service principal secret.
        """
        return pulumi.get(self, "serviceprincipalkey")

    @serviceprincipalkey.setter
    def serviceprincipalkey(self, value: pulumi.Input[str]):
        pulumi.set(self, "serviceprincipalkey", value)

    @property
    @pulumi.getter(name="serviceprincipalkeyHash")
    def serviceprincipalkey_hash(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "serviceprincipalkey_hash")

    @serviceprincipalkey_hash.setter
    def serviceprincipalkey_hash(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "serviceprincipalkey_hash", value)


@pulumi.input_type
class ServiceEndpointGitHubAuthOauthArgs:
    def __init__(__self__, *,
                 oauth_configuration_id: pulumi.Input[str]):
        pulumi.set(__self__, "oauth_configuration_id", oauth_configuration_id)

    @property
    @pulumi.getter(name="oauthConfigurationId")
    def oauth_configuration_id(self) -> pulumi.Input[str]:
        return pulumi.get(self, "oauth_configuration_id")

    @oauth_configuration_id.setter
    def oauth_configuration_id(self, value: pulumi.Input[str]):
        pulumi.set(self, "oauth_configuration_id", value)


@pulumi.input_type
class ServiceEndpointGitHubAuthPersonalArgs:
    def __init__(__self__, *,
                 personal_access_token: pulumi.Input[str],
                 personal_access_token_hash: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] personal_access_token: The Personal Access Token for Github.
        """
        pulumi.set(__self__, "personal_access_token", personal_access_token)
        if personal_access_token_hash is not None:
            pulumi.set(__self__, "personal_access_token_hash", personal_access_token_hash)

    @property
    @pulumi.getter(name="personalAccessToken")
    def personal_access_token(self) -> pulumi.Input[str]:
        """
        The Personal Access Token for Github.
        """
        return pulumi.get(self, "personal_access_token")

    @personal_access_token.setter
    def personal_access_token(self, value: pulumi.Input[str]):
        pulumi.set(self, "personal_access_token", value)

    @property
    @pulumi.getter(name="personalAccessTokenHash")
    def personal_access_token_hash(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "personal_access_token_hash")

    @personal_access_token_hash.setter
    def personal_access_token_hash(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "personal_access_token_hash", value)


@pulumi.input_type
class ServiceEndpointKubernetesAzureSubscriptionArgs:
    def __init__(__self__, *,
                 cluster_name: pulumi.Input[str],
                 resourcegroup_id: pulumi.Input[str],
                 subscription_id: pulumi.Input[str],
                 subscription_name: pulumi.Input[str],
                 tenant_id: pulumi.Input[str],
                 azure_environment: Optional[pulumi.Input[str]] = None,
                 cluster_admin: Optional[pulumi.Input[bool]] = None,
                 namespace: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] cluster_name: The name of the Kubernetes cluster.
        :param pulumi.Input[str] resourcegroup_id: The resource group name, to which the Kubernetes cluster is deployed.
        :param pulumi.Input[str] subscription_id: The id of the Azure subscription.
        :param pulumi.Input[str] subscription_name: The name of the Azure subscription.
        :param pulumi.Input[str] tenant_id: The id of the tenant used by the subscription.
        :param pulumi.Input[str] azure_environment: Azure environment refers to whether the public cloud offering or domestic (government) clouds are being used. Currently, only the public cloud is supported. The value must be AzureCloud. This is also the default-value.
        :param pulumi.Input[bool] cluster_admin: Set this option to allow use cluster admin credentials.
        :param pulumi.Input[str] namespace: The Kubernetes namespace. Default value is "default".
        """
        pulumi.set(__self__, "cluster_name", cluster_name)
        pulumi.set(__self__, "resourcegroup_id", resourcegroup_id)
        pulumi.set(__self__, "subscription_id", subscription_id)
        pulumi.set(__self__, "subscription_name", subscription_name)
        pulumi.set(__self__, "tenant_id", tenant_id)
        if azure_environment is not None:
            pulumi.set(__self__, "azure_environment", azure_environment)
        if cluster_admin is not None:
            pulumi.set(__self__, "cluster_admin", cluster_admin)
        if namespace is not None:
            pulumi.set(__self__, "namespace", namespace)

    @property
    @pulumi.getter(name="clusterName")
    def cluster_name(self) -> pulumi.Input[str]:
        """
        The name of the Kubernetes cluster.
        """
        return pulumi.get(self, "cluster_name")

    @cluster_name.setter
    def cluster_name(self, value: pulumi.Input[str]):
        pulumi.set(self, "cluster_name", value)

    @property
    @pulumi.getter(name="resourcegroupId")
    def resourcegroup_id(self) -> pulumi.Input[str]:
        """
        The resource group name, to which the Kubernetes cluster is deployed.
        """
        return pulumi.get(self, "resourcegroup_id")

    @resourcegroup_id.setter
    def resourcegroup_id(self, value: pulumi.Input[str]):
        pulumi.set(self, "resourcegroup_id", value)

    @property
    @pulumi.getter(name="subscriptionId")
    def subscription_id(self) -> pulumi.Input[str]:
        """
        The id of the Azure subscription.
        """
        return pulumi.get(self, "subscription_id")

    @subscription_id.setter
    def subscription_id(self, value: pulumi.Input[str]):
        pulumi.set(self, "subscription_id", value)

    @property
    @pulumi.getter(name="subscriptionName")
    def subscription_name(self) -> pulumi.Input[str]:
        """
        The name of the Azure subscription.
        """
        return pulumi.get(self, "subscription_name")

    @subscription_name.setter
    def subscription_name(self, value: pulumi.Input[str]):
        pulumi.set(self, "subscription_name", value)

    @property
    @pulumi.getter(name="tenantId")
    def tenant_id(self) -> pulumi.Input[str]:
        """
        The id of the tenant used by the subscription.
        """
        return pulumi.get(self, "tenant_id")

    @tenant_id.setter
    def tenant_id(self, value: pulumi.Input[str]):
        pulumi.set(self, "tenant_id", value)

    @property
    @pulumi.getter(name="azureEnvironment")
    def azure_environment(self) -> Optional[pulumi.Input[str]]:
        """
        Azure environment refers to whether the public cloud offering or domestic (government) clouds are being used. Currently, only the public cloud is supported. The value must be AzureCloud. This is also the default-value.
        """
        return pulumi.get(self, "azure_environment")

    @azure_environment.setter
    def azure_environment(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "azure_environment", value)

    @property
    @pulumi.getter(name="clusterAdmin")
    def cluster_admin(self) -> Optional[pulumi.Input[bool]]:
        """
        Set this option to allow use cluster admin credentials.
        """
        return pulumi.get(self, "cluster_admin")

    @cluster_admin.setter
    def cluster_admin(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "cluster_admin", value)

    @property
    @pulumi.getter
    def namespace(self) -> Optional[pulumi.Input[str]]:
        """
        The Kubernetes namespace. Default value is "default".
        """
        return pulumi.get(self, "namespace")

    @namespace.setter
    def namespace(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "namespace", value)


@pulumi.input_type
class ServiceEndpointKubernetesKubeconfigArgs:
    def __init__(__self__, *,
                 kube_config: pulumi.Input[str],
                 accept_untrusted_certs: Optional[pulumi.Input[bool]] = None,
                 cluster_context: Optional[pulumi.Input[str]] = None,
                 kube_config_hash: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] kube_config: The content of the kubeconfig in yaml notation to be used to communicate with the API-Server of Kubernetes.
        :param pulumi.Input[bool] accept_untrusted_certs: Set this option to allow clients to accept a self-signed certificate.
        :param pulumi.Input[str] cluster_context: Context within the kubeconfig file that is to be used for identifying the cluster. Default value is the current-context set in kubeconfig.
        """
        pulumi.set(__self__, "kube_config", kube_config)
        if accept_untrusted_certs is not None:
            pulumi.set(__self__, "accept_untrusted_certs", accept_untrusted_certs)
        if cluster_context is not None:
            pulumi.set(__self__, "cluster_context", cluster_context)
        if kube_config_hash is not None:
            pulumi.set(__self__, "kube_config_hash", kube_config_hash)

    @property
    @pulumi.getter(name="kubeConfig")
    def kube_config(self) -> pulumi.Input[str]:
        """
        The content of the kubeconfig in yaml notation to be used to communicate with the API-Server of Kubernetes.
        """
        return pulumi.get(self, "kube_config")

    @kube_config.setter
    def kube_config(self, value: pulumi.Input[str]):
        pulumi.set(self, "kube_config", value)

    @property
    @pulumi.getter(name="acceptUntrustedCerts")
    def accept_untrusted_certs(self) -> Optional[pulumi.Input[bool]]:
        """
        Set this option to allow clients to accept a self-signed certificate.
        """
        return pulumi.get(self, "accept_untrusted_certs")

    @accept_untrusted_certs.setter
    def accept_untrusted_certs(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "accept_untrusted_certs", value)

    @property
    @pulumi.getter(name="clusterContext")
    def cluster_context(self) -> Optional[pulumi.Input[str]]:
        """
        Context within the kubeconfig file that is to be used for identifying the cluster. Default value is the current-context set in kubeconfig.
        """
        return pulumi.get(self, "cluster_context")

    @cluster_context.setter
    def cluster_context(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "cluster_context", value)

    @property
    @pulumi.getter(name="kubeConfigHash")
    def kube_config_hash(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "kube_config_hash")

    @kube_config_hash.setter
    def kube_config_hash(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "kube_config_hash", value)


@pulumi.input_type
class ServiceEndpointKubernetesServiceAccountArgs:
    def __init__(__self__, *,
                 ca_cert: pulumi.Input[str],
                 token: pulumi.Input[str],
                 ca_cert_hash: Optional[pulumi.Input[str]] = None,
                 token_hash: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] ca_cert: The certificate from a Kubernetes secret object.
        :param pulumi.Input[str] token: The token from a Kubernetes secret object.
        """
        pulumi.set(__self__, "ca_cert", ca_cert)
        pulumi.set(__self__, "token", token)
        if ca_cert_hash is not None:
            pulumi.set(__self__, "ca_cert_hash", ca_cert_hash)
        if token_hash is not None:
            pulumi.set(__self__, "token_hash", token_hash)

    @property
    @pulumi.getter(name="caCert")
    def ca_cert(self) -> pulumi.Input[str]:
        """
        The certificate from a Kubernetes secret object.
        """
        return pulumi.get(self, "ca_cert")

    @ca_cert.setter
    def ca_cert(self, value: pulumi.Input[str]):
        pulumi.set(self, "ca_cert", value)

    @property
    @pulumi.getter
    def token(self) -> pulumi.Input[str]:
        """
        The token from a Kubernetes secret object.
        """
        return pulumi.get(self, "token")

    @token.setter
    def token(self, value: pulumi.Input[str]):
        pulumi.set(self, "token", value)

    @property
    @pulumi.getter(name="caCertHash")
    def ca_cert_hash(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "ca_cert_hash")

    @ca_cert_hash.setter
    def ca_cert_hash(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "ca_cert_hash", value)

    @property
    @pulumi.getter(name="tokenHash")
    def token_hash(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "token_hash")

    @token_hash.setter
    def token_hash(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "token_hash", value)


@pulumi.input_type
class ServiceEndpointPipelineAuthPersonalArgs:
    def __init__(__self__, *,
                 personal_access_token: pulumi.Input[str],
                 personal_access_token_hash: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] personal_access_token: The Personal Access Token for Azure DevOps Pipeline. It also can be set with AZDO_PERSONAL_ACCESS_TOKEN environment variable.
        """
        pulumi.set(__self__, "personal_access_token", personal_access_token)
        if personal_access_token_hash is not None:
            pulumi.set(__self__, "personal_access_token_hash", personal_access_token_hash)

    @property
    @pulumi.getter(name="personalAccessToken")
    def personal_access_token(self) -> pulumi.Input[str]:
        """
        The Personal Access Token for Azure DevOps Pipeline. It also can be set with AZDO_PERSONAL_ACCESS_TOKEN environment variable.
        """
        return pulumi.get(self, "personal_access_token")

    @personal_access_token.setter
    def personal_access_token(self, value: pulumi.Input[str]):
        pulumi.set(self, "personal_access_token", value)

    @property
    @pulumi.getter(name="personalAccessTokenHash")
    def personal_access_token_hash(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "personal_access_token_hash")

    @personal_access_token_hash.setter
    def personal_access_token_hash(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "personal_access_token_hash", value)


@pulumi.input_type
class VariableGroupKeyVaultArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[str],
                 service_endpoint_id: pulumi.Input[str]):
        """
        :param pulumi.Input[str] name: The name of the Variable Group.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "service_endpoint_id", service_endpoint_id)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        The name of the Variable Group.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter(name="serviceEndpointId")
    def service_endpoint_id(self) -> pulumi.Input[str]:
        return pulumi.get(self, "service_endpoint_id")

    @service_endpoint_id.setter
    def service_endpoint_id(self, value: pulumi.Input[str]):
        pulumi.set(self, "service_endpoint_id", value)


@pulumi.input_type
class VariableGroupVariableArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[str],
                 content_type: Optional[pulumi.Input[str]] = None,
                 enabled: Optional[pulumi.Input[bool]] = None,
                 expires: Optional[pulumi.Input[str]] = None,
                 is_secret: Optional[pulumi.Input[bool]] = None,
                 secret_value: Optional[pulumi.Input[str]] = None,
                 value: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] name: The key value used for the variable. Must be unique within the Variable Group.
        :param pulumi.Input[bool] is_secret: A boolean flag describing if the variable value is sensitive. Defaults to `false`.
        :param pulumi.Input[str] secret_value: The secret value of the variable. If omitted, it will default to empty string. Used when `is_secret` set to `true`.
        :param pulumi.Input[str] value: The value of the variable. If omitted, it will default to empty string.
        """
        pulumi.set(__self__, "name", name)
        if content_type is not None:
            pulumi.set(__self__, "content_type", content_type)
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if expires is not None:
            pulumi.set(__self__, "expires", expires)
        if is_secret is not None:
            pulumi.set(__self__, "is_secret", is_secret)
        if secret_value is not None:
            pulumi.set(__self__, "secret_value", secret_value)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        The key value used for the variable. Must be unique within the Variable Group.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter(name="contentType")
    def content_type(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "content_type")

    @content_type.setter
    def content_type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "content_type", value)

    @property
    @pulumi.getter
    def enabled(self) -> Optional[pulumi.Input[bool]]:
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "enabled", value)

    @property
    @pulumi.getter
    def expires(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "expires")

    @expires.setter
    def expires(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "expires", value)

    @property
    @pulumi.getter(name="isSecret")
    def is_secret(self) -> Optional[pulumi.Input[bool]]:
        """
        A boolean flag describing if the variable value is sensitive. Defaults to `false`.
        """
        return pulumi.get(self, "is_secret")

    @is_secret.setter
    def is_secret(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "is_secret", value)

    @property
    @pulumi.getter(name="secretValue")
    def secret_value(self) -> Optional[pulumi.Input[str]]:
        """
        The secret value of the variable. If omitted, it will default to empty string. Used when `is_secret` set to `true`.
        """
        return pulumi.get(self, "secret_value")

    @secret_value.setter
    def secret_value(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "secret_value", value)

    @property
    @pulumi.getter
    def value(self) -> Optional[pulumi.Input[str]]:
        """
        The value of the variable. If omitted, it will default to empty string.
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "value", value)


