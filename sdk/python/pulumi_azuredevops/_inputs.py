# coding=utf-8
# *** WARNING: this file was generated by the Pulumi Terraform Bridge (tfgen) Tool. ***
# *** Do not edit by hand unless you're certain you know what you are doing! ***

import copy
import warnings
import sys
import pulumi
import pulumi.runtime
from typing import Any, Mapping, Optional, Sequence, Union, overload
if sys.version_info >= (3, 11):
    from typing import NotRequired, TypedDict, TypeAlias
else:
    from typing_extensions import NotRequired, TypedDict, TypeAlias
from . import _utilities

__all__ = [
    'BranchPolicyAutoReviewersSettingsArgs',
    'BranchPolicyAutoReviewersSettingsArgsDict',
    'BranchPolicyAutoReviewersSettingsScopeArgs',
    'BranchPolicyAutoReviewersSettingsScopeArgsDict',
    'BranchPolicyBuildValidationSettingsArgs',
    'BranchPolicyBuildValidationSettingsArgsDict',
    'BranchPolicyBuildValidationSettingsScopeArgs',
    'BranchPolicyBuildValidationSettingsScopeArgsDict',
    'BranchPolicyCommentResolutionSettingsArgs',
    'BranchPolicyCommentResolutionSettingsArgsDict',
    'BranchPolicyCommentResolutionSettingsScopeArgs',
    'BranchPolicyCommentResolutionSettingsScopeArgsDict',
    'BranchPolicyMergeTypesSettingsArgs',
    'BranchPolicyMergeTypesSettingsArgsDict',
    'BranchPolicyMergeTypesSettingsScopeArgs',
    'BranchPolicyMergeTypesSettingsScopeArgsDict',
    'BranchPolicyMinReviewersSettingsArgs',
    'BranchPolicyMinReviewersSettingsArgsDict',
    'BranchPolicyMinReviewersSettingsScopeArgs',
    'BranchPolicyMinReviewersSettingsScopeArgsDict',
    'BranchPolicyStatusCheckSettingsArgs',
    'BranchPolicyStatusCheckSettingsArgsDict',
    'BranchPolicyStatusCheckSettingsScopeArgs',
    'BranchPolicyStatusCheckSettingsScopeArgsDict',
    'BranchPolicyWorkItemLinkingSettingsArgs',
    'BranchPolicyWorkItemLinkingSettingsArgsDict',
    'BranchPolicyWorkItemLinkingSettingsScopeArgs',
    'BranchPolicyWorkItemLinkingSettingsScopeArgsDict',
    'BuildDefinitionBuildCompletionTriggerArgs',
    'BuildDefinitionBuildCompletionTriggerArgsDict',
    'BuildDefinitionBuildCompletionTriggerBranchFilterArgs',
    'BuildDefinitionBuildCompletionTriggerBranchFilterArgsDict',
    'BuildDefinitionCiTriggerArgs',
    'BuildDefinitionCiTriggerArgsDict',
    'BuildDefinitionCiTriggerOverrideArgs',
    'BuildDefinitionCiTriggerOverrideArgsDict',
    'BuildDefinitionCiTriggerOverrideBranchFilterArgs',
    'BuildDefinitionCiTriggerOverrideBranchFilterArgsDict',
    'BuildDefinitionCiTriggerOverridePathFilterArgs',
    'BuildDefinitionCiTriggerOverridePathFilterArgsDict',
    'BuildDefinitionFeatureArgs',
    'BuildDefinitionFeatureArgsDict',
    'BuildDefinitionJobArgs',
    'BuildDefinitionJobArgsDict',
    'BuildDefinitionJobDependencyArgs',
    'BuildDefinitionJobDependencyArgsDict',
    'BuildDefinitionJobTargetArgs',
    'BuildDefinitionJobTargetArgsDict',
    'BuildDefinitionJobTargetExecutionOptionsArgs',
    'BuildDefinitionJobTargetExecutionOptionsArgsDict',
    'BuildDefinitionPullRequestTriggerArgs',
    'BuildDefinitionPullRequestTriggerArgsDict',
    'BuildDefinitionPullRequestTriggerForksArgs',
    'BuildDefinitionPullRequestTriggerForksArgsDict',
    'BuildDefinitionPullRequestTriggerOverrideArgs',
    'BuildDefinitionPullRequestTriggerOverrideArgsDict',
    'BuildDefinitionPullRequestTriggerOverrideBranchFilterArgs',
    'BuildDefinitionPullRequestTriggerOverrideBranchFilterArgsDict',
    'BuildDefinitionPullRequestTriggerOverridePathFilterArgs',
    'BuildDefinitionPullRequestTriggerOverridePathFilterArgsDict',
    'BuildDefinitionRepositoryArgs',
    'BuildDefinitionRepositoryArgsDict',
    'BuildDefinitionScheduleArgs',
    'BuildDefinitionScheduleArgsDict',
    'BuildDefinitionScheduleBranchFilterArgs',
    'BuildDefinitionScheduleBranchFilterArgsDict',
    'BuildDefinitionVariableArgs',
    'BuildDefinitionVariableArgsDict',
    'CheckRequiredTemplateRequiredTemplateArgs',
    'CheckRequiredTemplateRequiredTemplateArgsDict',
    'FeedFeatureArgs',
    'FeedFeatureArgsDict',
    'GitInitializationArgs',
    'GitInitializationArgsDict',
    'ServiceEndpointArtifactoryAuthenticationBasicArgs',
    'ServiceEndpointArtifactoryAuthenticationBasicArgsDict',
    'ServiceEndpointArtifactoryAuthenticationTokenArgs',
    'ServiceEndpointArtifactoryAuthenticationTokenArgsDict',
    'ServiceEndpointAzureEcrCredentialsArgs',
    'ServiceEndpointAzureEcrCredentialsArgsDict',
    'ServiceEndpointAzureRMCredentialsArgs',
    'ServiceEndpointAzureRMCredentialsArgsDict',
    'ServiceEndpointAzureRMFeaturesArgs',
    'ServiceEndpointAzureRMFeaturesArgsDict',
    'ServiceEndpointGitHubAuthOauthArgs',
    'ServiceEndpointGitHubAuthOauthArgsDict',
    'ServiceEndpointGitHubAuthPersonalArgs',
    'ServiceEndpointGitHubAuthPersonalArgsDict',
    'ServiceEndpointGitHubEnterpriseAuthPersonalArgs',
    'ServiceEndpointGitHubEnterpriseAuthPersonalArgsDict',
    'ServiceEndpointKubernetesAzureSubscriptionArgs',
    'ServiceEndpointKubernetesAzureSubscriptionArgsDict',
    'ServiceEndpointKubernetesKubeconfigArgs',
    'ServiceEndpointKubernetesKubeconfigArgsDict',
    'ServiceEndpointKubernetesServiceAccountArgs',
    'ServiceEndpointKubernetesServiceAccountArgsDict',
    'ServiceEndpointPipelineAuthPersonalArgs',
    'ServiceEndpointPipelineAuthPersonalArgsDict',
    'ServiceEndpointServiceFabricAzureActiveDirectoryArgs',
    'ServiceEndpointServiceFabricAzureActiveDirectoryArgsDict',
    'ServiceEndpointServiceFabricCertificateArgs',
    'ServiceEndpointServiceFabricCertificateArgsDict',
    'ServiceEndpointServiceFabricNoneArgs',
    'ServiceEndpointServiceFabricNoneArgsDict',
    'ServiceendpointArgocdAuthenticationBasicArgs',
    'ServiceendpointArgocdAuthenticationBasicArgsDict',
    'ServiceendpointArgocdAuthenticationTokenArgs',
    'ServiceendpointArgocdAuthenticationTokenArgsDict',
    'ServiceendpointExternaltfsAuthPersonalArgs',
    'ServiceendpointExternaltfsAuthPersonalArgsDict',
    'ServiceendpointJfrogArtifactoryV2AuthenticationBasicArgs',
    'ServiceendpointJfrogArtifactoryV2AuthenticationBasicArgsDict',
    'ServiceendpointJfrogArtifactoryV2AuthenticationTokenArgs',
    'ServiceendpointJfrogArtifactoryV2AuthenticationTokenArgsDict',
    'ServiceendpointJfrogDistributionV2AuthenticationBasicArgs',
    'ServiceendpointJfrogDistributionV2AuthenticationBasicArgsDict',
    'ServiceendpointJfrogDistributionV2AuthenticationTokenArgs',
    'ServiceendpointJfrogDistributionV2AuthenticationTokenArgsDict',
    'ServiceendpointJfrogPlatformV2AuthenticationBasicArgs',
    'ServiceendpointJfrogPlatformV2AuthenticationBasicArgsDict',
    'ServiceendpointJfrogPlatformV2AuthenticationTokenArgs',
    'ServiceendpointJfrogPlatformV2AuthenticationTokenArgsDict',
    'ServiceendpointJfrogXrayV2AuthenticationBasicArgs',
    'ServiceendpointJfrogXrayV2AuthenticationBasicArgsDict',
    'ServiceendpointJfrogXrayV2AuthenticationTokenArgs',
    'ServiceendpointJfrogXrayV2AuthenticationTokenArgsDict',
    'ServiceendpointMavenAuthenticationBasicArgs',
    'ServiceendpointMavenAuthenticationBasicArgsDict',
    'ServiceendpointMavenAuthenticationTokenArgs',
    'ServiceendpointMavenAuthenticationTokenArgsDict',
    'ServiceendpointVisualstudiomarketplaceAuthenticationBasicArgs',
    'ServiceendpointVisualstudiomarketplaceAuthenticationBasicArgsDict',
    'ServiceendpointVisualstudiomarketplaceAuthenticationTokenArgs',
    'ServiceendpointVisualstudiomarketplaceAuthenticationTokenArgsDict',
    'ServicehookStorageQueuePipelinesRunStateChangedEventArgs',
    'ServicehookStorageQueuePipelinesRunStateChangedEventArgsDict',
    'ServicehookStorageQueuePipelinesStageStateChangedEventArgs',
    'ServicehookStorageQueuePipelinesStageStateChangedEventArgsDict',
    'VariableGroupKeyVaultArgs',
    'VariableGroupKeyVaultArgsDict',
    'VariableGroupVariableArgs',
    'VariableGroupVariableArgsDict',
    'GetUsersFeaturesArgs',
    'GetUsersFeaturesArgsDict',
]

MYPY = False

if not MYPY:
    class BranchPolicyAutoReviewersSettingsArgsDict(TypedDict):
        auto_reviewer_ids: pulumi.Input[Sequence[pulumi.Input[str]]]
        """
        Required reviewers ids. Supports multiples user Ids.
        """
        scopes: pulumi.Input[Sequence[pulumi.Input['BranchPolicyAutoReviewersSettingsScopeArgsDict']]]
        """
        A `scope` block as defined below. Controls which repositories and branches the policy will be enabled for. This block must be defined at least once.
        """
        message: NotRequired[pulumi.Input[str]]
        """
        Activity feed message, Message will appear in the activity feed of pull requests with automatically added reviewers.
        """
        minimum_number_of_reviewers: NotRequired[pulumi.Input[int]]
        """
        Minimum number of required reviewers. Defaults to `1`.

        > **Note** Has to be greater than `0`. Can only be greater than `1` when attribute `auto_reviewer_ids` contains exactly one group! Only has an effect when attribute `blocking` is set to `true`.
        """
        path_filters: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        Filter path(s) on which the policy is applied. Supports absolute paths, wildcards and multiple paths. Example: /WebApp/Models/Data.cs, /WebApp/* or *.cs,/WebApp/Models/Data.cs;ClientApp/Models/Data.cs.
        """
        submitter_can_vote: NotRequired[pulumi.Input[bool]]
        """
        Controls whether or not the submitter's vote counts. Defaults to `false`.
        """
elif False:
    BranchPolicyAutoReviewersSettingsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class BranchPolicyAutoReviewersSettingsArgs:
    def __init__(__self__, *,
                 auto_reviewer_ids: pulumi.Input[Sequence[pulumi.Input[str]]],
                 scopes: pulumi.Input[Sequence[pulumi.Input['BranchPolicyAutoReviewersSettingsScopeArgs']]],
                 message: Optional[pulumi.Input[str]] = None,
                 minimum_number_of_reviewers: Optional[pulumi.Input[int]] = None,
                 path_filters: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 submitter_can_vote: Optional[pulumi.Input[bool]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input[str]]] auto_reviewer_ids: Required reviewers ids. Supports multiples user Ids.
        :param pulumi.Input[Sequence[pulumi.Input['BranchPolicyAutoReviewersSettingsScopeArgs']]] scopes: A `scope` block as defined below. Controls which repositories and branches the policy will be enabled for. This block must be defined at least once.
        :param pulumi.Input[str] message: Activity feed message, Message will appear in the activity feed of pull requests with automatically added reviewers.
        :param pulumi.Input[int] minimum_number_of_reviewers: Minimum number of required reviewers. Defaults to `1`.
               
               > **Note** Has to be greater than `0`. Can only be greater than `1` when attribute `auto_reviewer_ids` contains exactly one group! Only has an effect when attribute `blocking` is set to `true`.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] path_filters: Filter path(s) on which the policy is applied. Supports absolute paths, wildcards and multiple paths. Example: /WebApp/Models/Data.cs, /WebApp/* or *.cs,/WebApp/Models/Data.cs;ClientApp/Models/Data.cs.
        :param pulumi.Input[bool] submitter_can_vote: Controls whether or not the submitter's vote counts. Defaults to `false`.
        """
        pulumi.set(__self__, "auto_reviewer_ids", auto_reviewer_ids)
        pulumi.set(__self__, "scopes", scopes)
        if message is not None:
            pulumi.set(__self__, "message", message)
        if minimum_number_of_reviewers is not None:
            pulumi.set(__self__, "minimum_number_of_reviewers", minimum_number_of_reviewers)
        if path_filters is not None:
            pulumi.set(__self__, "path_filters", path_filters)
        if submitter_can_vote is not None:
            pulumi.set(__self__, "submitter_can_vote", submitter_can_vote)

    @property
    @pulumi.getter(name="autoReviewerIds")
    def auto_reviewer_ids(self) -> pulumi.Input[Sequence[pulumi.Input[str]]]:
        """
        Required reviewers ids. Supports multiples user Ids.
        """
        return pulumi.get(self, "auto_reviewer_ids")

    @auto_reviewer_ids.setter
    def auto_reviewer_ids(self, value: pulumi.Input[Sequence[pulumi.Input[str]]]):
        pulumi.set(self, "auto_reviewer_ids", value)

    @property
    @pulumi.getter
    def scopes(self) -> pulumi.Input[Sequence[pulumi.Input['BranchPolicyAutoReviewersSettingsScopeArgs']]]:
        """
        A `scope` block as defined below. Controls which repositories and branches the policy will be enabled for. This block must be defined at least once.
        """
        return pulumi.get(self, "scopes")

    @scopes.setter
    def scopes(self, value: pulumi.Input[Sequence[pulumi.Input['BranchPolicyAutoReviewersSettingsScopeArgs']]]):
        pulumi.set(self, "scopes", value)

    @property
    @pulumi.getter
    def message(self) -> Optional[pulumi.Input[str]]:
        """
        Activity feed message, Message will appear in the activity feed of pull requests with automatically added reviewers.
        """
        return pulumi.get(self, "message")

    @message.setter
    def message(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "message", value)

    @property
    @pulumi.getter(name="minimumNumberOfReviewers")
    def minimum_number_of_reviewers(self) -> Optional[pulumi.Input[int]]:
        """
        Minimum number of required reviewers. Defaults to `1`.

        > **Note** Has to be greater than `0`. Can only be greater than `1` when attribute `auto_reviewer_ids` contains exactly one group! Only has an effect when attribute `blocking` is set to `true`.
        """
        return pulumi.get(self, "minimum_number_of_reviewers")

    @minimum_number_of_reviewers.setter
    def minimum_number_of_reviewers(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "minimum_number_of_reviewers", value)

    @property
    @pulumi.getter(name="pathFilters")
    def path_filters(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Filter path(s) on which the policy is applied. Supports absolute paths, wildcards and multiple paths. Example: /WebApp/Models/Data.cs, /WebApp/* or *.cs,/WebApp/Models/Data.cs;ClientApp/Models/Data.cs.
        """
        return pulumi.get(self, "path_filters")

    @path_filters.setter
    def path_filters(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "path_filters", value)

    @property
    @pulumi.getter(name="submitterCanVote")
    def submitter_can_vote(self) -> Optional[pulumi.Input[bool]]:
        """
        Controls whether or not the submitter's vote counts. Defaults to `false`.
        """
        return pulumi.get(self, "submitter_can_vote")

    @submitter_can_vote.setter
    def submitter_can_vote(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "submitter_can_vote", value)


if not MYPY:
    class BranchPolicyAutoReviewersSettingsScopeArgsDict(TypedDict):
        match_type: NotRequired[pulumi.Input[str]]
        """
        The match type to use when applying the policy. Supported values are `Exact` (default), `Prefix` or `DefaultBranch`.
        """
        repository_id: NotRequired[pulumi.Input[str]]
        """
        The repository ID. Needed only if the scope of the policy will be limited to a single repository. If `match_type` is `DefaultBranch`, this should not be defined.
        """
        repository_ref: NotRequired[pulumi.Input[str]]
        """
        The ref pattern to use for the match when `match_type` other than `DefaultBranch`. If `match_type` is `Exact`, this should be a qualified ref such as `refs/heads/master`. If `match_type` is `Prefix`, this should be a ref path such as `refs/heads/releases`.
        """
elif False:
    BranchPolicyAutoReviewersSettingsScopeArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class BranchPolicyAutoReviewersSettingsScopeArgs:
    def __init__(__self__, *,
                 match_type: Optional[pulumi.Input[str]] = None,
                 repository_id: Optional[pulumi.Input[str]] = None,
                 repository_ref: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] match_type: The match type to use when applying the policy. Supported values are `Exact` (default), `Prefix` or `DefaultBranch`.
        :param pulumi.Input[str] repository_id: The repository ID. Needed only if the scope of the policy will be limited to a single repository. If `match_type` is `DefaultBranch`, this should not be defined.
        :param pulumi.Input[str] repository_ref: The ref pattern to use for the match when `match_type` other than `DefaultBranch`. If `match_type` is `Exact`, this should be a qualified ref such as `refs/heads/master`. If `match_type` is `Prefix`, this should be a ref path such as `refs/heads/releases`.
        """
        if match_type is not None:
            pulumi.set(__self__, "match_type", match_type)
        if repository_id is not None:
            pulumi.set(__self__, "repository_id", repository_id)
        if repository_ref is not None:
            pulumi.set(__self__, "repository_ref", repository_ref)

    @property
    @pulumi.getter(name="matchType")
    def match_type(self) -> Optional[pulumi.Input[str]]:
        """
        The match type to use when applying the policy. Supported values are `Exact` (default), `Prefix` or `DefaultBranch`.
        """
        return pulumi.get(self, "match_type")

    @match_type.setter
    def match_type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "match_type", value)

    @property
    @pulumi.getter(name="repositoryId")
    def repository_id(self) -> Optional[pulumi.Input[str]]:
        """
        The repository ID. Needed only if the scope of the policy will be limited to a single repository. If `match_type` is `DefaultBranch`, this should not be defined.
        """
        return pulumi.get(self, "repository_id")

    @repository_id.setter
    def repository_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "repository_id", value)

    @property
    @pulumi.getter(name="repositoryRef")
    def repository_ref(self) -> Optional[pulumi.Input[str]]:
        """
        The ref pattern to use for the match when `match_type` other than `DefaultBranch`. If `match_type` is `Exact`, this should be a qualified ref such as `refs/heads/master`. If `match_type` is `Prefix`, this should be a ref path such as `refs/heads/releases`.
        """
        return pulumi.get(self, "repository_ref")

    @repository_ref.setter
    def repository_ref(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "repository_ref", value)


if not MYPY:
    class BranchPolicyBuildValidationSettingsArgsDict(TypedDict):
        build_definition_id: pulumi.Input[int]
        """
        The ID of the build to monitor for the policy.
        """
        display_name: pulumi.Input[str]
        """
        The display name for the policy.
        """
        scopes: pulumi.Input[Sequence[pulumi.Input['BranchPolicyBuildValidationSettingsScopeArgsDict']]]
        """
        A `scope` block as defined below. Controls which repositories and branches the policy will be enabled for. This block must be defined at least once.
        """
        filename_patterns: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        If a path filter is set, the policy will only apply when files which match the filter are changes. Not setting this field means that the policy will always apply. You can specify absolute paths and wildcards. Example: `["/WebApp/Models/Data.cs", "/WebApp/*", "*.cs"]`. Paths prefixed with "!" are excluded. Example: `["/WebApp/*", "!/WebApp/Tests/*"]`. Order is significant.
        """
        manual_queue_only: NotRequired[pulumi.Input[bool]]
        """
        If set to true, the build will need to be manually queued. Defaults to `false`
        """
        queue_on_source_update_only: NotRequired[pulumi.Input[bool]]
        """
        True if the build should queue on source updates only. Defaults to `true`.
        """
        valid_duration: NotRequired[pulumi.Input[int]]
        """
        The number of minutes for which the build is valid. If `0`, the build will not expire. Defaults to `720` (12 hours).

        > **Note** Combine `valid_duration` and `queue_on_source_update_only` to set the build expiration.
        1.  Expire immediately when branch is updated: `valid_duration=0` and `queue_on_source_update_only=false`
        2.  Expire after a period of time : `valid_duration=360` and `queue_on_source_update_only=true`
        3.  Never expire: `valid_duration=0` and `queue_on_source_update_only=true`
        """
elif False:
    BranchPolicyBuildValidationSettingsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class BranchPolicyBuildValidationSettingsArgs:
    def __init__(__self__, *,
                 build_definition_id: pulumi.Input[int],
                 display_name: pulumi.Input[str],
                 scopes: pulumi.Input[Sequence[pulumi.Input['BranchPolicyBuildValidationSettingsScopeArgs']]],
                 filename_patterns: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 manual_queue_only: Optional[pulumi.Input[bool]] = None,
                 queue_on_source_update_only: Optional[pulumi.Input[bool]] = None,
                 valid_duration: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input[int] build_definition_id: The ID of the build to monitor for the policy.
        :param pulumi.Input[str] display_name: The display name for the policy.
        :param pulumi.Input[Sequence[pulumi.Input['BranchPolicyBuildValidationSettingsScopeArgs']]] scopes: A `scope` block as defined below. Controls which repositories and branches the policy will be enabled for. This block must be defined at least once.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] filename_patterns: If a path filter is set, the policy will only apply when files which match the filter are changes. Not setting this field means that the policy will always apply. You can specify absolute paths and wildcards. Example: `["/WebApp/Models/Data.cs", "/WebApp/*", "*.cs"]`. Paths prefixed with "!" are excluded. Example: `["/WebApp/*", "!/WebApp/Tests/*"]`. Order is significant.
        :param pulumi.Input[bool] manual_queue_only: If set to true, the build will need to be manually queued. Defaults to `false`
        :param pulumi.Input[bool] queue_on_source_update_only: True if the build should queue on source updates only. Defaults to `true`.
        :param pulumi.Input[int] valid_duration: The number of minutes for which the build is valid. If `0`, the build will not expire. Defaults to `720` (12 hours).
               
               > **Note** Combine `valid_duration` and `queue_on_source_update_only` to set the build expiration.
               1.  Expire immediately when branch is updated: `valid_duration=0` and `queue_on_source_update_only=false`
               2.  Expire after a period of time : `valid_duration=360` and `queue_on_source_update_only=true`
               3.  Never expire: `valid_duration=0` and `queue_on_source_update_only=true`
        """
        pulumi.set(__self__, "build_definition_id", build_definition_id)
        pulumi.set(__self__, "display_name", display_name)
        pulumi.set(__self__, "scopes", scopes)
        if filename_patterns is not None:
            pulumi.set(__self__, "filename_patterns", filename_patterns)
        if manual_queue_only is not None:
            pulumi.set(__self__, "manual_queue_only", manual_queue_only)
        if queue_on_source_update_only is not None:
            pulumi.set(__self__, "queue_on_source_update_only", queue_on_source_update_only)
        if valid_duration is not None:
            pulumi.set(__self__, "valid_duration", valid_duration)

    @property
    @pulumi.getter(name="buildDefinitionId")
    def build_definition_id(self) -> pulumi.Input[int]:
        """
        The ID of the build to monitor for the policy.
        """
        return pulumi.get(self, "build_definition_id")

    @build_definition_id.setter
    def build_definition_id(self, value: pulumi.Input[int]):
        pulumi.set(self, "build_definition_id", value)

    @property
    @pulumi.getter(name="displayName")
    def display_name(self) -> pulumi.Input[str]:
        """
        The display name for the policy.
        """
        return pulumi.get(self, "display_name")

    @display_name.setter
    def display_name(self, value: pulumi.Input[str]):
        pulumi.set(self, "display_name", value)

    @property
    @pulumi.getter
    def scopes(self) -> pulumi.Input[Sequence[pulumi.Input['BranchPolicyBuildValidationSettingsScopeArgs']]]:
        """
        A `scope` block as defined below. Controls which repositories and branches the policy will be enabled for. This block must be defined at least once.
        """
        return pulumi.get(self, "scopes")

    @scopes.setter
    def scopes(self, value: pulumi.Input[Sequence[pulumi.Input['BranchPolicyBuildValidationSettingsScopeArgs']]]):
        pulumi.set(self, "scopes", value)

    @property
    @pulumi.getter(name="filenamePatterns")
    def filename_patterns(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        If a path filter is set, the policy will only apply when files which match the filter are changes. Not setting this field means that the policy will always apply. You can specify absolute paths and wildcards. Example: `["/WebApp/Models/Data.cs", "/WebApp/*", "*.cs"]`. Paths prefixed with "!" are excluded. Example: `["/WebApp/*", "!/WebApp/Tests/*"]`. Order is significant.
        """
        return pulumi.get(self, "filename_patterns")

    @filename_patterns.setter
    def filename_patterns(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "filename_patterns", value)

    @property
    @pulumi.getter(name="manualQueueOnly")
    def manual_queue_only(self) -> Optional[pulumi.Input[bool]]:
        """
        If set to true, the build will need to be manually queued. Defaults to `false`
        """
        return pulumi.get(self, "manual_queue_only")

    @manual_queue_only.setter
    def manual_queue_only(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "manual_queue_only", value)

    @property
    @pulumi.getter(name="queueOnSourceUpdateOnly")
    def queue_on_source_update_only(self) -> Optional[pulumi.Input[bool]]:
        """
        True if the build should queue on source updates only. Defaults to `true`.
        """
        return pulumi.get(self, "queue_on_source_update_only")

    @queue_on_source_update_only.setter
    def queue_on_source_update_only(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "queue_on_source_update_only", value)

    @property
    @pulumi.getter(name="validDuration")
    def valid_duration(self) -> Optional[pulumi.Input[int]]:
        """
        The number of minutes for which the build is valid. If `0`, the build will not expire. Defaults to `720` (12 hours).

        > **Note** Combine `valid_duration` and `queue_on_source_update_only` to set the build expiration.
        1.  Expire immediately when branch is updated: `valid_duration=0` and `queue_on_source_update_only=false`
        2.  Expire after a period of time : `valid_duration=360` and `queue_on_source_update_only=true`
        3.  Never expire: `valid_duration=0` and `queue_on_source_update_only=true`
        """
        return pulumi.get(self, "valid_duration")

    @valid_duration.setter
    def valid_duration(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "valid_duration", value)


if not MYPY:
    class BranchPolicyBuildValidationSettingsScopeArgsDict(TypedDict):
        match_type: NotRequired[pulumi.Input[str]]
        """
        The match type to use when applying the policy. Supported values are `Exact` (default), `Prefix` or `DefaultBranch`.
        """
        repository_id: NotRequired[pulumi.Input[str]]
        """
        The repository ID. Needed only if the scope of the policy will be limited to a single repository. If `match_type` is `DefaultBranch`, this should not be defined.
        """
        repository_ref: NotRequired[pulumi.Input[str]]
        """
        The ref pattern to use for the match when `match_type` other than `DefaultBranch`. If `match_type` is `Exact`, this should be a qualified ref such as `refs/heads/master`. If `match_type` is `Prefix`, this should be a ref path such as `refs/heads/releases`.
        """
elif False:
    BranchPolicyBuildValidationSettingsScopeArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class BranchPolicyBuildValidationSettingsScopeArgs:
    def __init__(__self__, *,
                 match_type: Optional[pulumi.Input[str]] = None,
                 repository_id: Optional[pulumi.Input[str]] = None,
                 repository_ref: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] match_type: The match type to use when applying the policy. Supported values are `Exact` (default), `Prefix` or `DefaultBranch`.
        :param pulumi.Input[str] repository_id: The repository ID. Needed only if the scope of the policy will be limited to a single repository. If `match_type` is `DefaultBranch`, this should not be defined.
        :param pulumi.Input[str] repository_ref: The ref pattern to use for the match when `match_type` other than `DefaultBranch`. If `match_type` is `Exact`, this should be a qualified ref such as `refs/heads/master`. If `match_type` is `Prefix`, this should be a ref path such as `refs/heads/releases`.
        """
        if match_type is not None:
            pulumi.set(__self__, "match_type", match_type)
        if repository_id is not None:
            pulumi.set(__self__, "repository_id", repository_id)
        if repository_ref is not None:
            pulumi.set(__self__, "repository_ref", repository_ref)

    @property
    @pulumi.getter(name="matchType")
    def match_type(self) -> Optional[pulumi.Input[str]]:
        """
        The match type to use when applying the policy. Supported values are `Exact` (default), `Prefix` or `DefaultBranch`.
        """
        return pulumi.get(self, "match_type")

    @match_type.setter
    def match_type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "match_type", value)

    @property
    @pulumi.getter(name="repositoryId")
    def repository_id(self) -> Optional[pulumi.Input[str]]:
        """
        The repository ID. Needed only if the scope of the policy will be limited to a single repository. If `match_type` is `DefaultBranch`, this should not be defined.
        """
        return pulumi.get(self, "repository_id")

    @repository_id.setter
    def repository_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "repository_id", value)

    @property
    @pulumi.getter(name="repositoryRef")
    def repository_ref(self) -> Optional[pulumi.Input[str]]:
        """
        The ref pattern to use for the match when `match_type` other than `DefaultBranch`. If `match_type` is `Exact`, this should be a qualified ref such as `refs/heads/master`. If `match_type` is `Prefix`, this should be a ref path such as `refs/heads/releases`.
        """
        return pulumi.get(self, "repository_ref")

    @repository_ref.setter
    def repository_ref(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "repository_ref", value)


if not MYPY:
    class BranchPolicyCommentResolutionSettingsArgsDict(TypedDict):
        scopes: pulumi.Input[Sequence[pulumi.Input['BranchPolicyCommentResolutionSettingsScopeArgsDict']]]
        """
        A `scope` block as defined below. Controls which repositories and branches the policy will be enabled for. This block must be defined at least once.
        """
elif False:
    BranchPolicyCommentResolutionSettingsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class BranchPolicyCommentResolutionSettingsArgs:
    def __init__(__self__, *,
                 scopes: pulumi.Input[Sequence[pulumi.Input['BranchPolicyCommentResolutionSettingsScopeArgs']]]):
        """
        :param pulumi.Input[Sequence[pulumi.Input['BranchPolicyCommentResolutionSettingsScopeArgs']]] scopes: A `scope` block as defined below. Controls which repositories and branches the policy will be enabled for. This block must be defined at least once.
        """
        pulumi.set(__self__, "scopes", scopes)

    @property
    @pulumi.getter
    def scopes(self) -> pulumi.Input[Sequence[pulumi.Input['BranchPolicyCommentResolutionSettingsScopeArgs']]]:
        """
        A `scope` block as defined below. Controls which repositories and branches the policy will be enabled for. This block must be defined at least once.
        """
        return pulumi.get(self, "scopes")

    @scopes.setter
    def scopes(self, value: pulumi.Input[Sequence[pulumi.Input['BranchPolicyCommentResolutionSettingsScopeArgs']]]):
        pulumi.set(self, "scopes", value)


if not MYPY:
    class BranchPolicyCommentResolutionSettingsScopeArgsDict(TypedDict):
        match_type: NotRequired[pulumi.Input[str]]
        """
        The match type to use when applying the policy. Supported values are `Exact` (default), `Prefix` or `DefaultBranch`.
        """
        repository_id: NotRequired[pulumi.Input[str]]
        """
        The repository ID. Needed only if the scope of the policy will be limited to a single repository. If `match_type` is `DefaultBranch`, this should not be defined.
        """
        repository_ref: NotRequired[pulumi.Input[str]]
        """
        The ref pattern to use for the match when `match_type` other than `DefaultBranch`. If `match_type` is `Exact`, this should be a qualified ref such as `refs/heads/master`. If `match_type` is `Prefix`, this should be a ref path such as `refs/heads/releases`.
        """
elif False:
    BranchPolicyCommentResolutionSettingsScopeArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class BranchPolicyCommentResolutionSettingsScopeArgs:
    def __init__(__self__, *,
                 match_type: Optional[pulumi.Input[str]] = None,
                 repository_id: Optional[pulumi.Input[str]] = None,
                 repository_ref: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] match_type: The match type to use when applying the policy. Supported values are `Exact` (default), `Prefix` or `DefaultBranch`.
        :param pulumi.Input[str] repository_id: The repository ID. Needed only if the scope of the policy will be limited to a single repository. If `match_type` is `DefaultBranch`, this should not be defined.
        :param pulumi.Input[str] repository_ref: The ref pattern to use for the match when `match_type` other than `DefaultBranch`. If `match_type` is `Exact`, this should be a qualified ref such as `refs/heads/master`. If `match_type` is `Prefix`, this should be a ref path such as `refs/heads/releases`.
        """
        if match_type is not None:
            pulumi.set(__self__, "match_type", match_type)
        if repository_id is not None:
            pulumi.set(__self__, "repository_id", repository_id)
        if repository_ref is not None:
            pulumi.set(__self__, "repository_ref", repository_ref)

    @property
    @pulumi.getter(name="matchType")
    def match_type(self) -> Optional[pulumi.Input[str]]:
        """
        The match type to use when applying the policy. Supported values are `Exact` (default), `Prefix` or `DefaultBranch`.
        """
        return pulumi.get(self, "match_type")

    @match_type.setter
    def match_type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "match_type", value)

    @property
    @pulumi.getter(name="repositoryId")
    def repository_id(self) -> Optional[pulumi.Input[str]]:
        """
        The repository ID. Needed only if the scope of the policy will be limited to a single repository. If `match_type` is `DefaultBranch`, this should not be defined.
        """
        return pulumi.get(self, "repository_id")

    @repository_id.setter
    def repository_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "repository_id", value)

    @property
    @pulumi.getter(name="repositoryRef")
    def repository_ref(self) -> Optional[pulumi.Input[str]]:
        """
        The ref pattern to use for the match when `match_type` other than `DefaultBranch`. If `match_type` is `Exact`, this should be a qualified ref such as `refs/heads/master`. If `match_type` is `Prefix`, this should be a ref path such as `refs/heads/releases`.
        """
        return pulumi.get(self, "repository_ref")

    @repository_ref.setter
    def repository_ref(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "repository_ref", value)


if not MYPY:
    class BranchPolicyMergeTypesSettingsArgsDict(TypedDict):
        scopes: pulumi.Input[Sequence[pulumi.Input['BranchPolicyMergeTypesSettingsScopeArgsDict']]]
        """
        A `scope` block as defined below. Controls which repositories and branches the policy will be enabled for. This block must be defined at least once.
        """
        allow_basic_no_fast_forward: NotRequired[pulumi.Input[bool]]
        """
        Allow basic merge with no fast forward. Defaults to `false`.
        """
        allow_rebase_and_fast_forward: NotRequired[pulumi.Input[bool]]
        """
        Allow rebase with fast forward. Defaults to `false`.
        """
        allow_rebase_with_merge: NotRequired[pulumi.Input[bool]]
        """
        Allow rebase with merge commit. Defaults to `false`.
        """
        allow_squash: NotRequired[pulumi.Input[bool]]
        """
        Allow squash merge. Defaults to `false`
        """
elif False:
    BranchPolicyMergeTypesSettingsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class BranchPolicyMergeTypesSettingsArgs:
    def __init__(__self__, *,
                 scopes: pulumi.Input[Sequence[pulumi.Input['BranchPolicyMergeTypesSettingsScopeArgs']]],
                 allow_basic_no_fast_forward: Optional[pulumi.Input[bool]] = None,
                 allow_rebase_and_fast_forward: Optional[pulumi.Input[bool]] = None,
                 allow_rebase_with_merge: Optional[pulumi.Input[bool]] = None,
                 allow_squash: Optional[pulumi.Input[bool]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input['BranchPolicyMergeTypesSettingsScopeArgs']]] scopes: A `scope` block as defined below. Controls which repositories and branches the policy will be enabled for. This block must be defined at least once.
        :param pulumi.Input[bool] allow_basic_no_fast_forward: Allow basic merge with no fast forward. Defaults to `false`.
        :param pulumi.Input[bool] allow_rebase_and_fast_forward: Allow rebase with fast forward. Defaults to `false`.
        :param pulumi.Input[bool] allow_rebase_with_merge: Allow rebase with merge commit. Defaults to `false`.
        :param pulumi.Input[bool] allow_squash: Allow squash merge. Defaults to `false`
        """
        pulumi.set(__self__, "scopes", scopes)
        if allow_basic_no_fast_forward is not None:
            pulumi.set(__self__, "allow_basic_no_fast_forward", allow_basic_no_fast_forward)
        if allow_rebase_and_fast_forward is not None:
            pulumi.set(__self__, "allow_rebase_and_fast_forward", allow_rebase_and_fast_forward)
        if allow_rebase_with_merge is not None:
            pulumi.set(__self__, "allow_rebase_with_merge", allow_rebase_with_merge)
        if allow_squash is not None:
            pulumi.set(__self__, "allow_squash", allow_squash)

    @property
    @pulumi.getter
    def scopes(self) -> pulumi.Input[Sequence[pulumi.Input['BranchPolicyMergeTypesSettingsScopeArgs']]]:
        """
        A `scope` block as defined below. Controls which repositories and branches the policy will be enabled for. This block must be defined at least once.
        """
        return pulumi.get(self, "scopes")

    @scopes.setter
    def scopes(self, value: pulumi.Input[Sequence[pulumi.Input['BranchPolicyMergeTypesSettingsScopeArgs']]]):
        pulumi.set(self, "scopes", value)

    @property
    @pulumi.getter(name="allowBasicNoFastForward")
    def allow_basic_no_fast_forward(self) -> Optional[pulumi.Input[bool]]:
        """
        Allow basic merge with no fast forward. Defaults to `false`.
        """
        return pulumi.get(self, "allow_basic_no_fast_forward")

    @allow_basic_no_fast_forward.setter
    def allow_basic_no_fast_forward(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "allow_basic_no_fast_forward", value)

    @property
    @pulumi.getter(name="allowRebaseAndFastForward")
    def allow_rebase_and_fast_forward(self) -> Optional[pulumi.Input[bool]]:
        """
        Allow rebase with fast forward. Defaults to `false`.
        """
        return pulumi.get(self, "allow_rebase_and_fast_forward")

    @allow_rebase_and_fast_forward.setter
    def allow_rebase_and_fast_forward(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "allow_rebase_and_fast_forward", value)

    @property
    @pulumi.getter(name="allowRebaseWithMerge")
    def allow_rebase_with_merge(self) -> Optional[pulumi.Input[bool]]:
        """
        Allow rebase with merge commit. Defaults to `false`.
        """
        return pulumi.get(self, "allow_rebase_with_merge")

    @allow_rebase_with_merge.setter
    def allow_rebase_with_merge(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "allow_rebase_with_merge", value)

    @property
    @pulumi.getter(name="allowSquash")
    def allow_squash(self) -> Optional[pulumi.Input[bool]]:
        """
        Allow squash merge. Defaults to `false`
        """
        return pulumi.get(self, "allow_squash")

    @allow_squash.setter
    def allow_squash(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "allow_squash", value)


if not MYPY:
    class BranchPolicyMergeTypesSettingsScopeArgsDict(TypedDict):
        match_type: NotRequired[pulumi.Input[str]]
        """
        The match type to use when applying the policy. Supported values are `Exact` (default), `Prefix` or `DefaultBranch`.
        """
        repository_id: NotRequired[pulumi.Input[str]]
        """
        The repository ID. Needed only if the scope of the policy will be limited to a single repository. If `match_type` is `DefaultBranch`, this should not be defined.
        """
        repository_ref: NotRequired[pulumi.Input[str]]
        """
        The ref pattern to use for the match when `match_type` other than `DefaultBranch`. If `match_type` is `Exact`, this should be a qualified ref such as `refs/heads/master`. If `match_type` is `Prefix`, this should be a ref path such as `refs/heads/releases`.
        """
elif False:
    BranchPolicyMergeTypesSettingsScopeArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class BranchPolicyMergeTypesSettingsScopeArgs:
    def __init__(__self__, *,
                 match_type: Optional[pulumi.Input[str]] = None,
                 repository_id: Optional[pulumi.Input[str]] = None,
                 repository_ref: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] match_type: The match type to use when applying the policy. Supported values are `Exact` (default), `Prefix` or `DefaultBranch`.
        :param pulumi.Input[str] repository_id: The repository ID. Needed only if the scope of the policy will be limited to a single repository. If `match_type` is `DefaultBranch`, this should not be defined.
        :param pulumi.Input[str] repository_ref: The ref pattern to use for the match when `match_type` other than `DefaultBranch`. If `match_type` is `Exact`, this should be a qualified ref such as `refs/heads/master`. If `match_type` is `Prefix`, this should be a ref path such as `refs/heads/releases`.
        """
        if match_type is not None:
            pulumi.set(__self__, "match_type", match_type)
        if repository_id is not None:
            pulumi.set(__self__, "repository_id", repository_id)
        if repository_ref is not None:
            pulumi.set(__self__, "repository_ref", repository_ref)

    @property
    @pulumi.getter(name="matchType")
    def match_type(self) -> Optional[pulumi.Input[str]]:
        """
        The match type to use when applying the policy. Supported values are `Exact` (default), `Prefix` or `DefaultBranch`.
        """
        return pulumi.get(self, "match_type")

    @match_type.setter
    def match_type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "match_type", value)

    @property
    @pulumi.getter(name="repositoryId")
    def repository_id(self) -> Optional[pulumi.Input[str]]:
        """
        The repository ID. Needed only if the scope of the policy will be limited to a single repository. If `match_type` is `DefaultBranch`, this should not be defined.
        """
        return pulumi.get(self, "repository_id")

    @repository_id.setter
    def repository_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "repository_id", value)

    @property
    @pulumi.getter(name="repositoryRef")
    def repository_ref(self) -> Optional[pulumi.Input[str]]:
        """
        The ref pattern to use for the match when `match_type` other than `DefaultBranch`. If `match_type` is `Exact`, this should be a qualified ref such as `refs/heads/master`. If `match_type` is `Prefix`, this should be a ref path such as `refs/heads/releases`.
        """
        return pulumi.get(self, "repository_ref")

    @repository_ref.setter
    def repository_ref(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "repository_ref", value)


if not MYPY:
    class BranchPolicyMinReviewersSettingsArgsDict(TypedDict):
        scopes: pulumi.Input[Sequence[pulumi.Input['BranchPolicyMinReviewersSettingsScopeArgsDict']]]
        """
        A `scope` block as defined below. Controls which repositories and branches the policy will be enabled for. This block must be defined at least once.
        """
        allow_completion_with_rejects_or_waits: NotRequired[pulumi.Input[bool]]
        """
        Allow completion even if some reviewers vote to wait or reject. Defaults to `false`.
        """
        last_pusher_cannot_approve: NotRequired[pulumi.Input[bool]]
        """
        Prohibit the most recent pusher from approving their own changes. Defaults to `false`.
        """
        on_last_iteration_require_vote: NotRequired[pulumi.Input[bool]]
        """
        On last iteration require vote. Defaults to `false`.
        """
        on_push_reset_all_votes: NotRequired[pulumi.Input[bool]]
        """
        When new changes are pushed reset all code reviewer votes. Defaults to `false`.

        > **Note:** If `on_push_reset_all_votes` is `true` then `on_push_reset_approved_votes` will be set to `true`. To enable `on_push_reset_approved_votes`, you need explicitly set `on_push_reset_all_votes` `false` or not configure.
        """
        on_push_reset_approved_votes: NotRequired[pulumi.Input[bool]]
        """
        When new changes are pushed reset all approval votes (does not reset votes to reject or wait). Defaults to `false`.
        """
        reviewer_count: NotRequired[pulumi.Input[int]]
        """
        The number of reviewers needed to approve.
        """
        submitter_can_vote: NotRequired[pulumi.Input[bool]]
        """
        Allow requesters to approve their own changes. Defaults to `false`.
        """
elif False:
    BranchPolicyMinReviewersSettingsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class BranchPolicyMinReviewersSettingsArgs:
    def __init__(__self__, *,
                 scopes: pulumi.Input[Sequence[pulumi.Input['BranchPolicyMinReviewersSettingsScopeArgs']]],
                 allow_completion_with_rejects_or_waits: Optional[pulumi.Input[bool]] = None,
                 last_pusher_cannot_approve: Optional[pulumi.Input[bool]] = None,
                 on_last_iteration_require_vote: Optional[pulumi.Input[bool]] = None,
                 on_push_reset_all_votes: Optional[pulumi.Input[bool]] = None,
                 on_push_reset_approved_votes: Optional[pulumi.Input[bool]] = None,
                 reviewer_count: Optional[pulumi.Input[int]] = None,
                 submitter_can_vote: Optional[pulumi.Input[bool]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input['BranchPolicyMinReviewersSettingsScopeArgs']]] scopes: A `scope` block as defined below. Controls which repositories and branches the policy will be enabled for. This block must be defined at least once.
        :param pulumi.Input[bool] allow_completion_with_rejects_or_waits: Allow completion even if some reviewers vote to wait or reject. Defaults to `false`.
        :param pulumi.Input[bool] last_pusher_cannot_approve: Prohibit the most recent pusher from approving their own changes. Defaults to `false`.
        :param pulumi.Input[bool] on_last_iteration_require_vote: On last iteration require vote. Defaults to `false`.
        :param pulumi.Input[bool] on_push_reset_all_votes: When new changes are pushed reset all code reviewer votes. Defaults to `false`.
               
               > **Note:** If `on_push_reset_all_votes` is `true` then `on_push_reset_approved_votes` will be set to `true`. To enable `on_push_reset_approved_votes`, you need explicitly set `on_push_reset_all_votes` `false` or not configure.
        :param pulumi.Input[bool] on_push_reset_approved_votes: When new changes are pushed reset all approval votes (does not reset votes to reject or wait). Defaults to `false`.
        :param pulumi.Input[int] reviewer_count: The number of reviewers needed to approve.
        :param pulumi.Input[bool] submitter_can_vote: Allow requesters to approve their own changes. Defaults to `false`.
        """
        pulumi.set(__self__, "scopes", scopes)
        if allow_completion_with_rejects_or_waits is not None:
            pulumi.set(__self__, "allow_completion_with_rejects_or_waits", allow_completion_with_rejects_or_waits)
        if last_pusher_cannot_approve is not None:
            pulumi.set(__self__, "last_pusher_cannot_approve", last_pusher_cannot_approve)
        if on_last_iteration_require_vote is not None:
            pulumi.set(__self__, "on_last_iteration_require_vote", on_last_iteration_require_vote)
        if on_push_reset_all_votes is not None:
            pulumi.set(__self__, "on_push_reset_all_votes", on_push_reset_all_votes)
        if on_push_reset_approved_votes is not None:
            pulumi.set(__self__, "on_push_reset_approved_votes", on_push_reset_approved_votes)
        if reviewer_count is not None:
            pulumi.set(__self__, "reviewer_count", reviewer_count)
        if submitter_can_vote is not None:
            pulumi.set(__self__, "submitter_can_vote", submitter_can_vote)

    @property
    @pulumi.getter
    def scopes(self) -> pulumi.Input[Sequence[pulumi.Input['BranchPolicyMinReviewersSettingsScopeArgs']]]:
        """
        A `scope` block as defined below. Controls which repositories and branches the policy will be enabled for. This block must be defined at least once.
        """
        return pulumi.get(self, "scopes")

    @scopes.setter
    def scopes(self, value: pulumi.Input[Sequence[pulumi.Input['BranchPolicyMinReviewersSettingsScopeArgs']]]):
        pulumi.set(self, "scopes", value)

    @property
    @pulumi.getter(name="allowCompletionWithRejectsOrWaits")
    def allow_completion_with_rejects_or_waits(self) -> Optional[pulumi.Input[bool]]:
        """
        Allow completion even if some reviewers vote to wait or reject. Defaults to `false`.
        """
        return pulumi.get(self, "allow_completion_with_rejects_or_waits")

    @allow_completion_with_rejects_or_waits.setter
    def allow_completion_with_rejects_or_waits(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "allow_completion_with_rejects_or_waits", value)

    @property
    @pulumi.getter(name="lastPusherCannotApprove")
    def last_pusher_cannot_approve(self) -> Optional[pulumi.Input[bool]]:
        """
        Prohibit the most recent pusher from approving their own changes. Defaults to `false`.
        """
        return pulumi.get(self, "last_pusher_cannot_approve")

    @last_pusher_cannot_approve.setter
    def last_pusher_cannot_approve(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "last_pusher_cannot_approve", value)

    @property
    @pulumi.getter(name="onLastIterationRequireVote")
    def on_last_iteration_require_vote(self) -> Optional[pulumi.Input[bool]]:
        """
        On last iteration require vote. Defaults to `false`.
        """
        return pulumi.get(self, "on_last_iteration_require_vote")

    @on_last_iteration_require_vote.setter
    def on_last_iteration_require_vote(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "on_last_iteration_require_vote", value)

    @property
    @pulumi.getter(name="onPushResetAllVotes")
    def on_push_reset_all_votes(self) -> Optional[pulumi.Input[bool]]:
        """
        When new changes are pushed reset all code reviewer votes. Defaults to `false`.

        > **Note:** If `on_push_reset_all_votes` is `true` then `on_push_reset_approved_votes` will be set to `true`. To enable `on_push_reset_approved_votes`, you need explicitly set `on_push_reset_all_votes` `false` or not configure.
        """
        return pulumi.get(self, "on_push_reset_all_votes")

    @on_push_reset_all_votes.setter
    def on_push_reset_all_votes(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "on_push_reset_all_votes", value)

    @property
    @pulumi.getter(name="onPushResetApprovedVotes")
    def on_push_reset_approved_votes(self) -> Optional[pulumi.Input[bool]]:
        """
        When new changes are pushed reset all approval votes (does not reset votes to reject or wait). Defaults to `false`.
        """
        return pulumi.get(self, "on_push_reset_approved_votes")

    @on_push_reset_approved_votes.setter
    def on_push_reset_approved_votes(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "on_push_reset_approved_votes", value)

    @property
    @pulumi.getter(name="reviewerCount")
    def reviewer_count(self) -> Optional[pulumi.Input[int]]:
        """
        The number of reviewers needed to approve.
        """
        return pulumi.get(self, "reviewer_count")

    @reviewer_count.setter
    def reviewer_count(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "reviewer_count", value)

    @property
    @pulumi.getter(name="submitterCanVote")
    def submitter_can_vote(self) -> Optional[pulumi.Input[bool]]:
        """
        Allow requesters to approve their own changes. Defaults to `false`.
        """
        return pulumi.get(self, "submitter_can_vote")

    @submitter_can_vote.setter
    def submitter_can_vote(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "submitter_can_vote", value)


if not MYPY:
    class BranchPolicyMinReviewersSettingsScopeArgsDict(TypedDict):
        match_type: NotRequired[pulumi.Input[str]]
        """
        The match type to use when applying the policy. Supported values are `Exact` (default), `Prefix` or `DefaultBranch`.
        """
        repository_id: NotRequired[pulumi.Input[str]]
        """
        The repository ID. Needed only if the scope of the policy will be limited to a single repository. If `match_type` is `DefaultBranch`, this should not be defined.
        """
        repository_ref: NotRequired[pulumi.Input[str]]
        """
        The ref pattern to use for the match when `match_type` other than `DefaultBranch`. If `match_type` is `Exact`, this should be a qualified ref such as `refs/heads/master`. If `match_type` is `Prefix`, this should be a ref path such as `refs/heads/releases`.
        """
elif False:
    BranchPolicyMinReviewersSettingsScopeArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class BranchPolicyMinReviewersSettingsScopeArgs:
    def __init__(__self__, *,
                 match_type: Optional[pulumi.Input[str]] = None,
                 repository_id: Optional[pulumi.Input[str]] = None,
                 repository_ref: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] match_type: The match type to use when applying the policy. Supported values are `Exact` (default), `Prefix` or `DefaultBranch`.
        :param pulumi.Input[str] repository_id: The repository ID. Needed only if the scope of the policy will be limited to a single repository. If `match_type` is `DefaultBranch`, this should not be defined.
        :param pulumi.Input[str] repository_ref: The ref pattern to use for the match when `match_type` other than `DefaultBranch`. If `match_type` is `Exact`, this should be a qualified ref such as `refs/heads/master`. If `match_type` is `Prefix`, this should be a ref path such as `refs/heads/releases`.
        """
        if match_type is not None:
            pulumi.set(__self__, "match_type", match_type)
        if repository_id is not None:
            pulumi.set(__self__, "repository_id", repository_id)
        if repository_ref is not None:
            pulumi.set(__self__, "repository_ref", repository_ref)

    @property
    @pulumi.getter(name="matchType")
    def match_type(self) -> Optional[pulumi.Input[str]]:
        """
        The match type to use when applying the policy. Supported values are `Exact` (default), `Prefix` or `DefaultBranch`.
        """
        return pulumi.get(self, "match_type")

    @match_type.setter
    def match_type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "match_type", value)

    @property
    @pulumi.getter(name="repositoryId")
    def repository_id(self) -> Optional[pulumi.Input[str]]:
        """
        The repository ID. Needed only if the scope of the policy will be limited to a single repository. If `match_type` is `DefaultBranch`, this should not be defined.
        """
        return pulumi.get(self, "repository_id")

    @repository_id.setter
    def repository_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "repository_id", value)

    @property
    @pulumi.getter(name="repositoryRef")
    def repository_ref(self) -> Optional[pulumi.Input[str]]:
        """
        The ref pattern to use for the match when `match_type` other than `DefaultBranch`. If `match_type` is `Exact`, this should be a qualified ref such as `refs/heads/master`. If `match_type` is `Prefix`, this should be a ref path such as `refs/heads/releases`.
        """
        return pulumi.get(self, "repository_ref")

    @repository_ref.setter
    def repository_ref(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "repository_ref", value)


if not MYPY:
    class BranchPolicyStatusCheckSettingsArgsDict(TypedDict):
        name: pulumi.Input[str]
        """
        The status name to check.
        """
        scopes: pulumi.Input[Sequence[pulumi.Input['BranchPolicyStatusCheckSettingsScopeArgsDict']]]
        """
        A `scope` block as defined below.
        """
        applicability: NotRequired[pulumi.Input[str]]
        """
        Policy applicability. If policy `applicability=default`, apply unless "Not Applicable"
        status is posted to the pull request. If policy `applicability=conditional`, policy is applied only after a status
        is posted to the pull request. Possible values `default`, `conditional`. Defaults to `default`.
        """
        author_id: NotRequired[pulumi.Input[str]]
        """
        The authorized user can post the status.
        """
        display_name: NotRequired[pulumi.Input[str]]
        """
        The display name.
        """
        filename_patterns: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        If a path filter is set, the policy will only apply when files which match the filter are changed. Not setting this field means that the policy is always applied.

        ~>**NOTE** 1. Specify absolute paths and wildcards. Example: `["/WebApp/Models/Data.cs", "/WebApp/*", "*.cs"]`.
        <br> 2. Paths prefixed with "!" are excluded. Example: `["/WebApp/*", "!/WebApp/Tests/*"]`. Order is significant.
        """
        genre: NotRequired[pulumi.Input[str]]
        """
        The genre of the status to check (see [Microsoft Documentation](https://docs.microsoft.com/en-us/azure/devops/repos/git/pull-request-status?view=azure-devops#status-policy))
        """
        invalidate_on_update: NotRequired[pulumi.Input[bool]]
        """
        Reset status whenever there are new changes.
        """
elif False:
    BranchPolicyStatusCheckSettingsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class BranchPolicyStatusCheckSettingsArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[str],
                 scopes: pulumi.Input[Sequence[pulumi.Input['BranchPolicyStatusCheckSettingsScopeArgs']]],
                 applicability: Optional[pulumi.Input[str]] = None,
                 author_id: Optional[pulumi.Input[str]] = None,
                 display_name: Optional[pulumi.Input[str]] = None,
                 filename_patterns: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 genre: Optional[pulumi.Input[str]] = None,
                 invalidate_on_update: Optional[pulumi.Input[bool]] = None):
        """
        :param pulumi.Input[str] name: The status name to check.
        :param pulumi.Input[Sequence[pulumi.Input['BranchPolicyStatusCheckSettingsScopeArgs']]] scopes: A `scope` block as defined below.
        :param pulumi.Input[str] applicability: Policy applicability. If policy `applicability=default`, apply unless "Not Applicable"
               status is posted to the pull request. If policy `applicability=conditional`, policy is applied only after a status
               is posted to the pull request. Possible values `default`, `conditional`. Defaults to `default`.
        :param pulumi.Input[str] author_id: The authorized user can post the status.
        :param pulumi.Input[str] display_name: The display name.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] filename_patterns: If a path filter is set, the policy will only apply when files which match the filter are changed. Not setting this field means that the policy is always applied.
               
               ~>**NOTE** 1. Specify absolute paths and wildcards. Example: `["/WebApp/Models/Data.cs", "/WebApp/*", "*.cs"]`.
               <br> 2. Paths prefixed with "!" are excluded. Example: `["/WebApp/*", "!/WebApp/Tests/*"]`. Order is significant.
        :param pulumi.Input[str] genre: The genre of the status to check (see [Microsoft Documentation](https://docs.microsoft.com/en-us/azure/devops/repos/git/pull-request-status?view=azure-devops#status-policy))
        :param pulumi.Input[bool] invalidate_on_update: Reset status whenever there are new changes.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "scopes", scopes)
        if applicability is not None:
            pulumi.set(__self__, "applicability", applicability)
        if author_id is not None:
            pulumi.set(__self__, "author_id", author_id)
        if display_name is not None:
            pulumi.set(__self__, "display_name", display_name)
        if filename_patterns is not None:
            pulumi.set(__self__, "filename_patterns", filename_patterns)
        if genre is not None:
            pulumi.set(__self__, "genre", genre)
        if invalidate_on_update is not None:
            pulumi.set(__self__, "invalidate_on_update", invalidate_on_update)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        The status name to check.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def scopes(self) -> pulumi.Input[Sequence[pulumi.Input['BranchPolicyStatusCheckSettingsScopeArgs']]]:
        """
        A `scope` block as defined below.
        """
        return pulumi.get(self, "scopes")

    @scopes.setter
    def scopes(self, value: pulumi.Input[Sequence[pulumi.Input['BranchPolicyStatusCheckSettingsScopeArgs']]]):
        pulumi.set(self, "scopes", value)

    @property
    @pulumi.getter
    def applicability(self) -> Optional[pulumi.Input[str]]:
        """
        Policy applicability. If policy `applicability=default`, apply unless "Not Applicable"
        status is posted to the pull request. If policy `applicability=conditional`, policy is applied only after a status
        is posted to the pull request. Possible values `default`, `conditional`. Defaults to `default`.
        """
        return pulumi.get(self, "applicability")

    @applicability.setter
    def applicability(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "applicability", value)

    @property
    @pulumi.getter(name="authorId")
    def author_id(self) -> Optional[pulumi.Input[str]]:
        """
        The authorized user can post the status.
        """
        return pulumi.get(self, "author_id")

    @author_id.setter
    def author_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "author_id", value)

    @property
    @pulumi.getter(name="displayName")
    def display_name(self) -> Optional[pulumi.Input[str]]:
        """
        The display name.
        """
        return pulumi.get(self, "display_name")

    @display_name.setter
    def display_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "display_name", value)

    @property
    @pulumi.getter(name="filenamePatterns")
    def filename_patterns(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        If a path filter is set, the policy will only apply when files which match the filter are changed. Not setting this field means that the policy is always applied.

        ~>**NOTE** 1. Specify absolute paths and wildcards. Example: `["/WebApp/Models/Data.cs", "/WebApp/*", "*.cs"]`.
        <br> 2. Paths prefixed with "!" are excluded. Example: `["/WebApp/*", "!/WebApp/Tests/*"]`. Order is significant.
        """
        return pulumi.get(self, "filename_patterns")

    @filename_patterns.setter
    def filename_patterns(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "filename_patterns", value)

    @property
    @pulumi.getter
    def genre(self) -> Optional[pulumi.Input[str]]:
        """
        The genre of the status to check (see [Microsoft Documentation](https://docs.microsoft.com/en-us/azure/devops/repos/git/pull-request-status?view=azure-devops#status-policy))
        """
        return pulumi.get(self, "genre")

    @genre.setter
    def genre(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "genre", value)

    @property
    @pulumi.getter(name="invalidateOnUpdate")
    def invalidate_on_update(self) -> Optional[pulumi.Input[bool]]:
        """
        Reset status whenever there are new changes.
        """
        return pulumi.get(self, "invalidate_on_update")

    @invalidate_on_update.setter
    def invalidate_on_update(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "invalidate_on_update", value)


if not MYPY:
    class BranchPolicyStatusCheckSettingsScopeArgsDict(TypedDict):
        match_type: NotRequired[pulumi.Input[str]]
        """
        The match type to use when applying the policy. Supported values are `Exact` (default), `Prefix` or `DefaultBranch`.
        """
        repository_id: NotRequired[pulumi.Input[str]]
        """
        The repository ID. Needed only if the scope of the policy will be limited to a single repository. If `match_type=DefaultBranch`, this should not be defined.
        """
        repository_ref: NotRequired[pulumi.Input[str]]
        """
        The ref pattern to use for the match when `match_type` other than `DefaultBranch`. If `match_type=Exact`, this should be a qualified ref such as `refs/heads/master`. If `match_type=Prefix`, this should be a ref path such as `refs/heads/releases`.
        """
elif False:
    BranchPolicyStatusCheckSettingsScopeArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class BranchPolicyStatusCheckSettingsScopeArgs:
    def __init__(__self__, *,
                 match_type: Optional[pulumi.Input[str]] = None,
                 repository_id: Optional[pulumi.Input[str]] = None,
                 repository_ref: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] match_type: The match type to use when applying the policy. Supported values are `Exact` (default), `Prefix` or `DefaultBranch`.
        :param pulumi.Input[str] repository_id: The repository ID. Needed only if the scope of the policy will be limited to a single repository. If `match_type=DefaultBranch`, this should not be defined.
        :param pulumi.Input[str] repository_ref: The ref pattern to use for the match when `match_type` other than `DefaultBranch`. If `match_type=Exact`, this should be a qualified ref such as `refs/heads/master`. If `match_type=Prefix`, this should be a ref path such as `refs/heads/releases`.
        """
        if match_type is not None:
            pulumi.set(__self__, "match_type", match_type)
        if repository_id is not None:
            pulumi.set(__self__, "repository_id", repository_id)
        if repository_ref is not None:
            pulumi.set(__self__, "repository_ref", repository_ref)

    @property
    @pulumi.getter(name="matchType")
    def match_type(self) -> Optional[pulumi.Input[str]]:
        """
        The match type to use when applying the policy. Supported values are `Exact` (default), `Prefix` or `DefaultBranch`.
        """
        return pulumi.get(self, "match_type")

    @match_type.setter
    def match_type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "match_type", value)

    @property
    @pulumi.getter(name="repositoryId")
    def repository_id(self) -> Optional[pulumi.Input[str]]:
        """
        The repository ID. Needed only if the scope of the policy will be limited to a single repository. If `match_type=DefaultBranch`, this should not be defined.
        """
        return pulumi.get(self, "repository_id")

    @repository_id.setter
    def repository_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "repository_id", value)

    @property
    @pulumi.getter(name="repositoryRef")
    def repository_ref(self) -> Optional[pulumi.Input[str]]:
        """
        The ref pattern to use for the match when `match_type` other than `DefaultBranch`. If `match_type=Exact`, this should be a qualified ref such as `refs/heads/master`. If `match_type=Prefix`, this should be a ref path such as `refs/heads/releases`.
        """
        return pulumi.get(self, "repository_ref")

    @repository_ref.setter
    def repository_ref(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "repository_ref", value)


if not MYPY:
    class BranchPolicyWorkItemLinkingSettingsArgsDict(TypedDict):
        scopes: pulumi.Input[Sequence[pulumi.Input['BranchPolicyWorkItemLinkingSettingsScopeArgsDict']]]
        """
        A `scope` block as defined below. Controls which repositories and branches the policy will be enabled for. This block must be defined at least once.
        """
elif False:
    BranchPolicyWorkItemLinkingSettingsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class BranchPolicyWorkItemLinkingSettingsArgs:
    def __init__(__self__, *,
                 scopes: pulumi.Input[Sequence[pulumi.Input['BranchPolicyWorkItemLinkingSettingsScopeArgs']]]):
        """
        :param pulumi.Input[Sequence[pulumi.Input['BranchPolicyWorkItemLinkingSettingsScopeArgs']]] scopes: A `scope` block as defined below. Controls which repositories and branches the policy will be enabled for. This block must be defined at least once.
        """
        pulumi.set(__self__, "scopes", scopes)

    @property
    @pulumi.getter
    def scopes(self) -> pulumi.Input[Sequence[pulumi.Input['BranchPolicyWorkItemLinkingSettingsScopeArgs']]]:
        """
        A `scope` block as defined below. Controls which repositories and branches the policy will be enabled for. This block must be defined at least once.
        """
        return pulumi.get(self, "scopes")

    @scopes.setter
    def scopes(self, value: pulumi.Input[Sequence[pulumi.Input['BranchPolicyWorkItemLinkingSettingsScopeArgs']]]):
        pulumi.set(self, "scopes", value)


if not MYPY:
    class BranchPolicyWorkItemLinkingSettingsScopeArgsDict(TypedDict):
        match_type: NotRequired[pulumi.Input[str]]
        """
        The match type to use when applying the policy. Supported values are `Exact` (default), `Prefix` or `DefaultBranch`.
        """
        repository_id: NotRequired[pulumi.Input[str]]
        """
        The repository ID. Needed only if the scope of the policy will be limited to a single repository. If `match_type` is `DefaultBranch`, this should not be defined.
        """
        repository_ref: NotRequired[pulumi.Input[str]]
        """
        The ref pattern to use for the match when `match_type` other than `DefaultBranch`. If `match_type` is `Exact`, this should be a qualified ref such as `refs/heads/master`. If `match_type` is `Prefix`, this should be a ref path such as `refs/heads/releases`.
        """
elif False:
    BranchPolicyWorkItemLinkingSettingsScopeArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class BranchPolicyWorkItemLinkingSettingsScopeArgs:
    def __init__(__self__, *,
                 match_type: Optional[pulumi.Input[str]] = None,
                 repository_id: Optional[pulumi.Input[str]] = None,
                 repository_ref: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] match_type: The match type to use when applying the policy. Supported values are `Exact` (default), `Prefix` or `DefaultBranch`.
        :param pulumi.Input[str] repository_id: The repository ID. Needed only if the scope of the policy will be limited to a single repository. If `match_type` is `DefaultBranch`, this should not be defined.
        :param pulumi.Input[str] repository_ref: The ref pattern to use for the match when `match_type` other than `DefaultBranch`. If `match_type` is `Exact`, this should be a qualified ref such as `refs/heads/master`. If `match_type` is `Prefix`, this should be a ref path such as `refs/heads/releases`.
        """
        if match_type is not None:
            pulumi.set(__self__, "match_type", match_type)
        if repository_id is not None:
            pulumi.set(__self__, "repository_id", repository_id)
        if repository_ref is not None:
            pulumi.set(__self__, "repository_ref", repository_ref)

    @property
    @pulumi.getter(name="matchType")
    def match_type(self) -> Optional[pulumi.Input[str]]:
        """
        The match type to use when applying the policy. Supported values are `Exact` (default), `Prefix` or `DefaultBranch`.
        """
        return pulumi.get(self, "match_type")

    @match_type.setter
    def match_type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "match_type", value)

    @property
    @pulumi.getter(name="repositoryId")
    def repository_id(self) -> Optional[pulumi.Input[str]]:
        """
        The repository ID. Needed only if the scope of the policy will be limited to a single repository. If `match_type` is `DefaultBranch`, this should not be defined.
        """
        return pulumi.get(self, "repository_id")

    @repository_id.setter
    def repository_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "repository_id", value)

    @property
    @pulumi.getter(name="repositoryRef")
    def repository_ref(self) -> Optional[pulumi.Input[str]]:
        """
        The ref pattern to use for the match when `match_type` other than `DefaultBranch`. If `match_type` is `Exact`, this should be a qualified ref such as `refs/heads/master`. If `match_type` is `Prefix`, this should be a ref path such as `refs/heads/releases`.
        """
        return pulumi.get(self, "repository_ref")

    @repository_ref.setter
    def repository_ref(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "repository_ref", value)


if not MYPY:
    class BuildDefinitionBuildCompletionTriggerArgsDict(TypedDict):
        branch_filters: pulumi.Input[Sequence[pulumi.Input['BuildDefinitionBuildCompletionTriggerBranchFilterArgsDict']]]
        """
        The branches to include and exclude from the trigger. A `branch_filter` block as documented below.
        """
        build_definition_id: pulumi.Input[int]
        """
        The ID of the build pipeline will be triggered.
        """
elif False:
    BuildDefinitionBuildCompletionTriggerArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class BuildDefinitionBuildCompletionTriggerArgs:
    def __init__(__self__, *,
                 branch_filters: pulumi.Input[Sequence[pulumi.Input['BuildDefinitionBuildCompletionTriggerBranchFilterArgs']]],
                 build_definition_id: pulumi.Input[int]):
        """
        :param pulumi.Input[Sequence[pulumi.Input['BuildDefinitionBuildCompletionTriggerBranchFilterArgs']]] branch_filters: The branches to include and exclude from the trigger. A `branch_filter` block as documented below.
        :param pulumi.Input[int] build_definition_id: The ID of the build pipeline will be triggered.
        """
        pulumi.set(__self__, "branch_filters", branch_filters)
        pulumi.set(__self__, "build_definition_id", build_definition_id)

    @property
    @pulumi.getter(name="branchFilters")
    def branch_filters(self) -> pulumi.Input[Sequence[pulumi.Input['BuildDefinitionBuildCompletionTriggerBranchFilterArgs']]]:
        """
        The branches to include and exclude from the trigger. A `branch_filter` block as documented below.
        """
        return pulumi.get(self, "branch_filters")

    @branch_filters.setter
    def branch_filters(self, value: pulumi.Input[Sequence[pulumi.Input['BuildDefinitionBuildCompletionTriggerBranchFilterArgs']]]):
        pulumi.set(self, "branch_filters", value)

    @property
    @pulumi.getter(name="buildDefinitionId")
    def build_definition_id(self) -> pulumi.Input[int]:
        """
        The ID of the build pipeline will be triggered.
        """
        return pulumi.get(self, "build_definition_id")

    @build_definition_id.setter
    def build_definition_id(self, value: pulumi.Input[int]):
        pulumi.set(self, "build_definition_id", value)


if not MYPY:
    class BuildDefinitionBuildCompletionTriggerBranchFilterArgsDict(TypedDict):
        excludes: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        List of branch patterns to exclude.
        """
        includes: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        List of branch patterns to include.
        """
elif False:
    BuildDefinitionBuildCompletionTriggerBranchFilterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class BuildDefinitionBuildCompletionTriggerBranchFilterArgs:
    def __init__(__self__, *,
                 excludes: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 includes: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input[str]]] excludes: List of branch patterns to exclude.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] includes: List of branch patterns to include.
        """
        if excludes is not None:
            pulumi.set(__self__, "excludes", excludes)
        if includes is not None:
            pulumi.set(__self__, "includes", includes)

    @property
    @pulumi.getter
    def excludes(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        List of branch patterns to exclude.
        """
        return pulumi.get(self, "excludes")

    @excludes.setter
    def excludes(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "excludes", value)

    @property
    @pulumi.getter
    def includes(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        List of branch patterns to include.
        """
        return pulumi.get(self, "includes")

    @includes.setter
    def includes(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "includes", value)


if not MYPY:
    class BuildDefinitionCiTriggerArgsDict(TypedDict):
        override: NotRequired[pulumi.Input['BuildDefinitionCiTriggerOverrideArgsDict']]
        """
        Override the azure-pipeline file and use a this configuration for all builds.
        """
        use_yaml: NotRequired[pulumi.Input[bool]]
        """
        Use the azure-pipeline file for the build configuration. Defaults to `false`.
        """
elif False:
    BuildDefinitionCiTriggerArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class BuildDefinitionCiTriggerArgs:
    def __init__(__self__, *,
                 override: Optional[pulumi.Input['BuildDefinitionCiTriggerOverrideArgs']] = None,
                 use_yaml: Optional[pulumi.Input[bool]] = None):
        """
        :param pulumi.Input['BuildDefinitionCiTriggerOverrideArgs'] override: Override the azure-pipeline file and use a this configuration for all builds.
        :param pulumi.Input[bool] use_yaml: Use the azure-pipeline file for the build configuration. Defaults to `false`.
        """
        if override is not None:
            pulumi.set(__self__, "override", override)
        if use_yaml is not None:
            pulumi.set(__self__, "use_yaml", use_yaml)

    @property
    @pulumi.getter
    def override(self) -> Optional[pulumi.Input['BuildDefinitionCiTriggerOverrideArgs']]:
        """
        Override the azure-pipeline file and use a this configuration for all builds.
        """
        return pulumi.get(self, "override")

    @override.setter
    def override(self, value: Optional[pulumi.Input['BuildDefinitionCiTriggerOverrideArgs']]):
        pulumi.set(self, "override", value)

    @property
    @pulumi.getter(name="useYaml")
    def use_yaml(self) -> Optional[pulumi.Input[bool]]:
        """
        Use the azure-pipeline file for the build configuration. Defaults to `false`.
        """
        return pulumi.get(self, "use_yaml")

    @use_yaml.setter
    def use_yaml(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "use_yaml", value)


if not MYPY:
    class BuildDefinitionCiTriggerOverrideArgsDict(TypedDict):
        branch_filters: pulumi.Input[Sequence[pulumi.Input['BuildDefinitionCiTriggerOverrideBranchFilterArgsDict']]]
        """
        The branches to include and exclude from the trigger. A `branch_filter` block as documented below.
        """
        batch: NotRequired[pulumi.Input[bool]]
        """
        If you set batch to true, when a pipeline is running, the system waits until the run is completed, then starts another run with all changes that have not yet been built. Defaults to `true`.
        """
        max_concurrent_builds_per_branch: NotRequired[pulumi.Input[int]]
        """
        The number of max builds per branch. Defaults to `1`.
        """
        path_filters: NotRequired[pulumi.Input[Sequence[pulumi.Input['BuildDefinitionCiTriggerOverridePathFilterArgsDict']]]]
        """
        Specify file paths to include or exclude. Note that the wildcard syntax is different between branches/tags and file paths.
        """
        polling_interval: NotRequired[pulumi.Input[int]]
        """
        How often the external repository is polled. Defaults to `0`.
        """
        polling_job_id: NotRequired[pulumi.Input[str]]
        """
        This is the ID of the polling job that polls the external repository. Once the build definition is saved/updated, this value is set.
        """
elif False:
    BuildDefinitionCiTriggerOverrideArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class BuildDefinitionCiTriggerOverrideArgs:
    def __init__(__self__, *,
                 branch_filters: pulumi.Input[Sequence[pulumi.Input['BuildDefinitionCiTriggerOverrideBranchFilterArgs']]],
                 batch: Optional[pulumi.Input[bool]] = None,
                 max_concurrent_builds_per_branch: Optional[pulumi.Input[int]] = None,
                 path_filters: Optional[pulumi.Input[Sequence[pulumi.Input['BuildDefinitionCiTriggerOverridePathFilterArgs']]]] = None,
                 polling_interval: Optional[pulumi.Input[int]] = None,
                 polling_job_id: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input['BuildDefinitionCiTriggerOverrideBranchFilterArgs']]] branch_filters: The branches to include and exclude from the trigger. A `branch_filter` block as documented below.
        :param pulumi.Input[bool] batch: If you set batch to true, when a pipeline is running, the system waits until the run is completed, then starts another run with all changes that have not yet been built. Defaults to `true`.
        :param pulumi.Input[int] max_concurrent_builds_per_branch: The number of max builds per branch. Defaults to `1`.
        :param pulumi.Input[Sequence[pulumi.Input['BuildDefinitionCiTriggerOverridePathFilterArgs']]] path_filters: Specify file paths to include or exclude. Note that the wildcard syntax is different between branches/tags and file paths.
        :param pulumi.Input[int] polling_interval: How often the external repository is polled. Defaults to `0`.
        :param pulumi.Input[str] polling_job_id: This is the ID of the polling job that polls the external repository. Once the build definition is saved/updated, this value is set.
        """
        pulumi.set(__self__, "branch_filters", branch_filters)
        if batch is not None:
            pulumi.set(__self__, "batch", batch)
        if max_concurrent_builds_per_branch is not None:
            pulumi.set(__self__, "max_concurrent_builds_per_branch", max_concurrent_builds_per_branch)
        if path_filters is not None:
            pulumi.set(__self__, "path_filters", path_filters)
        if polling_interval is not None:
            pulumi.set(__self__, "polling_interval", polling_interval)
        if polling_job_id is not None:
            pulumi.set(__self__, "polling_job_id", polling_job_id)

    @property
    @pulumi.getter(name="branchFilters")
    def branch_filters(self) -> pulumi.Input[Sequence[pulumi.Input['BuildDefinitionCiTriggerOverrideBranchFilterArgs']]]:
        """
        The branches to include and exclude from the trigger. A `branch_filter` block as documented below.
        """
        return pulumi.get(self, "branch_filters")

    @branch_filters.setter
    def branch_filters(self, value: pulumi.Input[Sequence[pulumi.Input['BuildDefinitionCiTriggerOverrideBranchFilterArgs']]]):
        pulumi.set(self, "branch_filters", value)

    @property
    @pulumi.getter
    def batch(self) -> Optional[pulumi.Input[bool]]:
        """
        If you set batch to true, when a pipeline is running, the system waits until the run is completed, then starts another run with all changes that have not yet been built. Defaults to `true`.
        """
        return pulumi.get(self, "batch")

    @batch.setter
    def batch(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "batch", value)

    @property
    @pulumi.getter(name="maxConcurrentBuildsPerBranch")
    def max_concurrent_builds_per_branch(self) -> Optional[pulumi.Input[int]]:
        """
        The number of max builds per branch. Defaults to `1`.
        """
        return pulumi.get(self, "max_concurrent_builds_per_branch")

    @max_concurrent_builds_per_branch.setter
    def max_concurrent_builds_per_branch(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "max_concurrent_builds_per_branch", value)

    @property
    @pulumi.getter(name="pathFilters")
    def path_filters(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['BuildDefinitionCiTriggerOverridePathFilterArgs']]]]:
        """
        Specify file paths to include or exclude. Note that the wildcard syntax is different between branches/tags and file paths.
        """
        return pulumi.get(self, "path_filters")

    @path_filters.setter
    def path_filters(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['BuildDefinitionCiTriggerOverridePathFilterArgs']]]]):
        pulumi.set(self, "path_filters", value)

    @property
    @pulumi.getter(name="pollingInterval")
    def polling_interval(self) -> Optional[pulumi.Input[int]]:
        """
        How often the external repository is polled. Defaults to `0`.
        """
        return pulumi.get(self, "polling_interval")

    @polling_interval.setter
    def polling_interval(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "polling_interval", value)

    @property
    @pulumi.getter(name="pollingJobId")
    def polling_job_id(self) -> Optional[pulumi.Input[str]]:
        """
        This is the ID of the polling job that polls the external repository. Once the build definition is saved/updated, this value is set.
        """
        return pulumi.get(self, "polling_job_id")

    @polling_job_id.setter
    def polling_job_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "polling_job_id", value)


if not MYPY:
    class BuildDefinitionCiTriggerOverrideBranchFilterArgsDict(TypedDict):
        excludes: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        List of branch patterns to exclude.
        """
        includes: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        List of branch patterns to include.
        """
elif False:
    BuildDefinitionCiTriggerOverrideBranchFilterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class BuildDefinitionCiTriggerOverrideBranchFilterArgs:
    def __init__(__self__, *,
                 excludes: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 includes: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input[str]]] excludes: List of branch patterns to exclude.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] includes: List of branch patterns to include.
        """
        if excludes is not None:
            pulumi.set(__self__, "excludes", excludes)
        if includes is not None:
            pulumi.set(__self__, "includes", includes)

    @property
    @pulumi.getter
    def excludes(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        List of branch patterns to exclude.
        """
        return pulumi.get(self, "excludes")

    @excludes.setter
    def excludes(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "excludes", value)

    @property
    @pulumi.getter
    def includes(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        List of branch patterns to include.
        """
        return pulumi.get(self, "includes")

    @includes.setter
    def includes(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "includes", value)


if not MYPY:
    class BuildDefinitionCiTriggerOverridePathFilterArgsDict(TypedDict):
        excludes: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        List of path patterns to exclude.
        """
        includes: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        List of path patterns to include.
        """
elif False:
    BuildDefinitionCiTriggerOverridePathFilterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class BuildDefinitionCiTriggerOverridePathFilterArgs:
    def __init__(__self__, *,
                 excludes: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 includes: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input[str]]] excludes: List of path patterns to exclude.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] includes: List of path patterns to include.
        """
        if excludes is not None:
            pulumi.set(__self__, "excludes", excludes)
        if includes is not None:
            pulumi.set(__self__, "includes", includes)

    @property
    @pulumi.getter
    def excludes(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        List of path patterns to exclude.
        """
        return pulumi.get(self, "excludes")

    @excludes.setter
    def excludes(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "excludes", value)

    @property
    @pulumi.getter
    def includes(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        List of path patterns to include.
        """
        return pulumi.get(self, "includes")

    @includes.setter
    def includes(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "includes", value)


if not MYPY:
    class BuildDefinitionFeatureArgsDict(TypedDict):
        skip_first_run: NotRequired[pulumi.Input[bool]]
        """
        Trigger the pipeline to run after the creation. Defaults to `true`.

        > **Note** The first run(`skip_first_run = false`) will only be triggered on create. If the first run fails, the build definition will still be marked as successfully created. A warning message indicating the inability to run pipeline will be displayed.
        """
elif False:
    BuildDefinitionFeatureArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class BuildDefinitionFeatureArgs:
    def __init__(__self__, *,
                 skip_first_run: Optional[pulumi.Input[bool]] = None):
        """
        :param pulumi.Input[bool] skip_first_run: Trigger the pipeline to run after the creation. Defaults to `true`.
               
               > **Note** The first run(`skip_first_run = false`) will only be triggered on create. If the first run fails, the build definition will still be marked as successfully created. A warning message indicating the inability to run pipeline will be displayed.
        """
        if skip_first_run is not None:
            pulumi.set(__self__, "skip_first_run", skip_first_run)

    @property
    @pulumi.getter(name="skipFirstRun")
    def skip_first_run(self) -> Optional[pulumi.Input[bool]]:
        """
        Trigger the pipeline to run after the creation. Defaults to `true`.

        > **Note** The first run(`skip_first_run = false`) will only be triggered on create. If the first run fails, the build definition will still be marked as successfully created. A warning message indicating the inability to run pipeline will be displayed.
        """
        return pulumi.get(self, "skip_first_run")

    @skip_first_run.setter
    def skip_first_run(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "skip_first_run", value)


if not MYPY:
    class BuildDefinitionJobArgsDict(TypedDict):
        condition: pulumi.Input[str]
        """
        Specifies when this job should run. Can **Custom conditions** to specify more complex conditions. Possible values: `succeeded()`, `succeededOrFailed()`, `always()`, `failed()` etc. More details: [Pipeline conditions](https://learn.microsoft.com/en-us/azure/devops/pipelines/process/conditions?view=azure-devops)
        """
        name: pulumi.Input[str]
        """
        The name of the job.
        """
        ref_name: pulumi.Input[str]
        """
        The reference name of the job, can be used to define the job dependencies.
        """
        target: pulumi.Input['BuildDefinitionJobTargetArgsDict']
        """
        A `target` blocks as documented below.
        """
        allow_scripts_auth_access_option: NotRequired[pulumi.Input[bool]]
        """
        Enables scripts and other processes launched by tasks to access the OAuth token through the `System.AccessToken` variable. Possible values: `true`, `false`. Defaults to `false`. Available when Job type is `AgentJob`
        """
        dependencies: NotRequired[pulumi.Input[Sequence[pulumi.Input['BuildDefinitionJobDependencyArgsDict']]]]
        """
        A `dependencies` blocks as documented below. Define the job dependencies.
        """
        job_authorization_scope: NotRequired[pulumi.Input[str]]
        """
        The job authorization scope for builds queued against this definition. Possible values are: `project`, `projectCollection`. Defaults to `projectCollection`.
        """
        job_cancel_timeout_in_minutes: NotRequired[pulumi.Input[int]]
        """
        The job cancel timeout (in minutes) for builds cancelled by user for this definition. Possible values are between `0` and `60`. Defaults to `0`.
        """
        job_timeout_in_minutes: NotRequired[pulumi.Input[int]]
        """
        The job execution timeout (in minutes) for builds queued against this definition. Possible values are between `0` and `1000000000`. Defaults to `0`.
        """
elif False:
    BuildDefinitionJobArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class BuildDefinitionJobArgs:
    def __init__(__self__, *,
                 condition: pulumi.Input[str],
                 name: pulumi.Input[str],
                 ref_name: pulumi.Input[str],
                 target: pulumi.Input['BuildDefinitionJobTargetArgs'],
                 allow_scripts_auth_access_option: Optional[pulumi.Input[bool]] = None,
                 dependencies: Optional[pulumi.Input[Sequence[pulumi.Input['BuildDefinitionJobDependencyArgs']]]] = None,
                 job_authorization_scope: Optional[pulumi.Input[str]] = None,
                 job_cancel_timeout_in_minutes: Optional[pulumi.Input[int]] = None,
                 job_timeout_in_minutes: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input[str] condition: Specifies when this job should run. Can **Custom conditions** to specify more complex conditions. Possible values: `succeeded()`, `succeededOrFailed()`, `always()`, `failed()` etc. More details: [Pipeline conditions](https://learn.microsoft.com/en-us/azure/devops/pipelines/process/conditions?view=azure-devops)
        :param pulumi.Input[str] name: The name of the job.
        :param pulumi.Input[str] ref_name: The reference name of the job, can be used to define the job dependencies.
        :param pulumi.Input['BuildDefinitionJobTargetArgs'] target: A `target` blocks as documented below.
        :param pulumi.Input[bool] allow_scripts_auth_access_option: Enables scripts and other processes launched by tasks to access the OAuth token through the `System.AccessToken` variable. Possible values: `true`, `false`. Defaults to `false`. Available when Job type is `AgentJob`
        :param pulumi.Input[Sequence[pulumi.Input['BuildDefinitionJobDependencyArgs']]] dependencies: A `dependencies` blocks as documented below. Define the job dependencies.
        :param pulumi.Input[str] job_authorization_scope: The job authorization scope for builds queued against this definition. Possible values are: `project`, `projectCollection`. Defaults to `projectCollection`.
        :param pulumi.Input[int] job_cancel_timeout_in_minutes: The job cancel timeout (in minutes) for builds cancelled by user for this definition. Possible values are between `0` and `60`. Defaults to `0`.
        :param pulumi.Input[int] job_timeout_in_minutes: The job execution timeout (in minutes) for builds queued against this definition. Possible values are between `0` and `1000000000`. Defaults to `0`.
        """
        pulumi.set(__self__, "condition", condition)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "ref_name", ref_name)
        pulumi.set(__self__, "target", target)
        if allow_scripts_auth_access_option is not None:
            pulumi.set(__self__, "allow_scripts_auth_access_option", allow_scripts_auth_access_option)
        if dependencies is not None:
            pulumi.set(__self__, "dependencies", dependencies)
        if job_authorization_scope is not None:
            pulumi.set(__self__, "job_authorization_scope", job_authorization_scope)
        if job_cancel_timeout_in_minutes is not None:
            pulumi.set(__self__, "job_cancel_timeout_in_minutes", job_cancel_timeout_in_minutes)
        if job_timeout_in_minutes is not None:
            pulumi.set(__self__, "job_timeout_in_minutes", job_timeout_in_minutes)

    @property
    @pulumi.getter
    def condition(self) -> pulumi.Input[str]:
        """
        Specifies when this job should run. Can **Custom conditions** to specify more complex conditions. Possible values: `succeeded()`, `succeededOrFailed()`, `always()`, `failed()` etc. More details: [Pipeline conditions](https://learn.microsoft.com/en-us/azure/devops/pipelines/process/conditions?view=azure-devops)
        """
        return pulumi.get(self, "condition")

    @condition.setter
    def condition(self, value: pulumi.Input[str]):
        pulumi.set(self, "condition", value)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        The name of the job.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter(name="refName")
    def ref_name(self) -> pulumi.Input[str]:
        """
        The reference name of the job, can be used to define the job dependencies.
        """
        return pulumi.get(self, "ref_name")

    @ref_name.setter
    def ref_name(self, value: pulumi.Input[str]):
        pulumi.set(self, "ref_name", value)

    @property
    @pulumi.getter
    def target(self) -> pulumi.Input['BuildDefinitionJobTargetArgs']:
        """
        A `target` blocks as documented below.
        """
        return pulumi.get(self, "target")

    @target.setter
    def target(self, value: pulumi.Input['BuildDefinitionJobTargetArgs']):
        pulumi.set(self, "target", value)

    @property
    @pulumi.getter(name="allowScriptsAuthAccessOption")
    def allow_scripts_auth_access_option(self) -> Optional[pulumi.Input[bool]]:
        """
        Enables scripts and other processes launched by tasks to access the OAuth token through the `System.AccessToken` variable. Possible values: `true`, `false`. Defaults to `false`. Available when Job type is `AgentJob`
        """
        return pulumi.get(self, "allow_scripts_auth_access_option")

    @allow_scripts_auth_access_option.setter
    def allow_scripts_auth_access_option(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "allow_scripts_auth_access_option", value)

    @property
    @pulumi.getter
    def dependencies(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['BuildDefinitionJobDependencyArgs']]]]:
        """
        A `dependencies` blocks as documented below. Define the job dependencies.
        """
        return pulumi.get(self, "dependencies")

    @dependencies.setter
    def dependencies(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['BuildDefinitionJobDependencyArgs']]]]):
        pulumi.set(self, "dependencies", value)

    @property
    @pulumi.getter(name="jobAuthorizationScope")
    def job_authorization_scope(self) -> Optional[pulumi.Input[str]]:
        """
        The job authorization scope for builds queued against this definition. Possible values are: `project`, `projectCollection`. Defaults to `projectCollection`.
        """
        return pulumi.get(self, "job_authorization_scope")

    @job_authorization_scope.setter
    def job_authorization_scope(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "job_authorization_scope", value)

    @property
    @pulumi.getter(name="jobCancelTimeoutInMinutes")
    def job_cancel_timeout_in_minutes(self) -> Optional[pulumi.Input[int]]:
        """
        The job cancel timeout (in minutes) for builds cancelled by user for this definition. Possible values are between `0` and `60`. Defaults to `0`.
        """
        return pulumi.get(self, "job_cancel_timeout_in_minutes")

    @job_cancel_timeout_in_minutes.setter
    def job_cancel_timeout_in_minutes(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "job_cancel_timeout_in_minutes", value)

    @property
    @pulumi.getter(name="jobTimeoutInMinutes")
    def job_timeout_in_minutes(self) -> Optional[pulumi.Input[int]]:
        """
        The job execution timeout (in minutes) for builds queued against this definition. Possible values are between `0` and `1000000000`. Defaults to `0`.
        """
        return pulumi.get(self, "job_timeout_in_minutes")

    @job_timeout_in_minutes.setter
    def job_timeout_in_minutes(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "job_timeout_in_minutes", value)


if not MYPY:
    class BuildDefinitionJobDependencyArgsDict(TypedDict):
        scope: pulumi.Input[str]
        """
        The job reference name that depends on. Reference to `jobs.ref_name`
        """
elif False:
    BuildDefinitionJobDependencyArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class BuildDefinitionJobDependencyArgs:
    def __init__(__self__, *,
                 scope: pulumi.Input[str]):
        """
        :param pulumi.Input[str] scope: The job reference name that depends on. Reference to `jobs.ref_name`
        """
        pulumi.set(__self__, "scope", scope)

    @property
    @pulumi.getter
    def scope(self) -> pulumi.Input[str]:
        """
        The job reference name that depends on. Reference to `jobs.ref_name`
        """
        return pulumi.get(self, "scope")

    @scope.setter
    def scope(self, value: pulumi.Input[str]):
        pulumi.set(self, "scope", value)


if not MYPY:
    class BuildDefinitionJobTargetArgsDict(TypedDict):
        execution_options: pulumi.Input['BuildDefinitionJobTargetExecutionOptionsArgsDict']
        """
        A `execution_options` blocks as documented below.
        """
        type: pulumi.Input[str]
        """
        The job type. Possible values: `AgentJob`, `AgentlessJob`
        """
        demands: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        A list of demands that represents the agent capabilities required by this build. Example: `git`
        """
elif False:
    BuildDefinitionJobTargetArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class BuildDefinitionJobTargetArgs:
    def __init__(__self__, *,
                 execution_options: pulumi.Input['BuildDefinitionJobTargetExecutionOptionsArgs'],
                 type: pulumi.Input[str],
                 demands: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input['BuildDefinitionJobTargetExecutionOptionsArgs'] execution_options: A `execution_options` blocks as documented below.
        :param pulumi.Input[str] type: The job type. Possible values: `AgentJob`, `AgentlessJob`
        :param pulumi.Input[Sequence[pulumi.Input[str]]] demands: A list of demands that represents the agent capabilities required by this build. Example: `git`
        """
        pulumi.set(__self__, "execution_options", execution_options)
        pulumi.set(__self__, "type", type)
        if demands is not None:
            pulumi.set(__self__, "demands", demands)

    @property
    @pulumi.getter(name="executionOptions")
    def execution_options(self) -> pulumi.Input['BuildDefinitionJobTargetExecutionOptionsArgs']:
        """
        A `execution_options` blocks as documented below.
        """
        return pulumi.get(self, "execution_options")

    @execution_options.setter
    def execution_options(self, value: pulumi.Input['BuildDefinitionJobTargetExecutionOptionsArgs']):
        pulumi.set(self, "execution_options", value)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[str]:
        """
        The job type. Possible values: `AgentJob`, `AgentlessJob`
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[str]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter
    def demands(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        A list of demands that represents the agent capabilities required by this build. Example: `git`
        """
        return pulumi.get(self, "demands")

    @demands.setter
    def demands(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "demands", value)


if not MYPY:
    class BuildDefinitionJobTargetExecutionOptionsArgsDict(TypedDict):
        type: pulumi.Input[str]
        """
        The execution type of the Job. Possible values are: `None`, `Multi-Configuration`, `Multi-Agent`.
        """
        continue_on_error: NotRequired[pulumi.Input[bool]]
        """
        Whether to continue the job when an error occurs. Possible values are: `true`, `false`.
        """
        max_concurrency: NotRequired[pulumi.Input[int]]
        """
        Limit the number of agents to be used. If job type is `AgentlessJob`, the concurrency is not configurable and is fixed to 50.
        """
        multipliers: NotRequired[pulumi.Input[str]]
        """
        A list of comma separated configuration variables to use. These are defined on the Variables tab. For example, OperatingSystem, Browser will run the tasks for both variables. Available when `execution_options.type` is `Multi-Configuration`.
        """
elif False:
    BuildDefinitionJobTargetExecutionOptionsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class BuildDefinitionJobTargetExecutionOptionsArgs:
    def __init__(__self__, *,
                 type: pulumi.Input[str],
                 continue_on_error: Optional[pulumi.Input[bool]] = None,
                 max_concurrency: Optional[pulumi.Input[int]] = None,
                 multipliers: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] type: The execution type of the Job. Possible values are: `None`, `Multi-Configuration`, `Multi-Agent`.
        :param pulumi.Input[bool] continue_on_error: Whether to continue the job when an error occurs. Possible values are: `true`, `false`.
        :param pulumi.Input[int] max_concurrency: Limit the number of agents to be used. If job type is `AgentlessJob`, the concurrency is not configurable and is fixed to 50.
        :param pulumi.Input[str] multipliers: A list of comma separated configuration variables to use. These are defined on the Variables tab. For example, OperatingSystem, Browser will run the tasks for both variables. Available when `execution_options.type` is `Multi-Configuration`.
        """
        pulumi.set(__self__, "type", type)
        if continue_on_error is not None:
            pulumi.set(__self__, "continue_on_error", continue_on_error)
        if max_concurrency is not None:
            pulumi.set(__self__, "max_concurrency", max_concurrency)
        if multipliers is not None:
            pulumi.set(__self__, "multipliers", multipliers)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[str]:
        """
        The execution type of the Job. Possible values are: `None`, `Multi-Configuration`, `Multi-Agent`.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[str]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter(name="continueOnError")
    def continue_on_error(self) -> Optional[pulumi.Input[bool]]:
        """
        Whether to continue the job when an error occurs. Possible values are: `true`, `false`.
        """
        return pulumi.get(self, "continue_on_error")

    @continue_on_error.setter
    def continue_on_error(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "continue_on_error", value)

    @property
    @pulumi.getter(name="maxConcurrency")
    def max_concurrency(self) -> Optional[pulumi.Input[int]]:
        """
        Limit the number of agents to be used. If job type is `AgentlessJob`, the concurrency is not configurable and is fixed to 50.
        """
        return pulumi.get(self, "max_concurrency")

    @max_concurrency.setter
    def max_concurrency(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "max_concurrency", value)

    @property
    @pulumi.getter
    def multipliers(self) -> Optional[pulumi.Input[str]]:
        """
        A list of comma separated configuration variables to use. These are defined on the Variables tab. For example, OperatingSystem, Browser will run the tasks for both variables. Available when `execution_options.type` is `Multi-Configuration`.
        """
        return pulumi.get(self, "multipliers")

    @multipliers.setter
    def multipliers(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "multipliers", value)


if not MYPY:
    class BuildDefinitionPullRequestTriggerArgsDict(TypedDict):
        forks: pulumi.Input['BuildDefinitionPullRequestTriggerForksArgsDict']
        """
        Set permissions for Forked repositories.
        """
        comment_required: NotRequired[pulumi.Input[str]]
        initial_branch: NotRequired[pulumi.Input[str]]
        override: NotRequired[pulumi.Input['BuildDefinitionPullRequestTriggerOverrideArgsDict']]
        """
        Override the azure-pipeline file and use this configuration for all builds.
        """
        use_yaml: NotRequired[pulumi.Input[bool]]
        """
        Use the azure-pipeline file for the build configuration. Defaults to `false`.
        """
elif False:
    BuildDefinitionPullRequestTriggerArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class BuildDefinitionPullRequestTriggerArgs:
    def __init__(__self__, *,
                 forks: pulumi.Input['BuildDefinitionPullRequestTriggerForksArgs'],
                 comment_required: Optional[pulumi.Input[str]] = None,
                 initial_branch: Optional[pulumi.Input[str]] = None,
                 override: Optional[pulumi.Input['BuildDefinitionPullRequestTriggerOverrideArgs']] = None,
                 use_yaml: Optional[pulumi.Input[bool]] = None):
        """
        :param pulumi.Input['BuildDefinitionPullRequestTriggerForksArgs'] forks: Set permissions for Forked repositories.
        :param pulumi.Input['BuildDefinitionPullRequestTriggerOverrideArgs'] override: Override the azure-pipeline file and use this configuration for all builds.
        :param pulumi.Input[bool] use_yaml: Use the azure-pipeline file for the build configuration. Defaults to `false`.
        """
        pulumi.set(__self__, "forks", forks)
        if comment_required is not None:
            pulumi.set(__self__, "comment_required", comment_required)
        if initial_branch is not None:
            pulumi.set(__self__, "initial_branch", initial_branch)
        if override is not None:
            pulumi.set(__self__, "override", override)
        if use_yaml is not None:
            pulumi.set(__self__, "use_yaml", use_yaml)

    @property
    @pulumi.getter
    def forks(self) -> pulumi.Input['BuildDefinitionPullRequestTriggerForksArgs']:
        """
        Set permissions for Forked repositories.
        """
        return pulumi.get(self, "forks")

    @forks.setter
    def forks(self, value: pulumi.Input['BuildDefinitionPullRequestTriggerForksArgs']):
        pulumi.set(self, "forks", value)

    @property
    @pulumi.getter(name="commentRequired")
    def comment_required(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "comment_required")

    @comment_required.setter
    def comment_required(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "comment_required", value)

    @property
    @pulumi.getter(name="initialBranch")
    def initial_branch(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "initial_branch")

    @initial_branch.setter
    def initial_branch(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "initial_branch", value)

    @property
    @pulumi.getter
    def override(self) -> Optional[pulumi.Input['BuildDefinitionPullRequestTriggerOverrideArgs']]:
        """
        Override the azure-pipeline file and use this configuration for all builds.
        """
        return pulumi.get(self, "override")

    @override.setter
    def override(self, value: Optional[pulumi.Input['BuildDefinitionPullRequestTriggerOverrideArgs']]):
        pulumi.set(self, "override", value)

    @property
    @pulumi.getter(name="useYaml")
    def use_yaml(self) -> Optional[pulumi.Input[bool]]:
        """
        Use the azure-pipeline file for the build configuration. Defaults to `false`.
        """
        return pulumi.get(self, "use_yaml")

    @use_yaml.setter
    def use_yaml(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "use_yaml", value)


if not MYPY:
    class BuildDefinitionPullRequestTriggerForksArgsDict(TypedDict):
        enabled: pulumi.Input[bool]
        """
        Build pull requests from forks of this repository.
        """
        share_secrets: pulumi.Input[bool]
        """
        Make secrets available to builds of forks.
        """
elif False:
    BuildDefinitionPullRequestTriggerForksArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class BuildDefinitionPullRequestTriggerForksArgs:
    def __init__(__self__, *,
                 enabled: pulumi.Input[bool],
                 share_secrets: pulumi.Input[bool]):
        """
        :param pulumi.Input[bool] enabled: Build pull requests from forks of this repository.
        :param pulumi.Input[bool] share_secrets: Make secrets available to builds of forks.
        """
        pulumi.set(__self__, "enabled", enabled)
        pulumi.set(__self__, "share_secrets", share_secrets)

    @property
    @pulumi.getter
    def enabled(self) -> pulumi.Input[bool]:
        """
        Build pull requests from forks of this repository.
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: pulumi.Input[bool]):
        pulumi.set(self, "enabled", value)

    @property
    @pulumi.getter(name="shareSecrets")
    def share_secrets(self) -> pulumi.Input[bool]:
        """
        Make secrets available to builds of forks.
        """
        return pulumi.get(self, "share_secrets")

    @share_secrets.setter
    def share_secrets(self, value: pulumi.Input[bool]):
        pulumi.set(self, "share_secrets", value)


if not MYPY:
    class BuildDefinitionPullRequestTriggerOverrideArgsDict(TypedDict):
        branch_filters: pulumi.Input[Sequence[pulumi.Input['BuildDefinitionPullRequestTriggerOverrideBranchFilterArgsDict']]]
        """
        The branches to include and exclude from the trigger. A `branch_filter` block as documented below.
        """
        auto_cancel: NotRequired[pulumi.Input[bool]]
        """
        . Defaults to `true`.
        """
        path_filters: NotRequired[pulumi.Input[Sequence[pulumi.Input['BuildDefinitionPullRequestTriggerOverridePathFilterArgsDict']]]]
        """
        Specify file paths to include or exclude. Note that the wildcard syntax is different between branches/tags and file paths.
        """
elif False:
    BuildDefinitionPullRequestTriggerOverrideArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class BuildDefinitionPullRequestTriggerOverrideArgs:
    def __init__(__self__, *,
                 branch_filters: pulumi.Input[Sequence[pulumi.Input['BuildDefinitionPullRequestTriggerOverrideBranchFilterArgs']]],
                 auto_cancel: Optional[pulumi.Input[bool]] = None,
                 path_filters: Optional[pulumi.Input[Sequence[pulumi.Input['BuildDefinitionPullRequestTriggerOverridePathFilterArgs']]]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input['BuildDefinitionPullRequestTriggerOverrideBranchFilterArgs']]] branch_filters: The branches to include and exclude from the trigger. A `branch_filter` block as documented below.
        :param pulumi.Input[bool] auto_cancel: . Defaults to `true`.
        :param pulumi.Input[Sequence[pulumi.Input['BuildDefinitionPullRequestTriggerOverridePathFilterArgs']]] path_filters: Specify file paths to include or exclude. Note that the wildcard syntax is different between branches/tags and file paths.
        """
        pulumi.set(__self__, "branch_filters", branch_filters)
        if auto_cancel is not None:
            pulumi.set(__self__, "auto_cancel", auto_cancel)
        if path_filters is not None:
            pulumi.set(__self__, "path_filters", path_filters)

    @property
    @pulumi.getter(name="branchFilters")
    def branch_filters(self) -> pulumi.Input[Sequence[pulumi.Input['BuildDefinitionPullRequestTriggerOverrideBranchFilterArgs']]]:
        """
        The branches to include and exclude from the trigger. A `branch_filter` block as documented below.
        """
        return pulumi.get(self, "branch_filters")

    @branch_filters.setter
    def branch_filters(self, value: pulumi.Input[Sequence[pulumi.Input['BuildDefinitionPullRequestTriggerOverrideBranchFilterArgs']]]):
        pulumi.set(self, "branch_filters", value)

    @property
    @pulumi.getter(name="autoCancel")
    def auto_cancel(self) -> Optional[pulumi.Input[bool]]:
        """
        . Defaults to `true`.
        """
        return pulumi.get(self, "auto_cancel")

    @auto_cancel.setter
    def auto_cancel(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "auto_cancel", value)

    @property
    @pulumi.getter(name="pathFilters")
    def path_filters(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['BuildDefinitionPullRequestTriggerOverridePathFilterArgs']]]]:
        """
        Specify file paths to include or exclude. Note that the wildcard syntax is different between branches/tags and file paths.
        """
        return pulumi.get(self, "path_filters")

    @path_filters.setter
    def path_filters(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['BuildDefinitionPullRequestTriggerOverridePathFilterArgs']]]]):
        pulumi.set(self, "path_filters", value)


if not MYPY:
    class BuildDefinitionPullRequestTriggerOverrideBranchFilterArgsDict(TypedDict):
        excludes: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        List of branch patterns to exclude.
        """
        includes: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        List of branch patterns to include.
        """
elif False:
    BuildDefinitionPullRequestTriggerOverrideBranchFilterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class BuildDefinitionPullRequestTriggerOverrideBranchFilterArgs:
    def __init__(__self__, *,
                 excludes: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 includes: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input[str]]] excludes: List of branch patterns to exclude.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] includes: List of branch patterns to include.
        """
        if excludes is not None:
            pulumi.set(__self__, "excludes", excludes)
        if includes is not None:
            pulumi.set(__self__, "includes", includes)

    @property
    @pulumi.getter
    def excludes(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        List of branch patterns to exclude.
        """
        return pulumi.get(self, "excludes")

    @excludes.setter
    def excludes(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "excludes", value)

    @property
    @pulumi.getter
    def includes(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        List of branch patterns to include.
        """
        return pulumi.get(self, "includes")

    @includes.setter
    def includes(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "includes", value)


if not MYPY:
    class BuildDefinitionPullRequestTriggerOverridePathFilterArgsDict(TypedDict):
        excludes: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        List of path patterns to exclude.
        """
        includes: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        List of path patterns to include.
        """
elif False:
    BuildDefinitionPullRequestTriggerOverridePathFilterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class BuildDefinitionPullRequestTriggerOverridePathFilterArgs:
    def __init__(__self__, *,
                 excludes: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 includes: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input[str]]] excludes: List of path patterns to exclude.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] includes: List of path patterns to include.
        """
        if excludes is not None:
            pulumi.set(__self__, "excludes", excludes)
        if includes is not None:
            pulumi.set(__self__, "includes", includes)

    @property
    @pulumi.getter
    def excludes(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        List of path patterns to exclude.
        """
        return pulumi.get(self, "excludes")

    @excludes.setter
    def excludes(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "excludes", value)

    @property
    @pulumi.getter
    def includes(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        List of path patterns to include.
        """
        return pulumi.get(self, "includes")

    @includes.setter
    def includes(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "includes", value)


if not MYPY:
    class BuildDefinitionRepositoryArgsDict(TypedDict):
        repo_id: pulumi.Input[str]
        """
        The id of the repository. For `TfsGit` repos, this is simply the ID of the repository. For `Github` repos, this will take the form of `<GitHub Org>/<Repo Name>`. For `Bitbucket` repos, this will take the form of `<Workspace ID>/<Repo Name>`.
        """
        repo_type: pulumi.Input[str]
        """
        The repository type. Possible values are: `GitHub` or `TfsGit` or `Bitbucket` or `GitHub Enterprise` or `Git`. Defaults to `GitHub`. If `repo_type` is `GitHubEnterprise`, must use existing project and GitHub Enterprise service connection.
        """
        branch_name: NotRequired[pulumi.Input[str]]
        """
        The branch name for which builds are triggered. Defaults to `master`.
        """
        github_enterprise_url: NotRequired[pulumi.Input[str]]
        """
        The Github Enterprise URL. Used if `repo_type` is `GithubEnterprise`. Conflict with `url`
        """
        report_build_status: NotRequired[pulumi.Input[bool]]
        """
        Report build status. Default is true.
        """
        service_connection_id: NotRequired[pulumi.Input[str]]
        """
        The service connection ID. Used if the `repo_type` is `GitHub` or `GitHubEnterprise`.
        """
        url: NotRequired[pulumi.Input[str]]
        """
        The URL of the Git repository. Used if `repo_type` is `Git`. Conflict with `github_enterprise_url`
        """
        yml_path: NotRequired[pulumi.Input[str]]
        """
        The path of the Yaml file describing the build definition.
        """
elif False:
    BuildDefinitionRepositoryArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class BuildDefinitionRepositoryArgs:
    def __init__(__self__, *,
                 repo_id: pulumi.Input[str],
                 repo_type: pulumi.Input[str],
                 branch_name: Optional[pulumi.Input[str]] = None,
                 github_enterprise_url: Optional[pulumi.Input[str]] = None,
                 report_build_status: Optional[pulumi.Input[bool]] = None,
                 service_connection_id: Optional[pulumi.Input[str]] = None,
                 url: Optional[pulumi.Input[str]] = None,
                 yml_path: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] repo_id: The id of the repository. For `TfsGit` repos, this is simply the ID of the repository. For `Github` repos, this will take the form of `<GitHub Org>/<Repo Name>`. For `Bitbucket` repos, this will take the form of `<Workspace ID>/<Repo Name>`.
        :param pulumi.Input[str] repo_type: The repository type. Possible values are: `GitHub` or `TfsGit` or `Bitbucket` or `GitHub Enterprise` or `Git`. Defaults to `GitHub`. If `repo_type` is `GitHubEnterprise`, must use existing project and GitHub Enterprise service connection.
        :param pulumi.Input[str] branch_name: The branch name for which builds are triggered. Defaults to `master`.
        :param pulumi.Input[str] github_enterprise_url: The Github Enterprise URL. Used if `repo_type` is `GithubEnterprise`. Conflict with `url`
        :param pulumi.Input[bool] report_build_status: Report build status. Default is true.
        :param pulumi.Input[str] service_connection_id: The service connection ID. Used if the `repo_type` is `GitHub` or `GitHubEnterprise`.
        :param pulumi.Input[str] url: The URL of the Git repository. Used if `repo_type` is `Git`. Conflict with `github_enterprise_url`
        :param pulumi.Input[str] yml_path: The path of the Yaml file describing the build definition.
        """
        pulumi.set(__self__, "repo_id", repo_id)
        pulumi.set(__self__, "repo_type", repo_type)
        if branch_name is not None:
            pulumi.set(__self__, "branch_name", branch_name)
        if github_enterprise_url is not None:
            pulumi.set(__self__, "github_enterprise_url", github_enterprise_url)
        if report_build_status is not None:
            pulumi.set(__self__, "report_build_status", report_build_status)
        if service_connection_id is not None:
            pulumi.set(__self__, "service_connection_id", service_connection_id)
        if url is not None:
            pulumi.set(__self__, "url", url)
        if yml_path is not None:
            pulumi.set(__self__, "yml_path", yml_path)

    @property
    @pulumi.getter(name="repoId")
    def repo_id(self) -> pulumi.Input[str]:
        """
        The id of the repository. For `TfsGit` repos, this is simply the ID of the repository. For `Github` repos, this will take the form of `<GitHub Org>/<Repo Name>`. For `Bitbucket` repos, this will take the form of `<Workspace ID>/<Repo Name>`.
        """
        return pulumi.get(self, "repo_id")

    @repo_id.setter
    def repo_id(self, value: pulumi.Input[str]):
        pulumi.set(self, "repo_id", value)

    @property
    @pulumi.getter(name="repoType")
    def repo_type(self) -> pulumi.Input[str]:
        """
        The repository type. Possible values are: `GitHub` or `TfsGit` or `Bitbucket` or `GitHub Enterprise` or `Git`. Defaults to `GitHub`. If `repo_type` is `GitHubEnterprise`, must use existing project and GitHub Enterprise service connection.
        """
        return pulumi.get(self, "repo_type")

    @repo_type.setter
    def repo_type(self, value: pulumi.Input[str]):
        pulumi.set(self, "repo_type", value)

    @property
    @pulumi.getter(name="branchName")
    def branch_name(self) -> Optional[pulumi.Input[str]]:
        """
        The branch name for which builds are triggered. Defaults to `master`.
        """
        return pulumi.get(self, "branch_name")

    @branch_name.setter
    def branch_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "branch_name", value)

    @property
    @pulumi.getter(name="githubEnterpriseUrl")
    def github_enterprise_url(self) -> Optional[pulumi.Input[str]]:
        """
        The Github Enterprise URL. Used if `repo_type` is `GithubEnterprise`. Conflict with `url`
        """
        return pulumi.get(self, "github_enterprise_url")

    @github_enterprise_url.setter
    def github_enterprise_url(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "github_enterprise_url", value)

    @property
    @pulumi.getter(name="reportBuildStatus")
    def report_build_status(self) -> Optional[pulumi.Input[bool]]:
        """
        Report build status. Default is true.
        """
        return pulumi.get(self, "report_build_status")

    @report_build_status.setter
    def report_build_status(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "report_build_status", value)

    @property
    @pulumi.getter(name="serviceConnectionId")
    def service_connection_id(self) -> Optional[pulumi.Input[str]]:
        """
        The service connection ID. Used if the `repo_type` is `GitHub` or `GitHubEnterprise`.
        """
        return pulumi.get(self, "service_connection_id")

    @service_connection_id.setter
    def service_connection_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "service_connection_id", value)

    @property
    @pulumi.getter
    def url(self) -> Optional[pulumi.Input[str]]:
        """
        The URL of the Git repository. Used if `repo_type` is `Git`. Conflict with `github_enterprise_url`
        """
        return pulumi.get(self, "url")

    @url.setter
    def url(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "url", value)

    @property
    @pulumi.getter(name="ymlPath")
    def yml_path(self) -> Optional[pulumi.Input[str]]:
        """
        The path of the Yaml file describing the build definition.
        """
        return pulumi.get(self, "yml_path")

    @yml_path.setter
    def yml_path(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "yml_path", value)


if not MYPY:
    class BuildDefinitionScheduleArgsDict(TypedDict):
        branch_filters: pulumi.Input[Sequence[pulumi.Input['BuildDefinitionScheduleBranchFilterArgsDict']]]
        """
        A `branch_filter` block as defined below.
        """
        days_to_builds: pulumi.Input[Sequence[pulumi.Input[str]]]
        """
        When to build. Possible values are: `Mon`, `Tue`, `Wed`, `Thu`, `Fri`, `Sat`, `Sun`.
        """
        schedule_job_id: NotRequired[pulumi.Input[str]]
        """
        The ID of the schedule job
        """
        schedule_only_with_changes: NotRequired[pulumi.Input[bool]]
        """
        Schedule builds if the source or pipeline has changed. Defaults to `true`.
        """
        start_hours: NotRequired[pulumi.Input[int]]
        """
        Build start hour. Possible values are: `0 ~ 23`. Defaults to `0`.
        """
        start_minutes: NotRequired[pulumi.Input[int]]
        """
        Build start minute. Possible values are: `0 ~ 59`. Defaults to `0`.
        """
        time_zone: NotRequired[pulumi.Input[str]]
        """
        Build time zone. Defaults to `(UTC) Coordinated Universal Time`. Possible values are:
        `(UTC-12:00) International Date Line West`,
        `(UTC-11:00) Coordinated Universal Time-11`,
        `(UTC-10:00) Aleutian Islands`,
        `(UTC-10:00) Hawaii`,
        `(UTC-09:30) Marquesas Islands`,
        `(UTC-09:00) Alaska`,
        `(UTC-09:00) Coordinated Universal Time-09`,
        `(UTC-08:00) Baja California`,
        `(UTC-08:00) Coordinated Universal Time-08`,
        `(UTC-08:00) Pacific Time (US &Canada)`,
        `(UTC-07:00) Arizona`,
        `(UTC-07:00) Chihuahua, La Paz, Mazatlan`,
        `(UTC-07:00) Mountain Time (US &Canada)`,
        `(UTC-07:00) Yukon`,
        `(UTC-06:00) Central America`,
        `(UTC-06:00) Central Time (US &Canada)`,
        `(UTC-06:00) Easter Island`,
        `(UTC-06:00) Guadalajara, Mexico City, Monterrey`,
        `(UTC-06:00) Saskatchewan`,
        `(UTC-05:00) Bogota, Lima, Quito, Rio Branco`,
        `(UTC-05:00) Chetumal`,
        `(UTC-05:00) Eastern Time (US &Canada)`,
        `(UTC-05:00) Haiti`,
        `(UTC-05:00) Havana`,
        `(UTC-05:00) Indiana (East)`,
        `(UTC-05:00) Turks and Caicos`,
        `(UTC-04:00) Asuncion`,
        `(UTC-04:00) Atlantic Time (Canada)`,
        `(UTC-04:00) Caracas`,
        `(UTC-04:00) Cuiaba`,
        `(UTC-04:00) Georgetown, La Paz, Manaus, San Juan`,
        `(UTC-04:00) Santiago`,
        `(UTC-03:30) Newfoundland`,
        `(UTC-03:00) Araguaina`,
        `(UTC-03:00) Brasilia`,
        `(UTC-03:00) Cayenne, Fortaleza`,
        `(UTC-03:00) City of Buenos Aires`,
        `(UTC-03:00) Greenland`,
        `(UTC-03:00) Montevideo`,
        `(UTC-03:00) Punta Arenas`,
        `(UTC-03:00) Saint Pierre and Miquelon`,
        `(UTC-03:00) Salvador`,
        `(UTC-02:00) Coordinated Universal Time-02`,
        `(UTC-02:00) Mid-Atlantic - Old`,
        `(UTC-01:00) Azores`,
        `(UTC-01:00) Cabo Verde Is.`,
        `(UTC) Coordinated Universal Time`,
        `(UTC+00:00) Dublin, Edinburgh, Lisbon, London`,
        `(UTC+00:00) Monrovia, Reykjavik`,
        `(UTC+00:00) Sao Tome`,
        `(UTC+01:00) Casablanca`,
        `(UTC+01:00) Amsterdam, Berlin, Bern, Rome, Stockholm, Vienna`,
        `(UTC+01:00) Belgrade, Bratislava, Budapest, Ljubljana, Prague`,
        `(UTC+01:00) Brussels, Copenhagen, Madrid, Paris`,
        `(UTC+01:00) Sarajevo, Skopje, Warsaw, Zagreb`,
        `(UTC+01:00) West Central Africa`,
        `(UTC+02:00) Amman`,
        `(UTC+02:00) Athens, Bucharest`,
        `(UTC+02:00) Beirut`,
        `(UTC+02:00) Cairo`,
        `(UTC+02:00) Chisinau`,
        `(UTC+02:00) Damascus`,
        `(UTC+02:00) Gaza, Hebron`,
        `(UTC+02:00) Harare, Pretoria`,
        `(UTC+02:00) Helsinki, Kyiv, Riga, Sofia, Tallinn, Vilnius`,
        `(UTC+02:00) Jerusalem`,
        `(UTC+02:00) Juba`,
        `(UTC+02:00) Kaliningrad`,
        `(UTC+02:00) Khartoum`,
        `(UTC+02:00) Tripoli`,
        `(UTC+02:00) Windhoek`,
        `(UTC+03:00) Baghdad`,
        `(UTC+03:00) Istanbul`,
        `(UTC+03:00) Kuwait, Riyadh`,
        `(UTC+03:00) Minsk`,
        `(UTC+03:00) Moscow, St. Petersburg`,
        `(UTC+03:00) Nairobi`,
        `(UTC+03:00) Volgograd`,
        `(UTC+03:30) Tehran`,
        `(UTC+04:00) Abu Dhabi, Muscat`,
        `(UTC+04:00) Astrakhan, Ulyanovsk`,
        `(UTC+04:00) Baku`,
        `(UTC+04:00) Izhevsk, Samara`,
        `(UTC+04:00) Port Louis`,
        `(UTC+04:00) Saratov`,
        `(UTC+04:00) Tbilisi`,
        `(UTC+04:00) Yerevan`,
        `(UTC+04:30) Kabul`,
        `(UTC+05:00) Ashgabat, Tashkent`,
        `(UTC+05:00) Ekaterinburg`,
        `(UTC+05:00) Islamabad, Karachi`,
        `(UTC+05:00) Qyzylorda`,
        `(UTC+05:30) Chennai, Kolkata, Mumbai, New Delhi`,
        `(UTC+05:30) Sri Jayawardenepura`,
        `(UTC+05:45) Kathmandu`,
        `(UTC+06:00) Astana`,
        `(UTC+06:00) Dhaka`,
        `(UTC+06:00) Omsk`,
        `(UTC+06:30) Yangon (Rangoon)`,
        `(UTC+07:00) Bangkok, Hanoi, Jakarta`,
        `(UTC+07:00) Barnaul, Gorno-Altaysk`,
        `(UTC+07:00) Hovd`,
        `(UTC+07:00) Krasnoyarsk`,
        `(UTC+07:00) Novosibirsk`,
        `(UTC+07:00) Tomsk`,
        `(UTC+08:00) Beijing, Chongqing, Hong Kong, Urumqi`,
        `(UTC+08:00) Irkutsk`,
        `(UTC+08:00) Kuala Lumpur, Singapore`,
        `(UTC+08:00) Perth`,
        `(UTC+08:00) Taipei`,
        `(UTC+08:00) Ulaanbaatar`,
        `(UTC+08:45) Eucla`,
        `(UTC+09:00) Chita`,
        `(UTC+09:00) Osaka, Sapporo, Tokyo`,
        `(UTC+09:00) Pyongyang`,
        `(UTC+09:00) Seoul`,
        `(UTC+09:00) Yakutsk`,
        `(UTC+09:30) Adelaide`,
        `(UTC+09:30) Darwin`,
        `(UTC+10:00) Brisbane`,
        `(UTC+10:00) Canberra, Melbourne, Sydney`,
        `(UTC+10:00) Guam, Port Moresby`,
        `(UTC+10:00) Hobart`,
        `(UTC+10:00) Vladivostok`,
        `(UTC+10:30) Lord Howe Island`,
        `(UTC+11:00) Bougainville Island`,
        `(UTC+11:00) Chokurdakh`,
        `(UTC+11:00) Magadan`,
        `(UTC+11:00) Norfolk Island`,
        `(UTC+11:00) Sakhalin`,
        `(UTC+11:00) Solomon Is., New Caledonia`,
        `(UTC+12:00) Anadyr, Petropavlovsk-Kamchatsky`,
        `(UTC+12:00) Auckland, Wellington`,
        `(UTC+12:00) Coordinated Universal Time+12`,
        `(UTC+12:00) Fiji`,
        `(UTC+12:00) Petropavlovsk-Kamchatsky - Old`,
        `(UTC+12:45) Chatham Islands`,
        `(UTC+13:00) Coordinated Universal Time+13`,
        `(UTC+13:00) Nuku'alofa`,
        `(UTC+13:00) Samoa`,
        `(UTC+14:00) Kiritimati Island`.
        """
elif False:
    BuildDefinitionScheduleArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class BuildDefinitionScheduleArgs:
    def __init__(__self__, *,
                 branch_filters: pulumi.Input[Sequence[pulumi.Input['BuildDefinitionScheduleBranchFilterArgs']]],
                 days_to_builds: pulumi.Input[Sequence[pulumi.Input[str]]],
                 schedule_job_id: Optional[pulumi.Input[str]] = None,
                 schedule_only_with_changes: Optional[pulumi.Input[bool]] = None,
                 start_hours: Optional[pulumi.Input[int]] = None,
                 start_minutes: Optional[pulumi.Input[int]] = None,
                 time_zone: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input['BuildDefinitionScheduleBranchFilterArgs']]] branch_filters: A `branch_filter` block as defined below.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] days_to_builds: When to build. Possible values are: `Mon`, `Tue`, `Wed`, `Thu`, `Fri`, `Sat`, `Sun`.
        :param pulumi.Input[str] schedule_job_id: The ID of the schedule job
        :param pulumi.Input[bool] schedule_only_with_changes: Schedule builds if the source or pipeline has changed. Defaults to `true`.
        :param pulumi.Input[int] start_hours: Build start hour. Possible values are: `0 ~ 23`. Defaults to `0`.
        :param pulumi.Input[int] start_minutes: Build start minute. Possible values are: `0 ~ 59`. Defaults to `0`.
        :param pulumi.Input[str] time_zone: Build time zone. Defaults to `(UTC) Coordinated Universal Time`. Possible values are:
               `(UTC-12:00) International Date Line West`,
               `(UTC-11:00) Coordinated Universal Time-11`,
               `(UTC-10:00) Aleutian Islands`,
               `(UTC-10:00) Hawaii`,
               `(UTC-09:30) Marquesas Islands`,
               `(UTC-09:00) Alaska`,
               `(UTC-09:00) Coordinated Universal Time-09`,
               `(UTC-08:00) Baja California`,
               `(UTC-08:00) Coordinated Universal Time-08`,
               `(UTC-08:00) Pacific Time (US &Canada)`,
               `(UTC-07:00) Arizona`,
               `(UTC-07:00) Chihuahua, La Paz, Mazatlan`,
               `(UTC-07:00) Mountain Time (US &Canada)`,
               `(UTC-07:00) Yukon`,
               `(UTC-06:00) Central America`,
               `(UTC-06:00) Central Time (US &Canada)`,
               `(UTC-06:00) Easter Island`,
               `(UTC-06:00) Guadalajara, Mexico City, Monterrey`,
               `(UTC-06:00) Saskatchewan`,
               `(UTC-05:00) Bogota, Lima, Quito, Rio Branco`,
               `(UTC-05:00) Chetumal`,
               `(UTC-05:00) Eastern Time (US &Canada)`,
               `(UTC-05:00) Haiti`,
               `(UTC-05:00) Havana`,
               `(UTC-05:00) Indiana (East)`,
               `(UTC-05:00) Turks and Caicos`,
               `(UTC-04:00) Asuncion`,
               `(UTC-04:00) Atlantic Time (Canada)`,
               `(UTC-04:00) Caracas`,
               `(UTC-04:00) Cuiaba`,
               `(UTC-04:00) Georgetown, La Paz, Manaus, San Juan`,
               `(UTC-04:00) Santiago`,
               `(UTC-03:30) Newfoundland`,
               `(UTC-03:00) Araguaina`,
               `(UTC-03:00) Brasilia`,
               `(UTC-03:00) Cayenne, Fortaleza`,
               `(UTC-03:00) City of Buenos Aires`,
               `(UTC-03:00) Greenland`,
               `(UTC-03:00) Montevideo`,
               `(UTC-03:00) Punta Arenas`,
               `(UTC-03:00) Saint Pierre and Miquelon`,
               `(UTC-03:00) Salvador`,
               `(UTC-02:00) Coordinated Universal Time-02`,
               `(UTC-02:00) Mid-Atlantic - Old`,
               `(UTC-01:00) Azores`,
               `(UTC-01:00) Cabo Verde Is.`,
               `(UTC) Coordinated Universal Time`,
               `(UTC+00:00) Dublin, Edinburgh, Lisbon, London`,
               `(UTC+00:00) Monrovia, Reykjavik`,
               `(UTC+00:00) Sao Tome`,
               `(UTC+01:00) Casablanca`,
               `(UTC+01:00) Amsterdam, Berlin, Bern, Rome, Stockholm, Vienna`,
               `(UTC+01:00) Belgrade, Bratislava, Budapest, Ljubljana, Prague`,
               `(UTC+01:00) Brussels, Copenhagen, Madrid, Paris`,
               `(UTC+01:00) Sarajevo, Skopje, Warsaw, Zagreb`,
               `(UTC+01:00) West Central Africa`,
               `(UTC+02:00) Amman`,
               `(UTC+02:00) Athens, Bucharest`,
               `(UTC+02:00) Beirut`,
               `(UTC+02:00) Cairo`,
               `(UTC+02:00) Chisinau`,
               `(UTC+02:00) Damascus`,
               `(UTC+02:00) Gaza, Hebron`,
               `(UTC+02:00) Harare, Pretoria`,
               `(UTC+02:00) Helsinki, Kyiv, Riga, Sofia, Tallinn, Vilnius`,
               `(UTC+02:00) Jerusalem`,
               `(UTC+02:00) Juba`,
               `(UTC+02:00) Kaliningrad`,
               `(UTC+02:00) Khartoum`,
               `(UTC+02:00) Tripoli`,
               `(UTC+02:00) Windhoek`,
               `(UTC+03:00) Baghdad`,
               `(UTC+03:00) Istanbul`,
               `(UTC+03:00) Kuwait, Riyadh`,
               `(UTC+03:00) Minsk`,
               `(UTC+03:00) Moscow, St. Petersburg`,
               `(UTC+03:00) Nairobi`,
               `(UTC+03:00) Volgograd`,
               `(UTC+03:30) Tehran`,
               `(UTC+04:00) Abu Dhabi, Muscat`,
               `(UTC+04:00) Astrakhan, Ulyanovsk`,
               `(UTC+04:00) Baku`,
               `(UTC+04:00) Izhevsk, Samara`,
               `(UTC+04:00) Port Louis`,
               `(UTC+04:00) Saratov`,
               `(UTC+04:00) Tbilisi`,
               `(UTC+04:00) Yerevan`,
               `(UTC+04:30) Kabul`,
               `(UTC+05:00) Ashgabat, Tashkent`,
               `(UTC+05:00) Ekaterinburg`,
               `(UTC+05:00) Islamabad, Karachi`,
               `(UTC+05:00) Qyzylorda`,
               `(UTC+05:30) Chennai, Kolkata, Mumbai, New Delhi`,
               `(UTC+05:30) Sri Jayawardenepura`,
               `(UTC+05:45) Kathmandu`,
               `(UTC+06:00) Astana`,
               `(UTC+06:00) Dhaka`,
               `(UTC+06:00) Omsk`,
               `(UTC+06:30) Yangon (Rangoon)`,
               `(UTC+07:00) Bangkok, Hanoi, Jakarta`,
               `(UTC+07:00) Barnaul, Gorno-Altaysk`,
               `(UTC+07:00) Hovd`,
               `(UTC+07:00) Krasnoyarsk`,
               `(UTC+07:00) Novosibirsk`,
               `(UTC+07:00) Tomsk`,
               `(UTC+08:00) Beijing, Chongqing, Hong Kong, Urumqi`,
               `(UTC+08:00) Irkutsk`,
               `(UTC+08:00) Kuala Lumpur, Singapore`,
               `(UTC+08:00) Perth`,
               `(UTC+08:00) Taipei`,
               `(UTC+08:00) Ulaanbaatar`,
               `(UTC+08:45) Eucla`,
               `(UTC+09:00) Chita`,
               `(UTC+09:00) Osaka, Sapporo, Tokyo`,
               `(UTC+09:00) Pyongyang`,
               `(UTC+09:00) Seoul`,
               `(UTC+09:00) Yakutsk`,
               `(UTC+09:30) Adelaide`,
               `(UTC+09:30) Darwin`,
               `(UTC+10:00) Brisbane`,
               `(UTC+10:00) Canberra, Melbourne, Sydney`,
               `(UTC+10:00) Guam, Port Moresby`,
               `(UTC+10:00) Hobart`,
               `(UTC+10:00) Vladivostok`,
               `(UTC+10:30) Lord Howe Island`,
               `(UTC+11:00) Bougainville Island`,
               `(UTC+11:00) Chokurdakh`,
               `(UTC+11:00) Magadan`,
               `(UTC+11:00) Norfolk Island`,
               `(UTC+11:00) Sakhalin`,
               `(UTC+11:00) Solomon Is., New Caledonia`,
               `(UTC+12:00) Anadyr, Petropavlovsk-Kamchatsky`,
               `(UTC+12:00) Auckland, Wellington`,
               `(UTC+12:00) Coordinated Universal Time+12`,
               `(UTC+12:00) Fiji`,
               `(UTC+12:00) Petropavlovsk-Kamchatsky - Old`,
               `(UTC+12:45) Chatham Islands`,
               `(UTC+13:00) Coordinated Universal Time+13`,
               `(UTC+13:00) Nuku'alofa`,
               `(UTC+13:00) Samoa`,
               `(UTC+14:00) Kiritimati Island`.
        """
        pulumi.set(__self__, "branch_filters", branch_filters)
        pulumi.set(__self__, "days_to_builds", days_to_builds)
        if schedule_job_id is not None:
            pulumi.set(__self__, "schedule_job_id", schedule_job_id)
        if schedule_only_with_changes is not None:
            pulumi.set(__self__, "schedule_only_with_changes", schedule_only_with_changes)
        if start_hours is not None:
            pulumi.set(__self__, "start_hours", start_hours)
        if start_minutes is not None:
            pulumi.set(__self__, "start_minutes", start_minutes)
        if time_zone is not None:
            pulumi.set(__self__, "time_zone", time_zone)

    @property
    @pulumi.getter(name="branchFilters")
    def branch_filters(self) -> pulumi.Input[Sequence[pulumi.Input['BuildDefinitionScheduleBranchFilterArgs']]]:
        """
        A `branch_filter` block as defined below.
        """
        return pulumi.get(self, "branch_filters")

    @branch_filters.setter
    def branch_filters(self, value: pulumi.Input[Sequence[pulumi.Input['BuildDefinitionScheduleBranchFilterArgs']]]):
        pulumi.set(self, "branch_filters", value)

    @property
    @pulumi.getter(name="daysToBuilds")
    def days_to_builds(self) -> pulumi.Input[Sequence[pulumi.Input[str]]]:
        """
        When to build. Possible values are: `Mon`, `Tue`, `Wed`, `Thu`, `Fri`, `Sat`, `Sun`.
        """
        return pulumi.get(self, "days_to_builds")

    @days_to_builds.setter
    def days_to_builds(self, value: pulumi.Input[Sequence[pulumi.Input[str]]]):
        pulumi.set(self, "days_to_builds", value)

    @property
    @pulumi.getter(name="scheduleJobId")
    def schedule_job_id(self) -> Optional[pulumi.Input[str]]:
        """
        The ID of the schedule job
        """
        return pulumi.get(self, "schedule_job_id")

    @schedule_job_id.setter
    def schedule_job_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "schedule_job_id", value)

    @property
    @pulumi.getter(name="scheduleOnlyWithChanges")
    def schedule_only_with_changes(self) -> Optional[pulumi.Input[bool]]:
        """
        Schedule builds if the source or pipeline has changed. Defaults to `true`.
        """
        return pulumi.get(self, "schedule_only_with_changes")

    @schedule_only_with_changes.setter
    def schedule_only_with_changes(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "schedule_only_with_changes", value)

    @property
    @pulumi.getter(name="startHours")
    def start_hours(self) -> Optional[pulumi.Input[int]]:
        """
        Build start hour. Possible values are: `0 ~ 23`. Defaults to `0`.
        """
        return pulumi.get(self, "start_hours")

    @start_hours.setter
    def start_hours(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "start_hours", value)

    @property
    @pulumi.getter(name="startMinutes")
    def start_minutes(self) -> Optional[pulumi.Input[int]]:
        """
        Build start minute. Possible values are: `0 ~ 59`. Defaults to `0`.
        """
        return pulumi.get(self, "start_minutes")

    @start_minutes.setter
    def start_minutes(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "start_minutes", value)

    @property
    @pulumi.getter(name="timeZone")
    def time_zone(self) -> Optional[pulumi.Input[str]]:
        """
        Build time zone. Defaults to `(UTC) Coordinated Universal Time`. Possible values are:
        `(UTC-12:00) International Date Line West`,
        `(UTC-11:00) Coordinated Universal Time-11`,
        `(UTC-10:00) Aleutian Islands`,
        `(UTC-10:00) Hawaii`,
        `(UTC-09:30) Marquesas Islands`,
        `(UTC-09:00) Alaska`,
        `(UTC-09:00) Coordinated Universal Time-09`,
        `(UTC-08:00) Baja California`,
        `(UTC-08:00) Coordinated Universal Time-08`,
        `(UTC-08:00) Pacific Time (US &Canada)`,
        `(UTC-07:00) Arizona`,
        `(UTC-07:00) Chihuahua, La Paz, Mazatlan`,
        `(UTC-07:00) Mountain Time (US &Canada)`,
        `(UTC-07:00) Yukon`,
        `(UTC-06:00) Central America`,
        `(UTC-06:00) Central Time (US &Canada)`,
        `(UTC-06:00) Easter Island`,
        `(UTC-06:00) Guadalajara, Mexico City, Monterrey`,
        `(UTC-06:00) Saskatchewan`,
        `(UTC-05:00) Bogota, Lima, Quito, Rio Branco`,
        `(UTC-05:00) Chetumal`,
        `(UTC-05:00) Eastern Time (US &Canada)`,
        `(UTC-05:00) Haiti`,
        `(UTC-05:00) Havana`,
        `(UTC-05:00) Indiana (East)`,
        `(UTC-05:00) Turks and Caicos`,
        `(UTC-04:00) Asuncion`,
        `(UTC-04:00) Atlantic Time (Canada)`,
        `(UTC-04:00) Caracas`,
        `(UTC-04:00) Cuiaba`,
        `(UTC-04:00) Georgetown, La Paz, Manaus, San Juan`,
        `(UTC-04:00) Santiago`,
        `(UTC-03:30) Newfoundland`,
        `(UTC-03:00) Araguaina`,
        `(UTC-03:00) Brasilia`,
        `(UTC-03:00) Cayenne, Fortaleza`,
        `(UTC-03:00) City of Buenos Aires`,
        `(UTC-03:00) Greenland`,
        `(UTC-03:00) Montevideo`,
        `(UTC-03:00) Punta Arenas`,
        `(UTC-03:00) Saint Pierre and Miquelon`,
        `(UTC-03:00) Salvador`,
        `(UTC-02:00) Coordinated Universal Time-02`,
        `(UTC-02:00) Mid-Atlantic - Old`,
        `(UTC-01:00) Azores`,
        `(UTC-01:00) Cabo Verde Is.`,
        `(UTC) Coordinated Universal Time`,
        `(UTC+00:00) Dublin, Edinburgh, Lisbon, London`,
        `(UTC+00:00) Monrovia, Reykjavik`,
        `(UTC+00:00) Sao Tome`,
        `(UTC+01:00) Casablanca`,
        `(UTC+01:00) Amsterdam, Berlin, Bern, Rome, Stockholm, Vienna`,
        `(UTC+01:00) Belgrade, Bratislava, Budapest, Ljubljana, Prague`,
        `(UTC+01:00) Brussels, Copenhagen, Madrid, Paris`,
        `(UTC+01:00) Sarajevo, Skopje, Warsaw, Zagreb`,
        `(UTC+01:00) West Central Africa`,
        `(UTC+02:00) Amman`,
        `(UTC+02:00) Athens, Bucharest`,
        `(UTC+02:00) Beirut`,
        `(UTC+02:00) Cairo`,
        `(UTC+02:00) Chisinau`,
        `(UTC+02:00) Damascus`,
        `(UTC+02:00) Gaza, Hebron`,
        `(UTC+02:00) Harare, Pretoria`,
        `(UTC+02:00) Helsinki, Kyiv, Riga, Sofia, Tallinn, Vilnius`,
        `(UTC+02:00) Jerusalem`,
        `(UTC+02:00) Juba`,
        `(UTC+02:00) Kaliningrad`,
        `(UTC+02:00) Khartoum`,
        `(UTC+02:00) Tripoli`,
        `(UTC+02:00) Windhoek`,
        `(UTC+03:00) Baghdad`,
        `(UTC+03:00) Istanbul`,
        `(UTC+03:00) Kuwait, Riyadh`,
        `(UTC+03:00) Minsk`,
        `(UTC+03:00) Moscow, St. Petersburg`,
        `(UTC+03:00) Nairobi`,
        `(UTC+03:00) Volgograd`,
        `(UTC+03:30) Tehran`,
        `(UTC+04:00) Abu Dhabi, Muscat`,
        `(UTC+04:00) Astrakhan, Ulyanovsk`,
        `(UTC+04:00) Baku`,
        `(UTC+04:00) Izhevsk, Samara`,
        `(UTC+04:00) Port Louis`,
        `(UTC+04:00) Saratov`,
        `(UTC+04:00) Tbilisi`,
        `(UTC+04:00) Yerevan`,
        `(UTC+04:30) Kabul`,
        `(UTC+05:00) Ashgabat, Tashkent`,
        `(UTC+05:00) Ekaterinburg`,
        `(UTC+05:00) Islamabad, Karachi`,
        `(UTC+05:00) Qyzylorda`,
        `(UTC+05:30) Chennai, Kolkata, Mumbai, New Delhi`,
        `(UTC+05:30) Sri Jayawardenepura`,
        `(UTC+05:45) Kathmandu`,
        `(UTC+06:00) Astana`,
        `(UTC+06:00) Dhaka`,
        `(UTC+06:00) Omsk`,
        `(UTC+06:30) Yangon (Rangoon)`,
        `(UTC+07:00) Bangkok, Hanoi, Jakarta`,
        `(UTC+07:00) Barnaul, Gorno-Altaysk`,
        `(UTC+07:00) Hovd`,
        `(UTC+07:00) Krasnoyarsk`,
        `(UTC+07:00) Novosibirsk`,
        `(UTC+07:00) Tomsk`,
        `(UTC+08:00) Beijing, Chongqing, Hong Kong, Urumqi`,
        `(UTC+08:00) Irkutsk`,
        `(UTC+08:00) Kuala Lumpur, Singapore`,
        `(UTC+08:00) Perth`,
        `(UTC+08:00) Taipei`,
        `(UTC+08:00) Ulaanbaatar`,
        `(UTC+08:45) Eucla`,
        `(UTC+09:00) Chita`,
        `(UTC+09:00) Osaka, Sapporo, Tokyo`,
        `(UTC+09:00) Pyongyang`,
        `(UTC+09:00) Seoul`,
        `(UTC+09:00) Yakutsk`,
        `(UTC+09:30) Adelaide`,
        `(UTC+09:30) Darwin`,
        `(UTC+10:00) Brisbane`,
        `(UTC+10:00) Canberra, Melbourne, Sydney`,
        `(UTC+10:00) Guam, Port Moresby`,
        `(UTC+10:00) Hobart`,
        `(UTC+10:00) Vladivostok`,
        `(UTC+10:30) Lord Howe Island`,
        `(UTC+11:00) Bougainville Island`,
        `(UTC+11:00) Chokurdakh`,
        `(UTC+11:00) Magadan`,
        `(UTC+11:00) Norfolk Island`,
        `(UTC+11:00) Sakhalin`,
        `(UTC+11:00) Solomon Is., New Caledonia`,
        `(UTC+12:00) Anadyr, Petropavlovsk-Kamchatsky`,
        `(UTC+12:00) Auckland, Wellington`,
        `(UTC+12:00) Coordinated Universal Time+12`,
        `(UTC+12:00) Fiji`,
        `(UTC+12:00) Petropavlovsk-Kamchatsky - Old`,
        `(UTC+12:45) Chatham Islands`,
        `(UTC+13:00) Coordinated Universal Time+13`,
        `(UTC+13:00) Nuku'alofa`,
        `(UTC+13:00) Samoa`,
        `(UTC+14:00) Kiritimati Island`.
        """
        return pulumi.get(self, "time_zone")

    @time_zone.setter
    def time_zone(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "time_zone", value)


if not MYPY:
    class BuildDefinitionScheduleBranchFilterArgsDict(TypedDict):
        excludes: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        List of branch patterns to exclude.
        """
        includes: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        List of branch patterns to include.
        """
elif False:
    BuildDefinitionScheduleBranchFilterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class BuildDefinitionScheduleBranchFilterArgs:
    def __init__(__self__, *,
                 excludes: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 includes: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input[str]]] excludes: List of branch patterns to exclude.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] includes: List of branch patterns to include.
        """
        if excludes is not None:
            pulumi.set(__self__, "excludes", excludes)
        if includes is not None:
            pulumi.set(__self__, "includes", includes)

    @property
    @pulumi.getter
    def excludes(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        List of branch patterns to exclude.
        """
        return pulumi.get(self, "excludes")

    @excludes.setter
    def excludes(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "excludes", value)

    @property
    @pulumi.getter
    def includes(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        List of branch patterns to include.
        """
        return pulumi.get(self, "includes")

    @includes.setter
    def includes(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "includes", value)


if not MYPY:
    class BuildDefinitionVariableArgsDict(TypedDict):
        name: pulumi.Input[str]
        """
        The name of the variable.
        """
        allow_override: NotRequired[pulumi.Input[bool]]
        """
        True if the variable can be overridden. Defaults to `true`.
        """
        is_secret: NotRequired[pulumi.Input[bool]]
        """
        True if the variable is a secret. Defaults to `false`.
        """
        secret_value: NotRequired[pulumi.Input[str]]
        """
        The secret value of the variable. Used when `is_secret` set to `true`.
        """
        value: NotRequired[pulumi.Input[str]]
        """
        The value of the variable.
        """
elif False:
    BuildDefinitionVariableArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class BuildDefinitionVariableArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[str],
                 allow_override: Optional[pulumi.Input[bool]] = None,
                 is_secret: Optional[pulumi.Input[bool]] = None,
                 secret_value: Optional[pulumi.Input[str]] = None,
                 value: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] name: The name of the variable.
        :param pulumi.Input[bool] allow_override: True if the variable can be overridden. Defaults to `true`.
        :param pulumi.Input[bool] is_secret: True if the variable is a secret. Defaults to `false`.
        :param pulumi.Input[str] secret_value: The secret value of the variable. Used when `is_secret` set to `true`.
        :param pulumi.Input[str] value: The value of the variable.
        """
        pulumi.set(__self__, "name", name)
        if allow_override is not None:
            pulumi.set(__self__, "allow_override", allow_override)
        if is_secret is not None:
            pulumi.set(__self__, "is_secret", is_secret)
        if secret_value is not None:
            pulumi.set(__self__, "secret_value", secret_value)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        The name of the variable.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter(name="allowOverride")
    def allow_override(self) -> Optional[pulumi.Input[bool]]:
        """
        True if the variable can be overridden. Defaults to `true`.
        """
        return pulumi.get(self, "allow_override")

    @allow_override.setter
    def allow_override(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "allow_override", value)

    @property
    @pulumi.getter(name="isSecret")
    def is_secret(self) -> Optional[pulumi.Input[bool]]:
        """
        True if the variable is a secret. Defaults to `false`.
        """
        return pulumi.get(self, "is_secret")

    @is_secret.setter
    def is_secret(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "is_secret", value)

    @property
    @pulumi.getter(name="secretValue")
    def secret_value(self) -> Optional[pulumi.Input[str]]:
        """
        The secret value of the variable. Used when `is_secret` set to `true`.
        """
        return pulumi.get(self, "secret_value")

    @secret_value.setter
    def secret_value(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "secret_value", value)

    @property
    @pulumi.getter
    def value(self) -> Optional[pulumi.Input[str]]:
        """
        The value of the variable.
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "value", value)


if not MYPY:
    class CheckRequiredTemplateRequiredTemplateArgsDict(TypedDict):
        repository_name: pulumi.Input[str]
        """
        The name of the repository storing the template.
        """
        repository_ref: pulumi.Input[str]
        """
        The branch in which the template will be referenced.
        """
        template_path: pulumi.Input[str]
        """
        The path to the template yaml.
        """
        repository_type: NotRequired[pulumi.Input[str]]
        """
        The type of the repository storing the template. Possible values are: `azuregit`, `github`, `githubenterprise`, `bitbucket`. Defaults to `azuregit`.
        """
elif False:
    CheckRequiredTemplateRequiredTemplateArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class CheckRequiredTemplateRequiredTemplateArgs:
    def __init__(__self__, *,
                 repository_name: pulumi.Input[str],
                 repository_ref: pulumi.Input[str],
                 template_path: pulumi.Input[str],
                 repository_type: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] repository_name: The name of the repository storing the template.
        :param pulumi.Input[str] repository_ref: The branch in which the template will be referenced.
        :param pulumi.Input[str] template_path: The path to the template yaml.
        :param pulumi.Input[str] repository_type: The type of the repository storing the template. Possible values are: `azuregit`, `github`, `githubenterprise`, `bitbucket`. Defaults to `azuregit`.
        """
        pulumi.set(__self__, "repository_name", repository_name)
        pulumi.set(__self__, "repository_ref", repository_ref)
        pulumi.set(__self__, "template_path", template_path)
        if repository_type is not None:
            pulumi.set(__self__, "repository_type", repository_type)

    @property
    @pulumi.getter(name="repositoryName")
    def repository_name(self) -> pulumi.Input[str]:
        """
        The name of the repository storing the template.
        """
        return pulumi.get(self, "repository_name")

    @repository_name.setter
    def repository_name(self, value: pulumi.Input[str]):
        pulumi.set(self, "repository_name", value)

    @property
    @pulumi.getter(name="repositoryRef")
    def repository_ref(self) -> pulumi.Input[str]:
        """
        The branch in which the template will be referenced.
        """
        return pulumi.get(self, "repository_ref")

    @repository_ref.setter
    def repository_ref(self, value: pulumi.Input[str]):
        pulumi.set(self, "repository_ref", value)

    @property
    @pulumi.getter(name="templatePath")
    def template_path(self) -> pulumi.Input[str]:
        """
        The path to the template yaml.
        """
        return pulumi.get(self, "template_path")

    @template_path.setter
    def template_path(self, value: pulumi.Input[str]):
        pulumi.set(self, "template_path", value)

    @property
    @pulumi.getter(name="repositoryType")
    def repository_type(self) -> Optional[pulumi.Input[str]]:
        """
        The type of the repository storing the template. Possible values are: `azuregit`, `github`, `githubenterprise`, `bitbucket`. Defaults to `azuregit`.
        """
        return pulumi.get(self, "repository_type")

    @repository_type.setter
    def repository_type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "repository_type", value)


if not MYPY:
    class FeedFeatureArgsDict(TypedDict):
        permanent_delete: NotRequired[pulumi.Input[bool]]
        """
        Determines if Feed should be Permanently removed, Defaults to `false`
        """
        restore: NotRequired[pulumi.Input[bool]]
        """
        Determines if Feed should be Restored during creation (if possible), Defaults to `false`
        """
elif False:
    FeedFeatureArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class FeedFeatureArgs:
    def __init__(__self__, *,
                 permanent_delete: Optional[pulumi.Input[bool]] = None,
                 restore: Optional[pulumi.Input[bool]] = None):
        """
        :param pulumi.Input[bool] permanent_delete: Determines if Feed should be Permanently removed, Defaults to `false`
        :param pulumi.Input[bool] restore: Determines if Feed should be Restored during creation (if possible), Defaults to `false`
        """
        if permanent_delete is not None:
            pulumi.set(__self__, "permanent_delete", permanent_delete)
        if restore is not None:
            pulumi.set(__self__, "restore", restore)

    @property
    @pulumi.getter(name="permanentDelete")
    def permanent_delete(self) -> Optional[pulumi.Input[bool]]:
        """
        Determines if Feed should be Permanently removed, Defaults to `false`
        """
        return pulumi.get(self, "permanent_delete")

    @permanent_delete.setter
    def permanent_delete(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "permanent_delete", value)

    @property
    @pulumi.getter
    def restore(self) -> Optional[pulumi.Input[bool]]:
        """
        Determines if Feed should be Restored during creation (if possible), Defaults to `false`
        """
        return pulumi.get(self, "restore")

    @restore.setter
    def restore(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "restore", value)


if not MYPY:
    class GitInitializationArgsDict(TypedDict):
        init_type: pulumi.Input[str]
        """
        The type of repository to create. Valid values: `Uninitialized`, `Clean` or `Import`.
        """
        password: NotRequired[pulumi.Input[str]]
        """
        The password used to authenticate to a private repository for import initialization. Conflicts with `service_connection_id`.

        ~>**Note** At least `service_connection_id` or `username/password` needs to be set to import private repository.
        """
        service_connection_id: NotRequired[pulumi.Input[str]]
        """
        The ID of service connection used to authenticate to a private repository for import initialization. Conflicts with `username` and `password`.
        """
        source_type: NotRequired[pulumi.Input[str]]
        """
        Type of the source repository. Used if the `init_type` is `Import`. Valid values: `Git`.
        """
        source_url: NotRequired[pulumi.Input[str]]
        """
        The URL of the source repository. Used if the `init_type` is `Import`.
        """
        username: NotRequired[pulumi.Input[str]]
        """
        The username used to authenticate to a private repository for import initialization. Conflicts with `service_connection_id`.
        """
elif False:
    GitInitializationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GitInitializationArgs:
    def __init__(__self__, *,
                 init_type: pulumi.Input[str],
                 password: Optional[pulumi.Input[str]] = None,
                 service_connection_id: Optional[pulumi.Input[str]] = None,
                 source_type: Optional[pulumi.Input[str]] = None,
                 source_url: Optional[pulumi.Input[str]] = None,
                 username: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] init_type: The type of repository to create. Valid values: `Uninitialized`, `Clean` or `Import`.
        :param pulumi.Input[str] password: The password used to authenticate to a private repository for import initialization. Conflicts with `service_connection_id`.
               
               ~>**Note** At least `service_connection_id` or `username/password` needs to be set to import private repository.
        :param pulumi.Input[str] service_connection_id: The ID of service connection used to authenticate to a private repository for import initialization. Conflicts with `username` and `password`.
        :param pulumi.Input[str] source_type: Type of the source repository. Used if the `init_type` is `Import`. Valid values: `Git`.
        :param pulumi.Input[str] source_url: The URL of the source repository. Used if the `init_type` is `Import`.
        :param pulumi.Input[str] username: The username used to authenticate to a private repository for import initialization. Conflicts with `service_connection_id`.
        """
        pulumi.set(__self__, "init_type", init_type)
        if password is not None:
            pulumi.set(__self__, "password", password)
        if service_connection_id is not None:
            pulumi.set(__self__, "service_connection_id", service_connection_id)
        if source_type is not None:
            pulumi.set(__self__, "source_type", source_type)
        if source_url is not None:
            pulumi.set(__self__, "source_url", source_url)
        if username is not None:
            pulumi.set(__self__, "username", username)

    @property
    @pulumi.getter(name="initType")
    def init_type(self) -> pulumi.Input[str]:
        """
        The type of repository to create. Valid values: `Uninitialized`, `Clean` or `Import`.
        """
        return pulumi.get(self, "init_type")

    @init_type.setter
    def init_type(self, value: pulumi.Input[str]):
        pulumi.set(self, "init_type", value)

    @property
    @pulumi.getter
    def password(self) -> Optional[pulumi.Input[str]]:
        """
        The password used to authenticate to a private repository for import initialization. Conflicts with `service_connection_id`.

        ~>**Note** At least `service_connection_id` or `username/password` needs to be set to import private repository.
        """
        return pulumi.get(self, "password")

    @password.setter
    def password(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "password", value)

    @property
    @pulumi.getter(name="serviceConnectionId")
    def service_connection_id(self) -> Optional[pulumi.Input[str]]:
        """
        The ID of service connection used to authenticate to a private repository for import initialization. Conflicts with `username` and `password`.
        """
        return pulumi.get(self, "service_connection_id")

    @service_connection_id.setter
    def service_connection_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "service_connection_id", value)

    @property
    @pulumi.getter(name="sourceType")
    def source_type(self) -> Optional[pulumi.Input[str]]:
        """
        Type of the source repository. Used if the `init_type` is `Import`. Valid values: `Git`.
        """
        return pulumi.get(self, "source_type")

    @source_type.setter
    def source_type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "source_type", value)

    @property
    @pulumi.getter(name="sourceUrl")
    def source_url(self) -> Optional[pulumi.Input[str]]:
        """
        The URL of the source repository. Used if the `init_type` is `Import`.
        """
        return pulumi.get(self, "source_url")

    @source_url.setter
    def source_url(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "source_url", value)

    @property
    @pulumi.getter
    def username(self) -> Optional[pulumi.Input[str]]:
        """
        The username used to authenticate to a private repository for import initialization. Conflicts with `service_connection_id`.
        """
        return pulumi.get(self, "username")

    @username.setter
    def username(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "username", value)


if not MYPY:
    class ServiceEndpointArtifactoryAuthenticationBasicArgsDict(TypedDict):
        password: pulumi.Input[str]
        """
        The Password of the Artifactory.
        """
        username: pulumi.Input[str]
        """
        The Username of the Artifactory.
        """
elif False:
    ServiceEndpointArtifactoryAuthenticationBasicArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ServiceEndpointArtifactoryAuthenticationBasicArgs:
    def __init__(__self__, *,
                 password: pulumi.Input[str],
                 username: pulumi.Input[str]):
        """
        :param pulumi.Input[str] password: The Password of the Artifactory.
        :param pulumi.Input[str] username: The Username of the Artifactory.
        """
        pulumi.set(__self__, "password", password)
        pulumi.set(__self__, "username", username)

    @property
    @pulumi.getter
    def password(self) -> pulumi.Input[str]:
        """
        The Password of the Artifactory.
        """
        return pulumi.get(self, "password")

    @password.setter
    def password(self, value: pulumi.Input[str]):
        pulumi.set(self, "password", value)

    @property
    @pulumi.getter
    def username(self) -> pulumi.Input[str]:
        """
        The Username of the Artifactory.
        """
        return pulumi.get(self, "username")

    @username.setter
    def username(self, value: pulumi.Input[str]):
        pulumi.set(self, "username", value)


if not MYPY:
    class ServiceEndpointArtifactoryAuthenticationTokenArgsDict(TypedDict):
        token: pulumi.Input[str]
        """
        Authentication Token generated through Artifactory.
        """
elif False:
    ServiceEndpointArtifactoryAuthenticationTokenArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ServiceEndpointArtifactoryAuthenticationTokenArgs:
    def __init__(__self__, *,
                 token: pulumi.Input[str]):
        """
        :param pulumi.Input[str] token: Authentication Token generated through Artifactory.
        """
        pulumi.set(__self__, "token", token)

    @property
    @pulumi.getter
    def token(self) -> pulumi.Input[str]:
        """
        Authentication Token generated through Artifactory.
        """
        return pulumi.get(self, "token")

    @token.setter
    def token(self, value: pulumi.Input[str]):
        pulumi.set(self, "token", value)


if not MYPY:
    class ServiceEndpointAzureEcrCredentialsArgsDict(TypedDict):
        serviceprincipalid: pulumi.Input[str]
        """
        The ID of the Service Principal Application.
        """
elif False:
    ServiceEndpointAzureEcrCredentialsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ServiceEndpointAzureEcrCredentialsArgs:
    def __init__(__self__, *,
                 serviceprincipalid: pulumi.Input[str]):
        """
        :param pulumi.Input[str] serviceprincipalid: The ID of the Service Principal Application.
        """
        pulumi.set(__self__, "serviceprincipalid", serviceprincipalid)

    @property
    @pulumi.getter
    def serviceprincipalid(self) -> pulumi.Input[str]:
        """
        The ID of the Service Principal Application.
        """
        return pulumi.get(self, "serviceprincipalid")

    @serviceprincipalid.setter
    def serviceprincipalid(self, value: pulumi.Input[str]):
        pulumi.set(self, "serviceprincipalid", value)


if not MYPY:
    class ServiceEndpointAzureRMCredentialsArgsDict(TypedDict):
        serviceprincipalid: pulumi.Input[str]
        """
        The service principal application ID
        """
        serviceprincipalcertificate: NotRequired[pulumi.Input[str]]
        """
        The service principal certificate. This not required if `service_endpoint_authentication_scheme` is set to `WorkloadIdentityFederation`.
        """
        serviceprincipalkey: NotRequired[pulumi.Input[str]]
        """
        The service principal secret. This not required if `service_endpoint_authentication_scheme` is set to `WorkloadIdentityFederation`.
        """
elif False:
    ServiceEndpointAzureRMCredentialsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ServiceEndpointAzureRMCredentialsArgs:
    def __init__(__self__, *,
                 serviceprincipalid: pulumi.Input[str],
                 serviceprincipalcertificate: Optional[pulumi.Input[str]] = None,
                 serviceprincipalkey: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] serviceprincipalid: The service principal application ID
        :param pulumi.Input[str] serviceprincipalcertificate: The service principal certificate. This not required if `service_endpoint_authentication_scheme` is set to `WorkloadIdentityFederation`.
        :param pulumi.Input[str] serviceprincipalkey: The service principal secret. This not required if `service_endpoint_authentication_scheme` is set to `WorkloadIdentityFederation`.
        """
        pulumi.set(__self__, "serviceprincipalid", serviceprincipalid)
        if serviceprincipalcertificate is not None:
            pulumi.set(__self__, "serviceprincipalcertificate", serviceprincipalcertificate)
        if serviceprincipalkey is not None:
            pulumi.set(__self__, "serviceprincipalkey", serviceprincipalkey)

    @property
    @pulumi.getter
    def serviceprincipalid(self) -> pulumi.Input[str]:
        """
        The service principal application ID
        """
        return pulumi.get(self, "serviceprincipalid")

    @serviceprincipalid.setter
    def serviceprincipalid(self, value: pulumi.Input[str]):
        pulumi.set(self, "serviceprincipalid", value)

    @property
    @pulumi.getter
    def serviceprincipalcertificate(self) -> Optional[pulumi.Input[str]]:
        """
        The service principal certificate. This not required if `service_endpoint_authentication_scheme` is set to `WorkloadIdentityFederation`.
        """
        return pulumi.get(self, "serviceprincipalcertificate")

    @serviceprincipalcertificate.setter
    def serviceprincipalcertificate(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "serviceprincipalcertificate", value)

    @property
    @pulumi.getter
    def serviceprincipalkey(self) -> Optional[pulumi.Input[str]]:
        """
        The service principal secret. This not required if `service_endpoint_authentication_scheme` is set to `WorkloadIdentityFederation`.
        """
        return pulumi.get(self, "serviceprincipalkey")

    @serviceprincipalkey.setter
    def serviceprincipalkey(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "serviceprincipalkey", value)


if not MYPY:
    class ServiceEndpointAzureRMFeaturesArgsDict(TypedDict):
        validate: NotRequired[pulumi.Input[bool]]
        """
        Whether or not to validate connection with Azure after create or update operations. Defaults to `false`
        """
elif False:
    ServiceEndpointAzureRMFeaturesArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ServiceEndpointAzureRMFeaturesArgs:
    def __init__(__self__, *,
                 validate: Optional[pulumi.Input[bool]] = None):
        """
        :param pulumi.Input[bool] validate: Whether or not to validate connection with Azure after create or update operations. Defaults to `false`
        """
        if validate is not None:
            pulumi.set(__self__, "validate", validate)

    @property
    @pulumi.getter
    def validate(self) -> Optional[pulumi.Input[bool]]:
        """
        Whether or not to validate connection with Azure after create or update operations. Defaults to `false`
        """
        return pulumi.get(self, "validate")

    @validate.setter
    def validate(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "validate", value)


if not MYPY:
    class ServiceEndpointGitHubAuthOauthArgsDict(TypedDict):
        oauth_configuration_id: pulumi.Input[str]
elif False:
    ServiceEndpointGitHubAuthOauthArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ServiceEndpointGitHubAuthOauthArgs:
    def __init__(__self__, *,
                 oauth_configuration_id: pulumi.Input[str]):
        pulumi.set(__self__, "oauth_configuration_id", oauth_configuration_id)

    @property
    @pulumi.getter(name="oauthConfigurationId")
    def oauth_configuration_id(self) -> pulumi.Input[str]:
        return pulumi.get(self, "oauth_configuration_id")

    @oauth_configuration_id.setter
    def oauth_configuration_id(self, value: pulumi.Input[str]):
        pulumi.set(self, "oauth_configuration_id", value)


if not MYPY:
    class ServiceEndpointGitHubAuthPersonalArgsDict(TypedDict):
        personal_access_token: pulumi.Input[str]
        """
        The Personal Access Token for GitHub.
        """
elif False:
    ServiceEndpointGitHubAuthPersonalArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ServiceEndpointGitHubAuthPersonalArgs:
    def __init__(__self__, *,
                 personal_access_token: pulumi.Input[str]):
        """
        :param pulumi.Input[str] personal_access_token: The Personal Access Token for GitHub.
        """
        pulumi.set(__self__, "personal_access_token", personal_access_token)

    @property
    @pulumi.getter(name="personalAccessToken")
    def personal_access_token(self) -> pulumi.Input[str]:
        """
        The Personal Access Token for GitHub.
        """
        return pulumi.get(self, "personal_access_token")

    @personal_access_token.setter
    def personal_access_token(self, value: pulumi.Input[str]):
        pulumi.set(self, "personal_access_token", value)


if not MYPY:
    class ServiceEndpointGitHubEnterpriseAuthPersonalArgsDict(TypedDict):
        personal_access_token: pulumi.Input[str]
        """
        The Personal Access Token for GitHub.
        """
elif False:
    ServiceEndpointGitHubEnterpriseAuthPersonalArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ServiceEndpointGitHubEnterpriseAuthPersonalArgs:
    def __init__(__self__, *,
                 personal_access_token: pulumi.Input[str]):
        """
        :param pulumi.Input[str] personal_access_token: The Personal Access Token for GitHub.
        """
        pulumi.set(__self__, "personal_access_token", personal_access_token)

    @property
    @pulumi.getter(name="personalAccessToken")
    def personal_access_token(self) -> pulumi.Input[str]:
        """
        The Personal Access Token for GitHub.
        """
        return pulumi.get(self, "personal_access_token")

    @personal_access_token.setter
    def personal_access_token(self, value: pulumi.Input[str]):
        pulumi.set(self, "personal_access_token", value)


if not MYPY:
    class ServiceEndpointKubernetesAzureSubscriptionArgsDict(TypedDict):
        cluster_name: pulumi.Input[str]
        """
        The name of the Kubernetes cluster.
        """
        resourcegroup_id: pulumi.Input[str]
        """
        The resource group name, to which the Kubernetes cluster is deployed.
        """
        subscription_id: pulumi.Input[str]
        """
        The id of the Azure subscription.
        """
        subscription_name: pulumi.Input[str]
        """
        The name of the Azure subscription.
        """
        tenant_id: pulumi.Input[str]
        """
        The id of the tenant used by the subscription.
        """
        azure_environment: NotRequired[pulumi.Input[str]]
        """
        Azure environment refers to whether the public cloud offering or domestic (government) clouds are being used. Currently, only the public cloud is supported. The value must be AzureCloud. This is also the default-value.
        """
        cluster_admin: NotRequired[pulumi.Input[bool]]
        """
        Set this option to allow use cluster admin credentials.
        """
        namespace: NotRequired[pulumi.Input[str]]
        """
        The Kubernetes namespace. Default value is "default".
        """
elif False:
    ServiceEndpointKubernetesAzureSubscriptionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ServiceEndpointKubernetesAzureSubscriptionArgs:
    def __init__(__self__, *,
                 cluster_name: pulumi.Input[str],
                 resourcegroup_id: pulumi.Input[str],
                 subscription_id: pulumi.Input[str],
                 subscription_name: pulumi.Input[str],
                 tenant_id: pulumi.Input[str],
                 azure_environment: Optional[pulumi.Input[str]] = None,
                 cluster_admin: Optional[pulumi.Input[bool]] = None,
                 namespace: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] cluster_name: The name of the Kubernetes cluster.
        :param pulumi.Input[str] resourcegroup_id: The resource group name, to which the Kubernetes cluster is deployed.
        :param pulumi.Input[str] subscription_id: The id of the Azure subscription.
        :param pulumi.Input[str] subscription_name: The name of the Azure subscription.
        :param pulumi.Input[str] tenant_id: The id of the tenant used by the subscription.
        :param pulumi.Input[str] azure_environment: Azure environment refers to whether the public cloud offering or domestic (government) clouds are being used. Currently, only the public cloud is supported. The value must be AzureCloud. This is also the default-value.
        :param pulumi.Input[bool] cluster_admin: Set this option to allow use cluster admin credentials.
        :param pulumi.Input[str] namespace: The Kubernetes namespace. Default value is "default".
        """
        pulumi.set(__self__, "cluster_name", cluster_name)
        pulumi.set(__self__, "resourcegroup_id", resourcegroup_id)
        pulumi.set(__self__, "subscription_id", subscription_id)
        pulumi.set(__self__, "subscription_name", subscription_name)
        pulumi.set(__self__, "tenant_id", tenant_id)
        if azure_environment is not None:
            pulumi.set(__self__, "azure_environment", azure_environment)
        if cluster_admin is not None:
            pulumi.set(__self__, "cluster_admin", cluster_admin)
        if namespace is not None:
            pulumi.set(__self__, "namespace", namespace)

    @property
    @pulumi.getter(name="clusterName")
    def cluster_name(self) -> pulumi.Input[str]:
        """
        The name of the Kubernetes cluster.
        """
        return pulumi.get(self, "cluster_name")

    @cluster_name.setter
    def cluster_name(self, value: pulumi.Input[str]):
        pulumi.set(self, "cluster_name", value)

    @property
    @pulumi.getter(name="resourcegroupId")
    def resourcegroup_id(self) -> pulumi.Input[str]:
        """
        The resource group name, to which the Kubernetes cluster is deployed.
        """
        return pulumi.get(self, "resourcegroup_id")

    @resourcegroup_id.setter
    def resourcegroup_id(self, value: pulumi.Input[str]):
        pulumi.set(self, "resourcegroup_id", value)

    @property
    @pulumi.getter(name="subscriptionId")
    def subscription_id(self) -> pulumi.Input[str]:
        """
        The id of the Azure subscription.
        """
        return pulumi.get(self, "subscription_id")

    @subscription_id.setter
    def subscription_id(self, value: pulumi.Input[str]):
        pulumi.set(self, "subscription_id", value)

    @property
    @pulumi.getter(name="subscriptionName")
    def subscription_name(self) -> pulumi.Input[str]:
        """
        The name of the Azure subscription.
        """
        return pulumi.get(self, "subscription_name")

    @subscription_name.setter
    def subscription_name(self, value: pulumi.Input[str]):
        pulumi.set(self, "subscription_name", value)

    @property
    @pulumi.getter(name="tenantId")
    def tenant_id(self) -> pulumi.Input[str]:
        """
        The id of the tenant used by the subscription.
        """
        return pulumi.get(self, "tenant_id")

    @tenant_id.setter
    def tenant_id(self, value: pulumi.Input[str]):
        pulumi.set(self, "tenant_id", value)

    @property
    @pulumi.getter(name="azureEnvironment")
    def azure_environment(self) -> Optional[pulumi.Input[str]]:
        """
        Azure environment refers to whether the public cloud offering or domestic (government) clouds are being used. Currently, only the public cloud is supported. The value must be AzureCloud. This is also the default-value.
        """
        return pulumi.get(self, "azure_environment")

    @azure_environment.setter
    def azure_environment(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "azure_environment", value)

    @property
    @pulumi.getter(name="clusterAdmin")
    def cluster_admin(self) -> Optional[pulumi.Input[bool]]:
        """
        Set this option to allow use cluster admin credentials.
        """
        return pulumi.get(self, "cluster_admin")

    @cluster_admin.setter
    def cluster_admin(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "cluster_admin", value)

    @property
    @pulumi.getter
    def namespace(self) -> Optional[pulumi.Input[str]]:
        """
        The Kubernetes namespace. Default value is "default".
        """
        return pulumi.get(self, "namespace")

    @namespace.setter
    def namespace(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "namespace", value)


if not MYPY:
    class ServiceEndpointKubernetesKubeconfigArgsDict(TypedDict):
        kube_config: pulumi.Input[str]
        """
        The content of the kubeconfig in yaml notation to be used to communicate with the API-Server of Kubernetes.
        """
        accept_untrusted_certs: NotRequired[pulumi.Input[bool]]
        """
        Set this option to allow clients to accept a self-signed certificate.
        """
        cluster_context: NotRequired[pulumi.Input[str]]
        """
        Context within the kubeconfig file that is to be used for identifying the cluster. Default value is the current-context set in kubeconfig.
        """
elif False:
    ServiceEndpointKubernetesKubeconfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ServiceEndpointKubernetesKubeconfigArgs:
    def __init__(__self__, *,
                 kube_config: pulumi.Input[str],
                 accept_untrusted_certs: Optional[pulumi.Input[bool]] = None,
                 cluster_context: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] kube_config: The content of the kubeconfig in yaml notation to be used to communicate with the API-Server of Kubernetes.
        :param pulumi.Input[bool] accept_untrusted_certs: Set this option to allow clients to accept a self-signed certificate.
        :param pulumi.Input[str] cluster_context: Context within the kubeconfig file that is to be used for identifying the cluster. Default value is the current-context set in kubeconfig.
        """
        pulumi.set(__self__, "kube_config", kube_config)
        if accept_untrusted_certs is not None:
            pulumi.set(__self__, "accept_untrusted_certs", accept_untrusted_certs)
        if cluster_context is not None:
            pulumi.set(__self__, "cluster_context", cluster_context)

    @property
    @pulumi.getter(name="kubeConfig")
    def kube_config(self) -> pulumi.Input[str]:
        """
        The content of the kubeconfig in yaml notation to be used to communicate with the API-Server of Kubernetes.
        """
        return pulumi.get(self, "kube_config")

    @kube_config.setter
    def kube_config(self, value: pulumi.Input[str]):
        pulumi.set(self, "kube_config", value)

    @property
    @pulumi.getter(name="acceptUntrustedCerts")
    def accept_untrusted_certs(self) -> Optional[pulumi.Input[bool]]:
        """
        Set this option to allow clients to accept a self-signed certificate.
        """
        return pulumi.get(self, "accept_untrusted_certs")

    @accept_untrusted_certs.setter
    def accept_untrusted_certs(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "accept_untrusted_certs", value)

    @property
    @pulumi.getter(name="clusterContext")
    def cluster_context(self) -> Optional[pulumi.Input[str]]:
        """
        Context within the kubeconfig file that is to be used for identifying the cluster. Default value is the current-context set in kubeconfig.
        """
        return pulumi.get(self, "cluster_context")

    @cluster_context.setter
    def cluster_context(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "cluster_context", value)


if not MYPY:
    class ServiceEndpointKubernetesServiceAccountArgsDict(TypedDict):
        ca_cert: pulumi.Input[str]
        """
        The certificate from a Kubernetes secret object.
        """
        token: pulumi.Input[str]
        """
        The token from a Kubernetes secret object.
        """
        accept_untrusted_certs: NotRequired[pulumi.Input[bool]]
        """
        Set this option to allow clients to accept a self-signed certificate. Defaults to `false`.
        """
elif False:
    ServiceEndpointKubernetesServiceAccountArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ServiceEndpointKubernetesServiceAccountArgs:
    def __init__(__self__, *,
                 ca_cert: pulumi.Input[str],
                 token: pulumi.Input[str],
                 accept_untrusted_certs: Optional[pulumi.Input[bool]] = None):
        """
        :param pulumi.Input[str] ca_cert: The certificate from a Kubernetes secret object.
        :param pulumi.Input[str] token: The token from a Kubernetes secret object.
        :param pulumi.Input[bool] accept_untrusted_certs: Set this option to allow clients to accept a self-signed certificate. Defaults to `false`.
        """
        pulumi.set(__self__, "ca_cert", ca_cert)
        pulumi.set(__self__, "token", token)
        if accept_untrusted_certs is not None:
            pulumi.set(__self__, "accept_untrusted_certs", accept_untrusted_certs)

    @property
    @pulumi.getter(name="caCert")
    def ca_cert(self) -> pulumi.Input[str]:
        """
        The certificate from a Kubernetes secret object.
        """
        return pulumi.get(self, "ca_cert")

    @ca_cert.setter
    def ca_cert(self, value: pulumi.Input[str]):
        pulumi.set(self, "ca_cert", value)

    @property
    @pulumi.getter
    def token(self) -> pulumi.Input[str]:
        """
        The token from a Kubernetes secret object.
        """
        return pulumi.get(self, "token")

    @token.setter
    def token(self, value: pulumi.Input[str]):
        pulumi.set(self, "token", value)

    @property
    @pulumi.getter(name="acceptUntrustedCerts")
    def accept_untrusted_certs(self) -> Optional[pulumi.Input[bool]]:
        """
        Set this option to allow clients to accept a self-signed certificate. Defaults to `false`.
        """
        return pulumi.get(self, "accept_untrusted_certs")

    @accept_untrusted_certs.setter
    def accept_untrusted_certs(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "accept_untrusted_certs", value)


if not MYPY:
    class ServiceEndpointPipelineAuthPersonalArgsDict(TypedDict):
        personal_access_token: pulumi.Input[str]
        """
        The Personal Access Token for Azure DevOps Pipeline. It also can be set with AZDO_PERSONAL_ACCESS_TOKEN environment variable.
        """
elif False:
    ServiceEndpointPipelineAuthPersonalArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ServiceEndpointPipelineAuthPersonalArgs:
    def __init__(__self__, *,
                 personal_access_token: pulumi.Input[str]):
        """
        :param pulumi.Input[str] personal_access_token: The Personal Access Token for Azure DevOps Pipeline. It also can be set with AZDO_PERSONAL_ACCESS_TOKEN environment variable.
        """
        pulumi.set(__self__, "personal_access_token", personal_access_token)

    @property
    @pulumi.getter(name="personalAccessToken")
    def personal_access_token(self) -> pulumi.Input[str]:
        """
        The Personal Access Token for Azure DevOps Pipeline. It also can be set with AZDO_PERSONAL_ACCESS_TOKEN environment variable.
        """
        return pulumi.get(self, "personal_access_token")

    @personal_access_token.setter
    def personal_access_token(self, value: pulumi.Input[str]):
        pulumi.set(self, "personal_access_token", value)


if not MYPY:
    class ServiceEndpointServiceFabricAzureActiveDirectoryArgsDict(TypedDict):
        password: pulumi.Input[str]
        """
        Password for the Azure Active Directory account.
        """
        server_certificate_lookup: pulumi.Input[str]
        """
        Verification mode for the cluster. Possible values are: `Thumbprint`, `CommonName`.
        """
        username: pulumi.Input[str]
        """
        Specify an Azure Active Directory account.
        """
        server_certificate_common_name: NotRequired[pulumi.Input[str]]
        """
        The common name(s) of the cluster's certificate(s). This is used to verify the identity of the cluster. This value overrides the publish profile. Separate multiple common names with a comma (',')
        """
        server_certificate_thumbprint: NotRequired[pulumi.Input[str]]
        """
        The thumbprint(s) of the cluster's certificate(s). This is used to verify the identity of the cluster. This value overrides the publish profile. Separate multiple thumbprints with a comma (',')
        """
elif False:
    ServiceEndpointServiceFabricAzureActiveDirectoryArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ServiceEndpointServiceFabricAzureActiveDirectoryArgs:
    def __init__(__self__, *,
                 password: pulumi.Input[str],
                 server_certificate_lookup: pulumi.Input[str],
                 username: pulumi.Input[str],
                 server_certificate_common_name: Optional[pulumi.Input[str]] = None,
                 server_certificate_thumbprint: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] password: Password for the Azure Active Directory account.
        :param pulumi.Input[str] server_certificate_lookup: Verification mode for the cluster. Possible values are: `Thumbprint`, `CommonName`.
        :param pulumi.Input[str] username: Specify an Azure Active Directory account.
        :param pulumi.Input[str] server_certificate_common_name: The common name(s) of the cluster's certificate(s). This is used to verify the identity of the cluster. This value overrides the publish profile. Separate multiple common names with a comma (',')
        :param pulumi.Input[str] server_certificate_thumbprint: The thumbprint(s) of the cluster's certificate(s). This is used to verify the identity of the cluster. This value overrides the publish profile. Separate multiple thumbprints with a comma (',')
        """
        pulumi.set(__self__, "password", password)
        pulumi.set(__self__, "server_certificate_lookup", server_certificate_lookup)
        pulumi.set(__self__, "username", username)
        if server_certificate_common_name is not None:
            pulumi.set(__self__, "server_certificate_common_name", server_certificate_common_name)
        if server_certificate_thumbprint is not None:
            pulumi.set(__self__, "server_certificate_thumbprint", server_certificate_thumbprint)

    @property
    @pulumi.getter
    def password(self) -> pulumi.Input[str]:
        """
        Password for the Azure Active Directory account.
        """
        return pulumi.get(self, "password")

    @password.setter
    def password(self, value: pulumi.Input[str]):
        pulumi.set(self, "password", value)

    @property
    @pulumi.getter(name="serverCertificateLookup")
    def server_certificate_lookup(self) -> pulumi.Input[str]:
        """
        Verification mode for the cluster. Possible values are: `Thumbprint`, `CommonName`.
        """
        return pulumi.get(self, "server_certificate_lookup")

    @server_certificate_lookup.setter
    def server_certificate_lookup(self, value: pulumi.Input[str]):
        pulumi.set(self, "server_certificate_lookup", value)

    @property
    @pulumi.getter
    def username(self) -> pulumi.Input[str]:
        """
        Specify an Azure Active Directory account.
        """
        return pulumi.get(self, "username")

    @username.setter
    def username(self, value: pulumi.Input[str]):
        pulumi.set(self, "username", value)

    @property
    @pulumi.getter(name="serverCertificateCommonName")
    def server_certificate_common_name(self) -> Optional[pulumi.Input[str]]:
        """
        The common name(s) of the cluster's certificate(s). This is used to verify the identity of the cluster. This value overrides the publish profile. Separate multiple common names with a comma (',')
        """
        return pulumi.get(self, "server_certificate_common_name")

    @server_certificate_common_name.setter
    def server_certificate_common_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "server_certificate_common_name", value)

    @property
    @pulumi.getter(name="serverCertificateThumbprint")
    def server_certificate_thumbprint(self) -> Optional[pulumi.Input[str]]:
        """
        The thumbprint(s) of the cluster's certificate(s). This is used to verify the identity of the cluster. This value overrides the publish profile. Separate multiple thumbprints with a comma (',')
        """
        return pulumi.get(self, "server_certificate_thumbprint")

    @server_certificate_thumbprint.setter
    def server_certificate_thumbprint(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "server_certificate_thumbprint", value)


if not MYPY:
    class ServiceEndpointServiceFabricCertificateArgsDict(TypedDict):
        client_certificate: pulumi.Input[str]
        """
        Base64 encoding of the cluster's client certificate file.
        """
        server_certificate_lookup: pulumi.Input[str]
        """
        Verification mode for the cluster. Possible values are: `Thumbprint`, `CommonName`.
        """
        client_certificate_password: NotRequired[pulumi.Input[str]]
        """
        Password for the certificate.
        """
        server_certificate_common_name: NotRequired[pulumi.Input[str]]
        """
        The common name(s) of the cluster's certificate(s). This is used to verify the identity of the cluster. This value overrides the publish profile. Separate multiple common names with a comma (',')
        """
        server_certificate_thumbprint: NotRequired[pulumi.Input[str]]
        """
        The thumbprint(s) of the cluster's certificate(s). This is used to verify the identity of the cluster. This value overrides the publish profile. Separate multiple thumbprints with a comma (',')
        """
elif False:
    ServiceEndpointServiceFabricCertificateArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ServiceEndpointServiceFabricCertificateArgs:
    def __init__(__self__, *,
                 client_certificate: pulumi.Input[str],
                 server_certificate_lookup: pulumi.Input[str],
                 client_certificate_password: Optional[pulumi.Input[str]] = None,
                 server_certificate_common_name: Optional[pulumi.Input[str]] = None,
                 server_certificate_thumbprint: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] client_certificate: Base64 encoding of the cluster's client certificate file.
        :param pulumi.Input[str] server_certificate_lookup: Verification mode for the cluster. Possible values are: `Thumbprint`, `CommonName`.
        :param pulumi.Input[str] client_certificate_password: Password for the certificate.
        :param pulumi.Input[str] server_certificate_common_name: The common name(s) of the cluster's certificate(s). This is used to verify the identity of the cluster. This value overrides the publish profile. Separate multiple common names with a comma (',')
        :param pulumi.Input[str] server_certificate_thumbprint: The thumbprint(s) of the cluster's certificate(s). This is used to verify the identity of the cluster. This value overrides the publish profile. Separate multiple thumbprints with a comma (',')
        """
        pulumi.set(__self__, "client_certificate", client_certificate)
        pulumi.set(__self__, "server_certificate_lookup", server_certificate_lookup)
        if client_certificate_password is not None:
            pulumi.set(__self__, "client_certificate_password", client_certificate_password)
        if server_certificate_common_name is not None:
            pulumi.set(__self__, "server_certificate_common_name", server_certificate_common_name)
        if server_certificate_thumbprint is not None:
            pulumi.set(__self__, "server_certificate_thumbprint", server_certificate_thumbprint)

    @property
    @pulumi.getter(name="clientCertificate")
    def client_certificate(self) -> pulumi.Input[str]:
        """
        Base64 encoding of the cluster's client certificate file.
        """
        return pulumi.get(self, "client_certificate")

    @client_certificate.setter
    def client_certificate(self, value: pulumi.Input[str]):
        pulumi.set(self, "client_certificate", value)

    @property
    @pulumi.getter(name="serverCertificateLookup")
    def server_certificate_lookup(self) -> pulumi.Input[str]:
        """
        Verification mode for the cluster. Possible values are: `Thumbprint`, `CommonName`.
        """
        return pulumi.get(self, "server_certificate_lookup")

    @server_certificate_lookup.setter
    def server_certificate_lookup(self, value: pulumi.Input[str]):
        pulumi.set(self, "server_certificate_lookup", value)

    @property
    @pulumi.getter(name="clientCertificatePassword")
    def client_certificate_password(self) -> Optional[pulumi.Input[str]]:
        """
        Password for the certificate.
        """
        return pulumi.get(self, "client_certificate_password")

    @client_certificate_password.setter
    def client_certificate_password(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "client_certificate_password", value)

    @property
    @pulumi.getter(name="serverCertificateCommonName")
    def server_certificate_common_name(self) -> Optional[pulumi.Input[str]]:
        """
        The common name(s) of the cluster's certificate(s). This is used to verify the identity of the cluster. This value overrides the publish profile. Separate multiple common names with a comma (',')
        """
        return pulumi.get(self, "server_certificate_common_name")

    @server_certificate_common_name.setter
    def server_certificate_common_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "server_certificate_common_name", value)

    @property
    @pulumi.getter(name="serverCertificateThumbprint")
    def server_certificate_thumbprint(self) -> Optional[pulumi.Input[str]]:
        """
        The thumbprint(s) of the cluster's certificate(s). This is used to verify the identity of the cluster. This value overrides the publish profile. Separate multiple thumbprints with a comma (',')
        """
        return pulumi.get(self, "server_certificate_thumbprint")

    @server_certificate_thumbprint.setter
    def server_certificate_thumbprint(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "server_certificate_thumbprint", value)


if not MYPY:
    class ServiceEndpointServiceFabricNoneArgsDict(TypedDict):
        cluster_spn: NotRequired[pulumi.Input[str]]
        """
        Fully qualified domain SPN for gMSA account. This is applicable only if `unsecured` option is disabled.
        """
        unsecured: NotRequired[pulumi.Input[bool]]
        """
        Skip using windows security for authentication.
        """
elif False:
    ServiceEndpointServiceFabricNoneArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ServiceEndpointServiceFabricNoneArgs:
    def __init__(__self__, *,
                 cluster_spn: Optional[pulumi.Input[str]] = None,
                 unsecured: Optional[pulumi.Input[bool]] = None):
        """
        :param pulumi.Input[str] cluster_spn: Fully qualified domain SPN for gMSA account. This is applicable only if `unsecured` option is disabled.
        :param pulumi.Input[bool] unsecured: Skip using windows security for authentication.
        """
        if cluster_spn is not None:
            pulumi.set(__self__, "cluster_spn", cluster_spn)
        if unsecured is not None:
            pulumi.set(__self__, "unsecured", unsecured)

    @property
    @pulumi.getter(name="clusterSpn")
    def cluster_spn(self) -> Optional[pulumi.Input[str]]:
        """
        Fully qualified domain SPN for gMSA account. This is applicable only if `unsecured` option is disabled.
        """
        return pulumi.get(self, "cluster_spn")

    @cluster_spn.setter
    def cluster_spn(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "cluster_spn", value)

    @property
    @pulumi.getter
    def unsecured(self) -> Optional[pulumi.Input[bool]]:
        """
        Skip using windows security for authentication.
        """
        return pulumi.get(self, "unsecured")

    @unsecured.setter
    def unsecured(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "unsecured", value)


if not MYPY:
    class ServiceendpointArgocdAuthenticationBasicArgsDict(TypedDict):
        password: pulumi.Input[str]
        """
        The Password of the ArgoCD.
        """
        username: pulumi.Input[str]
        """
        The Username of the ArgoCD.
        """
elif False:
    ServiceendpointArgocdAuthenticationBasicArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ServiceendpointArgocdAuthenticationBasicArgs:
    def __init__(__self__, *,
                 password: pulumi.Input[str],
                 username: pulumi.Input[str]):
        """
        :param pulumi.Input[str] password: The Password of the ArgoCD.
        :param pulumi.Input[str] username: The Username of the ArgoCD.
        """
        pulumi.set(__self__, "password", password)
        pulumi.set(__self__, "username", username)

    @property
    @pulumi.getter
    def password(self) -> pulumi.Input[str]:
        """
        The Password of the ArgoCD.
        """
        return pulumi.get(self, "password")

    @password.setter
    def password(self, value: pulumi.Input[str]):
        pulumi.set(self, "password", value)

    @property
    @pulumi.getter
    def username(self) -> pulumi.Input[str]:
        """
        The Username of the ArgoCD.
        """
        return pulumi.get(self, "username")

    @username.setter
    def username(self, value: pulumi.Input[str]):
        pulumi.set(self, "username", value)


if not MYPY:
    class ServiceendpointArgocdAuthenticationTokenArgsDict(TypedDict):
        token: pulumi.Input[str]
        """
        Authentication Token generated through ArgoCD.
        """
elif False:
    ServiceendpointArgocdAuthenticationTokenArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ServiceendpointArgocdAuthenticationTokenArgs:
    def __init__(__self__, *,
                 token: pulumi.Input[str]):
        """
        :param pulumi.Input[str] token: Authentication Token generated through ArgoCD.
        """
        pulumi.set(__self__, "token", token)

    @property
    @pulumi.getter
    def token(self) -> pulumi.Input[str]:
        """
        Authentication Token generated through ArgoCD.
        """
        return pulumi.get(self, "token")

    @token.setter
    def token(self, value: pulumi.Input[str]):
        pulumi.set(self, "token", value)


if not MYPY:
    class ServiceendpointExternaltfsAuthPersonalArgsDict(TypedDict):
        personal_access_token: pulumi.Input[str]
        """
        The Personal Access Token for Azure DevOps Organization.
        """
elif False:
    ServiceendpointExternaltfsAuthPersonalArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ServiceendpointExternaltfsAuthPersonalArgs:
    def __init__(__self__, *,
                 personal_access_token: pulumi.Input[str]):
        """
        :param pulumi.Input[str] personal_access_token: The Personal Access Token for Azure DevOps Organization.
        """
        pulumi.set(__self__, "personal_access_token", personal_access_token)

    @property
    @pulumi.getter(name="personalAccessToken")
    def personal_access_token(self) -> pulumi.Input[str]:
        """
        The Personal Access Token for Azure DevOps Organization.
        """
        return pulumi.get(self, "personal_access_token")

    @personal_access_token.setter
    def personal_access_token(self, value: pulumi.Input[str]):
        pulumi.set(self, "personal_access_token", value)


if not MYPY:
    class ServiceendpointJfrogArtifactoryV2AuthenticationBasicArgsDict(TypedDict):
        password: pulumi.Input[str]
        """
        The Password of the Artifactory.
        """
        username: pulumi.Input[str]
        """
        The Username of the Artifactory.
        """
elif False:
    ServiceendpointJfrogArtifactoryV2AuthenticationBasicArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ServiceendpointJfrogArtifactoryV2AuthenticationBasicArgs:
    def __init__(__self__, *,
                 password: pulumi.Input[str],
                 username: pulumi.Input[str]):
        """
        :param pulumi.Input[str] password: The Password of the Artifactory.
        :param pulumi.Input[str] username: The Username of the Artifactory.
        """
        pulumi.set(__self__, "password", password)
        pulumi.set(__self__, "username", username)

    @property
    @pulumi.getter
    def password(self) -> pulumi.Input[str]:
        """
        The Password of the Artifactory.
        """
        return pulumi.get(self, "password")

    @password.setter
    def password(self, value: pulumi.Input[str]):
        pulumi.set(self, "password", value)

    @property
    @pulumi.getter
    def username(self) -> pulumi.Input[str]:
        """
        The Username of the Artifactory.
        """
        return pulumi.get(self, "username")

    @username.setter
    def username(self, value: pulumi.Input[str]):
        pulumi.set(self, "username", value)


if not MYPY:
    class ServiceendpointJfrogArtifactoryV2AuthenticationTokenArgsDict(TypedDict):
        token: pulumi.Input[str]
        """
        Authentication Token generated through Artifactory.
        """
elif False:
    ServiceendpointJfrogArtifactoryV2AuthenticationTokenArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ServiceendpointJfrogArtifactoryV2AuthenticationTokenArgs:
    def __init__(__self__, *,
                 token: pulumi.Input[str]):
        """
        :param pulumi.Input[str] token: Authentication Token generated through Artifactory.
        """
        pulumi.set(__self__, "token", token)

    @property
    @pulumi.getter
    def token(self) -> pulumi.Input[str]:
        """
        Authentication Token generated through Artifactory.
        """
        return pulumi.get(self, "token")

    @token.setter
    def token(self, value: pulumi.Input[str]):
        pulumi.set(self, "token", value)


if not MYPY:
    class ServiceendpointJfrogDistributionV2AuthenticationBasicArgsDict(TypedDict):
        password: pulumi.Input[str]
        """
        The Password of the Artifactory.
        """
        username: pulumi.Input[str]
        """
        The Username of the Artifactory.
        """
elif False:
    ServiceendpointJfrogDistributionV2AuthenticationBasicArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ServiceendpointJfrogDistributionV2AuthenticationBasicArgs:
    def __init__(__self__, *,
                 password: pulumi.Input[str],
                 username: pulumi.Input[str]):
        """
        :param pulumi.Input[str] password: The Password of the Artifactory.
        :param pulumi.Input[str] username: The Username of the Artifactory.
        """
        pulumi.set(__self__, "password", password)
        pulumi.set(__self__, "username", username)

    @property
    @pulumi.getter
    def password(self) -> pulumi.Input[str]:
        """
        The Password of the Artifactory.
        """
        return pulumi.get(self, "password")

    @password.setter
    def password(self, value: pulumi.Input[str]):
        pulumi.set(self, "password", value)

    @property
    @pulumi.getter
    def username(self) -> pulumi.Input[str]:
        """
        The Username of the Artifactory.
        """
        return pulumi.get(self, "username")

    @username.setter
    def username(self, value: pulumi.Input[str]):
        pulumi.set(self, "username", value)


if not MYPY:
    class ServiceendpointJfrogDistributionV2AuthenticationTokenArgsDict(TypedDict):
        token: pulumi.Input[str]
        """
        The Authentication Token generated through Artifactory.
        """
elif False:
    ServiceendpointJfrogDistributionV2AuthenticationTokenArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ServiceendpointJfrogDistributionV2AuthenticationTokenArgs:
    def __init__(__self__, *,
                 token: pulumi.Input[str]):
        """
        :param pulumi.Input[str] token: The Authentication Token generated through Artifactory.
        """
        pulumi.set(__self__, "token", token)

    @property
    @pulumi.getter
    def token(self) -> pulumi.Input[str]:
        """
        The Authentication Token generated through Artifactory.
        """
        return pulumi.get(self, "token")

    @token.setter
    def token(self, value: pulumi.Input[str]):
        pulumi.set(self, "token", value)


if not MYPY:
    class ServiceendpointJfrogPlatformV2AuthenticationBasicArgsDict(TypedDict):
        password: pulumi.Input[str]
        """
        The Password of the Artifactory.
        """
        username: pulumi.Input[str]
        """
        The Username of the  Artifactory.
        """
elif False:
    ServiceendpointJfrogPlatformV2AuthenticationBasicArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ServiceendpointJfrogPlatformV2AuthenticationBasicArgs:
    def __init__(__self__, *,
                 password: pulumi.Input[str],
                 username: pulumi.Input[str]):
        """
        :param pulumi.Input[str] password: The Password of the Artifactory.
        :param pulumi.Input[str] username: The Username of the  Artifactory.
        """
        pulumi.set(__self__, "password", password)
        pulumi.set(__self__, "username", username)

    @property
    @pulumi.getter
    def password(self) -> pulumi.Input[str]:
        """
        The Password of the Artifactory.
        """
        return pulumi.get(self, "password")

    @password.setter
    def password(self, value: pulumi.Input[str]):
        pulumi.set(self, "password", value)

    @property
    @pulumi.getter
    def username(self) -> pulumi.Input[str]:
        """
        The Username of the  Artifactory.
        """
        return pulumi.get(self, "username")

    @username.setter
    def username(self, value: pulumi.Input[str]):
        pulumi.set(self, "username", value)


if not MYPY:
    class ServiceendpointJfrogPlatformV2AuthenticationTokenArgsDict(TypedDict):
        token: pulumi.Input[str]
        """
        Authentication Token generated through Artifactory.
        """
elif False:
    ServiceendpointJfrogPlatformV2AuthenticationTokenArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ServiceendpointJfrogPlatformV2AuthenticationTokenArgs:
    def __init__(__self__, *,
                 token: pulumi.Input[str]):
        """
        :param pulumi.Input[str] token: Authentication Token generated through Artifactory.
        """
        pulumi.set(__self__, "token", token)

    @property
    @pulumi.getter
    def token(self) -> pulumi.Input[str]:
        """
        Authentication Token generated through Artifactory.
        """
        return pulumi.get(self, "token")

    @token.setter
    def token(self, value: pulumi.Input[str]):
        pulumi.set(self, "token", value)


if not MYPY:
    class ServiceendpointJfrogXrayV2AuthenticationBasicArgsDict(TypedDict):
        password: pulumi.Input[str]
        """
        The Password of the Artifactory.
        """
        username: pulumi.Input[str]
        """
        The Username of the  Artifactory.
        """
elif False:
    ServiceendpointJfrogXrayV2AuthenticationBasicArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ServiceendpointJfrogXrayV2AuthenticationBasicArgs:
    def __init__(__self__, *,
                 password: pulumi.Input[str],
                 username: pulumi.Input[str]):
        """
        :param pulumi.Input[str] password: The Password of the Artifactory.
        :param pulumi.Input[str] username: The Username of the  Artifactory.
        """
        pulumi.set(__self__, "password", password)
        pulumi.set(__self__, "username", username)

    @property
    @pulumi.getter
    def password(self) -> pulumi.Input[str]:
        """
        The Password of the Artifactory.
        """
        return pulumi.get(self, "password")

    @password.setter
    def password(self, value: pulumi.Input[str]):
        pulumi.set(self, "password", value)

    @property
    @pulumi.getter
    def username(self) -> pulumi.Input[str]:
        """
        The Username of the  Artifactory.
        """
        return pulumi.get(self, "username")

    @username.setter
    def username(self, value: pulumi.Input[str]):
        pulumi.set(self, "username", value)


if not MYPY:
    class ServiceendpointJfrogXrayV2AuthenticationTokenArgsDict(TypedDict):
        token: pulumi.Input[str]
        """
        Authentication Token generated through Artifactory.
        """
elif False:
    ServiceendpointJfrogXrayV2AuthenticationTokenArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ServiceendpointJfrogXrayV2AuthenticationTokenArgs:
    def __init__(__self__, *,
                 token: pulumi.Input[str]):
        """
        :param pulumi.Input[str] token: Authentication Token generated through Artifactory.
        """
        pulumi.set(__self__, "token", token)

    @property
    @pulumi.getter
    def token(self) -> pulumi.Input[str]:
        """
        Authentication Token generated through Artifactory.
        """
        return pulumi.get(self, "token")

    @token.setter
    def token(self, value: pulumi.Input[str]):
        pulumi.set(self, "token", value)


if not MYPY:
    class ServiceendpointMavenAuthenticationBasicArgsDict(TypedDict):
        password: pulumi.Input[str]
        """
        The password Maven Repository.
        """
        username: pulumi.Input[str]
        """
        The Username of the Maven Repository.
        """
elif False:
    ServiceendpointMavenAuthenticationBasicArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ServiceendpointMavenAuthenticationBasicArgs:
    def __init__(__self__, *,
                 password: pulumi.Input[str],
                 username: pulumi.Input[str]):
        """
        :param pulumi.Input[str] password: The password Maven Repository.
        :param pulumi.Input[str] username: The Username of the Maven Repository.
        """
        pulumi.set(__self__, "password", password)
        pulumi.set(__self__, "username", username)

    @property
    @pulumi.getter
    def password(self) -> pulumi.Input[str]:
        """
        The password Maven Repository.
        """
        return pulumi.get(self, "password")

    @password.setter
    def password(self, value: pulumi.Input[str]):
        pulumi.set(self, "password", value)

    @property
    @pulumi.getter
    def username(self) -> pulumi.Input[str]:
        """
        The Username of the Maven Repository.
        """
        return pulumi.get(self, "username")

    @username.setter
    def username(self, value: pulumi.Input[str]):
        pulumi.set(self, "username", value)


if not MYPY:
    class ServiceendpointMavenAuthenticationTokenArgsDict(TypedDict):
        token: pulumi.Input[str]
        """
        Authentication Token generated through maven repository.
        """
elif False:
    ServiceendpointMavenAuthenticationTokenArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ServiceendpointMavenAuthenticationTokenArgs:
    def __init__(__self__, *,
                 token: pulumi.Input[str]):
        """
        :param pulumi.Input[str] token: Authentication Token generated through maven repository.
        """
        pulumi.set(__self__, "token", token)

    @property
    @pulumi.getter
    def token(self) -> pulumi.Input[str]:
        """
        Authentication Token generated through maven repository.
        """
        return pulumi.get(self, "token")

    @token.setter
    def token(self, value: pulumi.Input[str]):
        pulumi.set(self, "token", value)


if not MYPY:
    class ServiceendpointVisualstudiomarketplaceAuthenticationBasicArgsDict(TypedDict):
        password: pulumi.Input[str]
        """
        The password of the marketplace.
        """
        username: pulumi.Input[str]
        """
        The username of the marketplace.
        """
elif False:
    ServiceendpointVisualstudiomarketplaceAuthenticationBasicArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ServiceendpointVisualstudiomarketplaceAuthenticationBasicArgs:
    def __init__(__self__, *,
                 password: pulumi.Input[str],
                 username: pulumi.Input[str]):
        """
        :param pulumi.Input[str] password: The password of the marketplace.
        :param pulumi.Input[str] username: The username of the marketplace.
        """
        pulumi.set(__self__, "password", password)
        pulumi.set(__self__, "username", username)

    @property
    @pulumi.getter
    def password(self) -> pulumi.Input[str]:
        """
        The password of the marketplace.
        """
        return pulumi.get(self, "password")

    @password.setter
    def password(self, value: pulumi.Input[str]):
        pulumi.set(self, "password", value)

    @property
    @pulumi.getter
    def username(self) -> pulumi.Input[str]:
        """
        The username of the marketplace.
        """
        return pulumi.get(self, "username")

    @username.setter
    def username(self, value: pulumi.Input[str]):
        pulumi.set(self, "username", value)


if not MYPY:
    class ServiceendpointVisualstudiomarketplaceAuthenticationTokenArgsDict(TypedDict):
        token: pulumi.Input[str]
        """
        The Personal Access Token.
        """
elif False:
    ServiceendpointVisualstudiomarketplaceAuthenticationTokenArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ServiceendpointVisualstudiomarketplaceAuthenticationTokenArgs:
    def __init__(__self__, *,
                 token: pulumi.Input[str]):
        """
        :param pulumi.Input[str] token: The Personal Access Token.
        """
        pulumi.set(__self__, "token", token)

    @property
    @pulumi.getter
    def token(self) -> pulumi.Input[str]:
        """
        The Personal Access Token.
        """
        return pulumi.get(self, "token")

    @token.setter
    def token(self, value: pulumi.Input[str]):
        pulumi.set(self, "token", value)


if not MYPY:
    class ServicehookStorageQueuePipelinesRunStateChangedEventArgsDict(TypedDict):
        pipeline_id: NotRequired[pulumi.Input[str]]
        """
        The pipeline ID that will generate an event. If not specified, all pipelines in the project will trigger the event.
        """
        run_result_filter: NotRequired[pulumi.Input[str]]
        """
        Which run result should generate an event. Only valid if published_event is `RunStateChanged`. If not specified, all results will trigger the event.
        """
        run_state_filter: NotRequired[pulumi.Input[str]]
        """
        Which run state should generate an event. Only valid if published_event is `RunStateChanged`. If not specified, all states will trigger the event.
        """
elif False:
    ServicehookStorageQueuePipelinesRunStateChangedEventArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ServicehookStorageQueuePipelinesRunStateChangedEventArgs:
    def __init__(__self__, *,
                 pipeline_id: Optional[pulumi.Input[str]] = None,
                 run_result_filter: Optional[pulumi.Input[str]] = None,
                 run_state_filter: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] pipeline_id: The pipeline ID that will generate an event. If not specified, all pipelines in the project will trigger the event.
        :param pulumi.Input[str] run_result_filter: Which run result should generate an event. Only valid if published_event is `RunStateChanged`. If not specified, all results will trigger the event.
        :param pulumi.Input[str] run_state_filter: Which run state should generate an event. Only valid if published_event is `RunStateChanged`. If not specified, all states will trigger the event.
        """
        if pipeline_id is not None:
            pulumi.set(__self__, "pipeline_id", pipeline_id)
        if run_result_filter is not None:
            pulumi.set(__self__, "run_result_filter", run_result_filter)
        if run_state_filter is not None:
            pulumi.set(__self__, "run_state_filter", run_state_filter)

    @property
    @pulumi.getter(name="pipelineId")
    def pipeline_id(self) -> Optional[pulumi.Input[str]]:
        """
        The pipeline ID that will generate an event. If not specified, all pipelines in the project will trigger the event.
        """
        return pulumi.get(self, "pipeline_id")

    @pipeline_id.setter
    def pipeline_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "pipeline_id", value)

    @property
    @pulumi.getter(name="runResultFilter")
    def run_result_filter(self) -> Optional[pulumi.Input[str]]:
        """
        Which run result should generate an event. Only valid if published_event is `RunStateChanged`. If not specified, all results will trigger the event.
        """
        return pulumi.get(self, "run_result_filter")

    @run_result_filter.setter
    def run_result_filter(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "run_result_filter", value)

    @property
    @pulumi.getter(name="runStateFilter")
    def run_state_filter(self) -> Optional[pulumi.Input[str]]:
        """
        Which run state should generate an event. Only valid if published_event is `RunStateChanged`. If not specified, all states will trigger the event.
        """
        return pulumi.get(self, "run_state_filter")

    @run_state_filter.setter
    def run_state_filter(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "run_state_filter", value)


if not MYPY:
    class ServicehookStorageQueuePipelinesStageStateChangedEventArgsDict(TypedDict):
        pipeline_id: NotRequired[pulumi.Input[str]]
        """
        The pipeline ID that will generate an event.
        """
        stage_name: NotRequired[pulumi.Input[str]]
        """
        Which stage should generate an event. Only valid if published_event is `StageStateChanged`. If not specified, all stages will trigger the event.
        """
        stage_result_filter: NotRequired[pulumi.Input[str]]
        """
        Which stage result should generate an event. Only valid if published_event is `StageStateChanged`. If not specified, all results will trigger the event.
        """
        stage_state_filter: NotRequired[pulumi.Input[str]]
        """
        Which stage state should generate an event. Only valid if published_event is `StageStateChanged`. If not specified, all states will trigger the event.
        """
elif False:
    ServicehookStorageQueuePipelinesStageStateChangedEventArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ServicehookStorageQueuePipelinesStageStateChangedEventArgs:
    def __init__(__self__, *,
                 pipeline_id: Optional[pulumi.Input[str]] = None,
                 stage_name: Optional[pulumi.Input[str]] = None,
                 stage_result_filter: Optional[pulumi.Input[str]] = None,
                 stage_state_filter: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] pipeline_id: The pipeline ID that will generate an event.
        :param pulumi.Input[str] stage_name: Which stage should generate an event. Only valid if published_event is `StageStateChanged`. If not specified, all stages will trigger the event.
        :param pulumi.Input[str] stage_result_filter: Which stage result should generate an event. Only valid if published_event is `StageStateChanged`. If not specified, all results will trigger the event.
        :param pulumi.Input[str] stage_state_filter: Which stage state should generate an event. Only valid if published_event is `StageStateChanged`. If not specified, all states will trigger the event.
        """
        if pipeline_id is not None:
            pulumi.set(__self__, "pipeline_id", pipeline_id)
        if stage_name is not None:
            pulumi.set(__self__, "stage_name", stage_name)
        if stage_result_filter is not None:
            pulumi.set(__self__, "stage_result_filter", stage_result_filter)
        if stage_state_filter is not None:
            pulumi.set(__self__, "stage_state_filter", stage_state_filter)

    @property
    @pulumi.getter(name="pipelineId")
    def pipeline_id(self) -> Optional[pulumi.Input[str]]:
        """
        The pipeline ID that will generate an event.
        """
        return pulumi.get(self, "pipeline_id")

    @pipeline_id.setter
    def pipeline_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "pipeline_id", value)

    @property
    @pulumi.getter(name="stageName")
    def stage_name(self) -> Optional[pulumi.Input[str]]:
        """
        Which stage should generate an event. Only valid if published_event is `StageStateChanged`. If not specified, all stages will trigger the event.
        """
        return pulumi.get(self, "stage_name")

    @stage_name.setter
    def stage_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "stage_name", value)

    @property
    @pulumi.getter(name="stageResultFilter")
    def stage_result_filter(self) -> Optional[pulumi.Input[str]]:
        """
        Which stage result should generate an event. Only valid if published_event is `StageStateChanged`. If not specified, all results will trigger the event.
        """
        return pulumi.get(self, "stage_result_filter")

    @stage_result_filter.setter
    def stage_result_filter(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "stage_result_filter", value)

    @property
    @pulumi.getter(name="stageStateFilter")
    def stage_state_filter(self) -> Optional[pulumi.Input[str]]:
        """
        Which stage state should generate an event. Only valid if published_event is `StageStateChanged`. If not specified, all states will trigger the event.
        """
        return pulumi.get(self, "stage_state_filter")

    @stage_state_filter.setter
    def stage_state_filter(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "stage_state_filter", value)


if not MYPY:
    class VariableGroupKeyVaultArgsDict(TypedDict):
        name: pulumi.Input[str]
        """
        The name of the Azure key vault to link secrets from as variables.
        """
        service_endpoint_id: pulumi.Input[str]
        """
        The id of the Azure subscription endpoint to access the key vault.
        """
        search_depth: NotRequired[pulumi.Input[int]]
        """
        Set the Azure Key Vault Secret search depth. Defaults to `20`.
        """
elif False:
    VariableGroupKeyVaultArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class VariableGroupKeyVaultArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[str],
                 service_endpoint_id: pulumi.Input[str],
                 search_depth: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input[str] name: The name of the Azure key vault to link secrets from as variables.
        :param pulumi.Input[str] service_endpoint_id: The id of the Azure subscription endpoint to access the key vault.
        :param pulumi.Input[int] search_depth: Set the Azure Key Vault Secret search depth. Defaults to `20`.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "service_endpoint_id", service_endpoint_id)
        if search_depth is not None:
            pulumi.set(__self__, "search_depth", search_depth)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        The name of the Azure key vault to link secrets from as variables.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter(name="serviceEndpointId")
    def service_endpoint_id(self) -> pulumi.Input[str]:
        """
        The id of the Azure subscription endpoint to access the key vault.
        """
        return pulumi.get(self, "service_endpoint_id")

    @service_endpoint_id.setter
    def service_endpoint_id(self, value: pulumi.Input[str]):
        pulumi.set(self, "service_endpoint_id", value)

    @property
    @pulumi.getter(name="searchDepth")
    def search_depth(self) -> Optional[pulumi.Input[int]]:
        """
        Set the Azure Key Vault Secret search depth. Defaults to `20`.
        """
        return pulumi.get(self, "search_depth")

    @search_depth.setter
    def search_depth(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "search_depth", value)


if not MYPY:
    class VariableGroupVariableArgsDict(TypedDict):
        name: pulumi.Input[str]
        """
        The key value used for the variable. Must be unique within the Variable Group.
        """
        content_type: NotRequired[pulumi.Input[str]]
        enabled: NotRequired[pulumi.Input[bool]]
        expires: NotRequired[pulumi.Input[str]]
        is_secret: NotRequired[pulumi.Input[bool]]
        """
        A boolean flag describing if the variable value is sensitive. Defaults to `false`.
        """
        secret_value: NotRequired[pulumi.Input[str]]
        """
        The secret value of the variable. If omitted, it will default to empty string. Used when `is_secret` set to `true`.
        """
        value: NotRequired[pulumi.Input[str]]
        """
        The value of the variable. If omitted, it will default to empty string.
        """
elif False:
    VariableGroupVariableArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class VariableGroupVariableArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[str],
                 content_type: Optional[pulumi.Input[str]] = None,
                 enabled: Optional[pulumi.Input[bool]] = None,
                 expires: Optional[pulumi.Input[str]] = None,
                 is_secret: Optional[pulumi.Input[bool]] = None,
                 secret_value: Optional[pulumi.Input[str]] = None,
                 value: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] name: The key value used for the variable. Must be unique within the Variable Group.
        :param pulumi.Input[bool] is_secret: A boolean flag describing if the variable value is sensitive. Defaults to `false`.
        :param pulumi.Input[str] secret_value: The secret value of the variable. If omitted, it will default to empty string. Used when `is_secret` set to `true`.
        :param pulumi.Input[str] value: The value of the variable. If omitted, it will default to empty string.
        """
        pulumi.set(__self__, "name", name)
        if content_type is not None:
            pulumi.set(__self__, "content_type", content_type)
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if expires is not None:
            pulumi.set(__self__, "expires", expires)
        if is_secret is not None:
            pulumi.set(__self__, "is_secret", is_secret)
        if secret_value is not None:
            pulumi.set(__self__, "secret_value", secret_value)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        The key value used for the variable. Must be unique within the Variable Group.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter(name="contentType")
    def content_type(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "content_type")

    @content_type.setter
    def content_type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "content_type", value)

    @property
    @pulumi.getter
    def enabled(self) -> Optional[pulumi.Input[bool]]:
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "enabled", value)

    @property
    @pulumi.getter
    def expires(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "expires")

    @expires.setter
    def expires(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "expires", value)

    @property
    @pulumi.getter(name="isSecret")
    def is_secret(self) -> Optional[pulumi.Input[bool]]:
        """
        A boolean flag describing if the variable value is sensitive. Defaults to `false`.
        """
        return pulumi.get(self, "is_secret")

    @is_secret.setter
    def is_secret(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "is_secret", value)

    @property
    @pulumi.getter(name="secretValue")
    def secret_value(self) -> Optional[pulumi.Input[str]]:
        """
        The secret value of the variable. If omitted, it will default to empty string. Used when `is_secret` set to `true`.
        """
        return pulumi.get(self, "secret_value")

    @secret_value.setter
    def secret_value(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "secret_value", value)

    @property
    @pulumi.getter
    def value(self) -> Optional[pulumi.Input[str]]:
        """
        The value of the variable. If omitted, it will default to empty string.
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "value", value)


if not MYPY:
    class GetUsersFeaturesArgsDict(TypedDict):
        concurrent_workers: NotRequired[int]
        """
        Number of workers to process user data concurrently.

        > **Note** Setting `concurrent_workers` to a value greater than 1 can greatly decrease the time it takes to read the data source.
        """
elif False:
    GetUsersFeaturesArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetUsersFeaturesArgs:
    def __init__(__self__, *,
                 concurrent_workers: Optional[int] = None):
        """
        :param int concurrent_workers: Number of workers to process user data concurrently.
               
               > **Note** Setting `concurrent_workers` to a value greater than 1 can greatly decrease the time it takes to read the data source.
        """
        if concurrent_workers is not None:
            pulumi.set(__self__, "concurrent_workers", concurrent_workers)

    @property
    @pulumi.getter(name="concurrentWorkers")
    def concurrent_workers(self) -> Optional[int]:
        """
        Number of workers to process user data concurrently.

        > **Note** Setting `concurrent_workers` to a value greater than 1 can greatly decrease the time it takes to read the data source.
        """
        return pulumi.get(self, "concurrent_workers")

    @concurrent_workers.setter
    def concurrent_workers(self, value: Optional[int]):
        pulumi.set(self, "concurrent_workers", value)


