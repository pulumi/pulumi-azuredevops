# coding=utf-8
# *** WARNING: this file was generated by the Pulumi Terraform Bridge (tfgen) Tool. ***
# *** Do not edit by hand unless you're certain you know what you are doing! ***

import copy
import warnings
import pulumi
import pulumi.runtime
from typing import Any, Mapping, Optional, Sequence, Union, overload
from . import _utilities

__all__ = [
    'BranchPolicyAutoReviewersSettingsArgs',
    'BranchPolicyAutoReviewersSettingsScopeArgs',
    'BranchPolicyBuildValidationSettingsArgs',
    'BranchPolicyBuildValidationSettingsScopeArgs',
    'BranchPolicyCommentResolutionSettingsArgs',
    'BranchPolicyCommentResolutionSettingsScopeArgs',
    'BranchPolicyMergeTypesSettingsArgs',
    'BranchPolicyMergeTypesSettingsScopeArgs',
    'BranchPolicyMinReviewersSettingsArgs',
    'BranchPolicyMinReviewersSettingsScopeArgs',
    'BranchPolicyStatusCheckSettingsArgs',
    'BranchPolicyStatusCheckSettingsScopeArgs',
    'BranchPolicyWorkItemLinkingSettingsArgs',
    'BranchPolicyWorkItemLinkingSettingsScopeArgs',
    'BuildDefinitionCiTriggerArgs',
    'BuildDefinitionCiTriggerOverrideArgs',
    'BuildDefinitionCiTriggerOverrideBranchFilterArgs',
    'BuildDefinitionCiTriggerOverridePathFilterArgs',
    'BuildDefinitionFeatureArgs',
    'BuildDefinitionPullRequestTriggerArgs',
    'BuildDefinitionPullRequestTriggerForksArgs',
    'BuildDefinitionPullRequestTriggerOverrideArgs',
    'BuildDefinitionPullRequestTriggerOverrideBranchFilterArgs',
    'BuildDefinitionPullRequestTriggerOverridePathFilterArgs',
    'BuildDefinitionRepositoryArgs',
    'BuildDefinitionScheduleArgs',
    'BuildDefinitionScheduleBranchFilterArgs',
    'BuildDefinitionVariableArgs',
    'CheckRequiredTemplateRequiredTemplateArgs',
    'GitInitializationArgs',
    'ServiceEndpointArtifactoryAuthenticationBasicArgs',
    'ServiceEndpointArtifactoryAuthenticationTokenArgs',
    'ServiceEndpointAzureRMCredentialsArgs',
    'ServiceEndpointGitHubAuthOauthArgs',
    'ServiceEndpointGitHubAuthPersonalArgs',
    'ServiceEndpointGitHubEnterpriseAuthPersonalArgs',
    'ServiceEndpointKubernetesAzureSubscriptionArgs',
    'ServiceEndpointKubernetesKubeconfigArgs',
    'ServiceEndpointKubernetesServiceAccountArgs',
    'ServiceEndpointPipelineAuthPersonalArgs',
    'ServiceEndpointServiceFabricAzureActiveDirectoryArgs',
    'ServiceEndpointServiceFabricCertificateArgs',
    'ServiceEndpointServiceFabricNoneArgs',
    'ServiceendpointArgocdAuthenticationBasicArgs',
    'ServiceendpointArgocdAuthenticationTokenArgs',
    'ServiceendpointExternaltfsAuthPersonalArgs',
    'ServiceendpointJfrogArtifactoryV2AuthenticationBasicArgs',
    'ServiceendpointJfrogArtifactoryV2AuthenticationTokenArgs',
    'ServiceendpointJfrogDistributionV2AuthenticationBasicArgs',
    'ServiceendpointJfrogDistributionV2AuthenticationTokenArgs',
    'ServiceendpointJfrogPlatformV2AuthenticationBasicArgs',
    'ServiceendpointJfrogPlatformV2AuthenticationTokenArgs',
    'ServiceendpointJfrogXrayV2AuthenticationBasicArgs',
    'ServiceendpointJfrogXrayV2AuthenticationTokenArgs',
    'ServiceendpointMavenAuthenticationBasicArgs',
    'ServiceendpointMavenAuthenticationTokenArgs',
    'VariableGroupKeyVaultArgs',
    'VariableGroupVariableArgs',
]

@pulumi.input_type
class BranchPolicyAutoReviewersSettingsArgs:
    def __init__(__self__, *,
                 auto_reviewer_ids: pulumi.Input[Sequence[pulumi.Input[str]]],
                 scopes: pulumi.Input[Sequence[pulumi.Input['BranchPolicyAutoReviewersSettingsScopeArgs']]],
                 message: Optional[pulumi.Input[str]] = None,
                 minimum_number_of_reviewers: Optional[pulumi.Input[int]] = None,
                 path_filters: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 submitter_can_vote: Optional[pulumi.Input[bool]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input[str]]] auto_reviewer_ids: Required reviewers ids. Supports multiples user Ids.
        :param pulumi.Input[Sequence[pulumi.Input['BranchPolicyAutoReviewersSettingsScopeArgs']]] scopes: Controls which repositories and branches the policy will be enabled for. This block must be defined at least once.
        :param pulumi.Input[str] message: Activity feed message, Message will appear in the activity feed of pull requests with automatically added reviewers.
        :param pulumi.Input[int] minimum_number_of_reviewers: Minimum number of required reviewers. Defaults to `1`.
               
               > **Note** Has to be greater than `0`. Can only be greater than `1` when attribute `auto_reviewer_ids` contains exactly one group! Only has an effect when attribute `blocking` is set to `true`.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] path_filters: Filter path(s) on which the policy is applied. Supports absolute paths, wildcards and multiple paths. Example: /WebApp/Models/Data.cs, /WebApp/* or *.cs,/WebApp/Models/Data.cs;ClientApp/Models/Data.cs.
        :param pulumi.Input[bool] submitter_can_vote: Controls whether or not the submitter's vote counts. Defaults to `false`.
        """
        pulumi.set(__self__, "auto_reviewer_ids", auto_reviewer_ids)
        pulumi.set(__self__, "scopes", scopes)
        if message is not None:
            pulumi.set(__self__, "message", message)
        if minimum_number_of_reviewers is not None:
            pulumi.set(__self__, "minimum_number_of_reviewers", minimum_number_of_reviewers)
        if path_filters is not None:
            pulumi.set(__self__, "path_filters", path_filters)
        if submitter_can_vote is not None:
            pulumi.set(__self__, "submitter_can_vote", submitter_can_vote)

    @property
    @pulumi.getter(name="autoReviewerIds")
    def auto_reviewer_ids(self) -> pulumi.Input[Sequence[pulumi.Input[str]]]:
        """
        Required reviewers ids. Supports multiples user Ids.
        """
        return pulumi.get(self, "auto_reviewer_ids")

    @auto_reviewer_ids.setter
    def auto_reviewer_ids(self, value: pulumi.Input[Sequence[pulumi.Input[str]]]):
        pulumi.set(self, "auto_reviewer_ids", value)

    @property
    @pulumi.getter
    def scopes(self) -> pulumi.Input[Sequence[pulumi.Input['BranchPolicyAutoReviewersSettingsScopeArgs']]]:
        """
        Controls which repositories and branches the policy will be enabled for. This block must be defined at least once.
        """
        return pulumi.get(self, "scopes")

    @scopes.setter
    def scopes(self, value: pulumi.Input[Sequence[pulumi.Input['BranchPolicyAutoReviewersSettingsScopeArgs']]]):
        pulumi.set(self, "scopes", value)

    @property
    @pulumi.getter
    def message(self) -> Optional[pulumi.Input[str]]:
        """
        Activity feed message, Message will appear in the activity feed of pull requests with automatically added reviewers.
        """
        return pulumi.get(self, "message")

    @message.setter
    def message(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "message", value)

    @property
    @pulumi.getter(name="minimumNumberOfReviewers")
    def minimum_number_of_reviewers(self) -> Optional[pulumi.Input[int]]:
        """
        Minimum number of required reviewers. Defaults to `1`.

        > **Note** Has to be greater than `0`. Can only be greater than `1` when attribute `auto_reviewer_ids` contains exactly one group! Only has an effect when attribute `blocking` is set to `true`.
        """
        return pulumi.get(self, "minimum_number_of_reviewers")

    @minimum_number_of_reviewers.setter
    def minimum_number_of_reviewers(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "minimum_number_of_reviewers", value)

    @property
    @pulumi.getter(name="pathFilters")
    def path_filters(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Filter path(s) on which the policy is applied. Supports absolute paths, wildcards and multiple paths. Example: /WebApp/Models/Data.cs, /WebApp/* or *.cs,/WebApp/Models/Data.cs;ClientApp/Models/Data.cs.
        """
        return pulumi.get(self, "path_filters")

    @path_filters.setter
    def path_filters(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "path_filters", value)

    @property
    @pulumi.getter(name="submitterCanVote")
    def submitter_can_vote(self) -> Optional[pulumi.Input[bool]]:
        """
        Controls whether or not the submitter's vote counts. Defaults to `false`.
        """
        return pulumi.get(self, "submitter_can_vote")

    @submitter_can_vote.setter
    def submitter_can_vote(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "submitter_can_vote", value)


@pulumi.input_type
class BranchPolicyAutoReviewersSettingsScopeArgs:
    def __init__(__self__, *,
                 match_type: Optional[pulumi.Input[str]] = None,
                 repository_id: Optional[pulumi.Input[str]] = None,
                 repository_ref: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] match_type: The match type to use when applying the policy. Supported values are `Exact` (default), `Prefix` or `DefaultBranch`.
        :param pulumi.Input[str] repository_id: The repository ID. Needed only if the scope of the policy will be limited to a single repository. If `match_type` is `DefaultBranch`, this should not be defined.
        :param pulumi.Input[str] repository_ref: The ref pattern to use for the match when `match_type` other than `DefaultBranch`. If `match_type` is `Exact`, this should be a qualified ref such as `refs/heads/master`. If `match_type` is `Prefix`, this should be a ref path such as `refs/heads/releases`.
        """
        if match_type is not None:
            pulumi.set(__self__, "match_type", match_type)
        if repository_id is not None:
            pulumi.set(__self__, "repository_id", repository_id)
        if repository_ref is not None:
            pulumi.set(__self__, "repository_ref", repository_ref)

    @property
    @pulumi.getter(name="matchType")
    def match_type(self) -> Optional[pulumi.Input[str]]:
        """
        The match type to use when applying the policy. Supported values are `Exact` (default), `Prefix` or `DefaultBranch`.
        """
        return pulumi.get(self, "match_type")

    @match_type.setter
    def match_type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "match_type", value)

    @property
    @pulumi.getter(name="repositoryId")
    def repository_id(self) -> Optional[pulumi.Input[str]]:
        """
        The repository ID. Needed only if the scope of the policy will be limited to a single repository. If `match_type` is `DefaultBranch`, this should not be defined.
        """
        return pulumi.get(self, "repository_id")

    @repository_id.setter
    def repository_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "repository_id", value)

    @property
    @pulumi.getter(name="repositoryRef")
    def repository_ref(self) -> Optional[pulumi.Input[str]]:
        """
        The ref pattern to use for the match when `match_type` other than `DefaultBranch`. If `match_type` is `Exact`, this should be a qualified ref such as `refs/heads/master`. If `match_type` is `Prefix`, this should be a ref path such as `refs/heads/releases`.
        """
        return pulumi.get(self, "repository_ref")

    @repository_ref.setter
    def repository_ref(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "repository_ref", value)


@pulumi.input_type
class BranchPolicyBuildValidationSettingsArgs:
    def __init__(__self__, *,
                 build_definition_id: pulumi.Input[int],
                 display_name: pulumi.Input[str],
                 scopes: pulumi.Input[Sequence[pulumi.Input['BranchPolicyBuildValidationSettingsScopeArgs']]],
                 filename_patterns: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 manual_queue_only: Optional[pulumi.Input[bool]] = None,
                 queue_on_source_update_only: Optional[pulumi.Input[bool]] = None,
                 valid_duration: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input[int] build_definition_id: The ID of the build to monitor for the policy.
        :param pulumi.Input[str] display_name: The display name for the policy.
        :param pulumi.Input[Sequence[pulumi.Input['BranchPolicyBuildValidationSettingsScopeArgs']]] scopes: Controls which repositories and branches the policy will be enabled for. This block must be defined at least once.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] filename_patterns: If a path filter is set, the policy will only apply when files which match the filter are changes. Not setting this field means that the policy will always apply. You can specify absolute paths and wildcards. Example: `["/WebApp/Models/Data.cs", "/WebApp/*", "*.cs"]`. Paths prefixed with "!" are excluded. Example: `["/WebApp/*", "!/WebApp/Tests/*"]`. Order is significant.
        :param pulumi.Input[bool] manual_queue_only: If set to true, the build will need to be manually queued. Defaults to `false`
        :param pulumi.Input[bool] queue_on_source_update_only: True if the build should queue on source updates only. Defaults to `true`.
        :param pulumi.Input[int] valid_duration: The number of minutes for which the build is valid. If `0`, the build will not expire. Defaults to `720` (12 hours).
        """
        pulumi.set(__self__, "build_definition_id", build_definition_id)
        pulumi.set(__self__, "display_name", display_name)
        pulumi.set(__self__, "scopes", scopes)
        if filename_patterns is not None:
            pulumi.set(__self__, "filename_patterns", filename_patterns)
        if manual_queue_only is not None:
            pulumi.set(__self__, "manual_queue_only", manual_queue_only)
        if queue_on_source_update_only is not None:
            pulumi.set(__self__, "queue_on_source_update_only", queue_on_source_update_only)
        if valid_duration is not None:
            pulumi.set(__self__, "valid_duration", valid_duration)

    @property
    @pulumi.getter(name="buildDefinitionId")
    def build_definition_id(self) -> pulumi.Input[int]:
        """
        The ID of the build to monitor for the policy.
        """
        return pulumi.get(self, "build_definition_id")

    @build_definition_id.setter
    def build_definition_id(self, value: pulumi.Input[int]):
        pulumi.set(self, "build_definition_id", value)

    @property
    @pulumi.getter(name="displayName")
    def display_name(self) -> pulumi.Input[str]:
        """
        The display name for the policy.
        """
        return pulumi.get(self, "display_name")

    @display_name.setter
    def display_name(self, value: pulumi.Input[str]):
        pulumi.set(self, "display_name", value)

    @property
    @pulumi.getter
    def scopes(self) -> pulumi.Input[Sequence[pulumi.Input['BranchPolicyBuildValidationSettingsScopeArgs']]]:
        """
        Controls which repositories and branches the policy will be enabled for. This block must be defined at least once.
        """
        return pulumi.get(self, "scopes")

    @scopes.setter
    def scopes(self, value: pulumi.Input[Sequence[pulumi.Input['BranchPolicyBuildValidationSettingsScopeArgs']]]):
        pulumi.set(self, "scopes", value)

    @property
    @pulumi.getter(name="filenamePatterns")
    def filename_patterns(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        If a path filter is set, the policy will only apply when files which match the filter are changes. Not setting this field means that the policy will always apply. You can specify absolute paths and wildcards. Example: `["/WebApp/Models/Data.cs", "/WebApp/*", "*.cs"]`. Paths prefixed with "!" are excluded. Example: `["/WebApp/*", "!/WebApp/Tests/*"]`. Order is significant.
        """
        return pulumi.get(self, "filename_patterns")

    @filename_patterns.setter
    def filename_patterns(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "filename_patterns", value)

    @property
    @pulumi.getter(name="manualQueueOnly")
    def manual_queue_only(self) -> Optional[pulumi.Input[bool]]:
        """
        If set to true, the build will need to be manually queued. Defaults to `false`
        """
        return pulumi.get(self, "manual_queue_only")

    @manual_queue_only.setter
    def manual_queue_only(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "manual_queue_only", value)

    @property
    @pulumi.getter(name="queueOnSourceUpdateOnly")
    def queue_on_source_update_only(self) -> Optional[pulumi.Input[bool]]:
        """
        True if the build should queue on source updates only. Defaults to `true`.
        """
        return pulumi.get(self, "queue_on_source_update_only")

    @queue_on_source_update_only.setter
    def queue_on_source_update_only(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "queue_on_source_update_only", value)

    @property
    @pulumi.getter(name="validDuration")
    def valid_duration(self) -> Optional[pulumi.Input[int]]:
        """
        The number of minutes for which the build is valid. If `0`, the build will not expire. Defaults to `720` (12 hours).
        """
        return pulumi.get(self, "valid_duration")

    @valid_duration.setter
    def valid_duration(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "valid_duration", value)


@pulumi.input_type
class BranchPolicyBuildValidationSettingsScopeArgs:
    def __init__(__self__, *,
                 match_type: Optional[pulumi.Input[str]] = None,
                 repository_id: Optional[pulumi.Input[str]] = None,
                 repository_ref: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] match_type: The match type to use when applying the policy. Supported values are `Exact` (default), `Prefix` or `DefaultBranch`.
        :param pulumi.Input[str] repository_id: The repository ID. Needed only if the scope of the policy will be limited to a single repository. If `match_type` is `DefaultBranch`, this should not be defined.
        :param pulumi.Input[str] repository_ref: The ref pattern to use for the match when `match_type` other than `DefaultBranch`. If `match_type` is `Exact`, this should be a qualified ref such as `refs/heads/master`. If `match_type` is `Prefix`, this should be a ref path such as `refs/heads/releases`.
        """
        if match_type is not None:
            pulumi.set(__self__, "match_type", match_type)
        if repository_id is not None:
            pulumi.set(__self__, "repository_id", repository_id)
        if repository_ref is not None:
            pulumi.set(__self__, "repository_ref", repository_ref)

    @property
    @pulumi.getter(name="matchType")
    def match_type(self) -> Optional[pulumi.Input[str]]:
        """
        The match type to use when applying the policy. Supported values are `Exact` (default), `Prefix` or `DefaultBranch`.
        """
        return pulumi.get(self, "match_type")

    @match_type.setter
    def match_type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "match_type", value)

    @property
    @pulumi.getter(name="repositoryId")
    def repository_id(self) -> Optional[pulumi.Input[str]]:
        """
        The repository ID. Needed only if the scope of the policy will be limited to a single repository. If `match_type` is `DefaultBranch`, this should not be defined.
        """
        return pulumi.get(self, "repository_id")

    @repository_id.setter
    def repository_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "repository_id", value)

    @property
    @pulumi.getter(name="repositoryRef")
    def repository_ref(self) -> Optional[pulumi.Input[str]]:
        """
        The ref pattern to use for the match when `match_type` other than `DefaultBranch`. If `match_type` is `Exact`, this should be a qualified ref such as `refs/heads/master`. If `match_type` is `Prefix`, this should be a ref path such as `refs/heads/releases`.
        """
        return pulumi.get(self, "repository_ref")

    @repository_ref.setter
    def repository_ref(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "repository_ref", value)


@pulumi.input_type
class BranchPolicyCommentResolutionSettingsArgs:
    def __init__(__self__, *,
                 scopes: pulumi.Input[Sequence[pulumi.Input['BranchPolicyCommentResolutionSettingsScopeArgs']]]):
        """
        :param pulumi.Input[Sequence[pulumi.Input['BranchPolicyCommentResolutionSettingsScopeArgs']]] scopes: Controls which repositories and branches the policy will be enabled for. This block must be defined at least once.
        """
        pulumi.set(__self__, "scopes", scopes)

    @property
    @pulumi.getter
    def scopes(self) -> pulumi.Input[Sequence[pulumi.Input['BranchPolicyCommentResolutionSettingsScopeArgs']]]:
        """
        Controls which repositories and branches the policy will be enabled for. This block must be defined at least once.
        """
        return pulumi.get(self, "scopes")

    @scopes.setter
    def scopes(self, value: pulumi.Input[Sequence[pulumi.Input['BranchPolicyCommentResolutionSettingsScopeArgs']]]):
        pulumi.set(self, "scopes", value)


@pulumi.input_type
class BranchPolicyCommentResolutionSettingsScopeArgs:
    def __init__(__self__, *,
                 match_type: Optional[pulumi.Input[str]] = None,
                 repository_id: Optional[pulumi.Input[str]] = None,
                 repository_ref: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] match_type: The match type to use when applying the policy. Supported values are `Exact` (default), `Prefix` or `DefaultBranch`.
        :param pulumi.Input[str] repository_id: The repository ID. Needed only if the scope of the policy will be limited to a single repository. If `match_type` is `DefaultBranch`, this should not be defined.
        :param pulumi.Input[str] repository_ref: The ref pattern to use for the match when `match_type` other than `DefaultBranch`. If `match_type` is `Exact`, this should be a qualified ref such as `refs/heads/master`. If `match_type` is `Prefix`, this should be a ref path such as `refs/heads/releases`.
        """
        if match_type is not None:
            pulumi.set(__self__, "match_type", match_type)
        if repository_id is not None:
            pulumi.set(__self__, "repository_id", repository_id)
        if repository_ref is not None:
            pulumi.set(__self__, "repository_ref", repository_ref)

    @property
    @pulumi.getter(name="matchType")
    def match_type(self) -> Optional[pulumi.Input[str]]:
        """
        The match type to use when applying the policy. Supported values are `Exact` (default), `Prefix` or `DefaultBranch`.
        """
        return pulumi.get(self, "match_type")

    @match_type.setter
    def match_type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "match_type", value)

    @property
    @pulumi.getter(name="repositoryId")
    def repository_id(self) -> Optional[pulumi.Input[str]]:
        """
        The repository ID. Needed only if the scope of the policy will be limited to a single repository. If `match_type` is `DefaultBranch`, this should not be defined.
        """
        return pulumi.get(self, "repository_id")

    @repository_id.setter
    def repository_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "repository_id", value)

    @property
    @pulumi.getter(name="repositoryRef")
    def repository_ref(self) -> Optional[pulumi.Input[str]]:
        """
        The ref pattern to use for the match when `match_type` other than `DefaultBranch`. If `match_type` is `Exact`, this should be a qualified ref such as `refs/heads/master`. If `match_type` is `Prefix`, this should be a ref path such as `refs/heads/releases`.
        """
        return pulumi.get(self, "repository_ref")

    @repository_ref.setter
    def repository_ref(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "repository_ref", value)


@pulumi.input_type
class BranchPolicyMergeTypesSettingsArgs:
    def __init__(__self__, *,
                 scopes: pulumi.Input[Sequence[pulumi.Input['BranchPolicyMergeTypesSettingsScopeArgs']]],
                 allow_basic_no_fast_forward: Optional[pulumi.Input[bool]] = None,
                 allow_rebase_and_fast_forward: Optional[pulumi.Input[bool]] = None,
                 allow_rebase_with_merge: Optional[pulumi.Input[bool]] = None,
                 allow_squash: Optional[pulumi.Input[bool]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input['BranchPolicyMergeTypesSettingsScopeArgs']]] scopes: Controls which repositories and branches the policy will be enabled for. This block must be defined at least once.
        :param pulumi.Input[bool] allow_basic_no_fast_forward: Allow basic merge with no fast forward. Defaults to `false`.
        :param pulumi.Input[bool] allow_rebase_and_fast_forward: Allow rebase with fast forward. Defaults to `false`.
        :param pulumi.Input[bool] allow_rebase_with_merge: Allow rebase with merge commit. Defaults to `false`.
        :param pulumi.Input[bool] allow_squash: Allow squash merge. Defaults to `false`
        """
        pulumi.set(__self__, "scopes", scopes)
        if allow_basic_no_fast_forward is not None:
            pulumi.set(__self__, "allow_basic_no_fast_forward", allow_basic_no_fast_forward)
        if allow_rebase_and_fast_forward is not None:
            pulumi.set(__self__, "allow_rebase_and_fast_forward", allow_rebase_and_fast_forward)
        if allow_rebase_with_merge is not None:
            pulumi.set(__self__, "allow_rebase_with_merge", allow_rebase_with_merge)
        if allow_squash is not None:
            pulumi.set(__self__, "allow_squash", allow_squash)

    @property
    @pulumi.getter
    def scopes(self) -> pulumi.Input[Sequence[pulumi.Input['BranchPolicyMergeTypesSettingsScopeArgs']]]:
        """
        Controls which repositories and branches the policy will be enabled for. This block must be defined at least once.
        """
        return pulumi.get(self, "scopes")

    @scopes.setter
    def scopes(self, value: pulumi.Input[Sequence[pulumi.Input['BranchPolicyMergeTypesSettingsScopeArgs']]]):
        pulumi.set(self, "scopes", value)

    @property
    @pulumi.getter(name="allowBasicNoFastForward")
    def allow_basic_no_fast_forward(self) -> Optional[pulumi.Input[bool]]:
        """
        Allow basic merge with no fast forward. Defaults to `false`.
        """
        return pulumi.get(self, "allow_basic_no_fast_forward")

    @allow_basic_no_fast_forward.setter
    def allow_basic_no_fast_forward(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "allow_basic_no_fast_forward", value)

    @property
    @pulumi.getter(name="allowRebaseAndFastForward")
    def allow_rebase_and_fast_forward(self) -> Optional[pulumi.Input[bool]]:
        """
        Allow rebase with fast forward. Defaults to `false`.
        """
        return pulumi.get(self, "allow_rebase_and_fast_forward")

    @allow_rebase_and_fast_forward.setter
    def allow_rebase_and_fast_forward(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "allow_rebase_and_fast_forward", value)

    @property
    @pulumi.getter(name="allowRebaseWithMerge")
    def allow_rebase_with_merge(self) -> Optional[pulumi.Input[bool]]:
        """
        Allow rebase with merge commit. Defaults to `false`.
        """
        return pulumi.get(self, "allow_rebase_with_merge")

    @allow_rebase_with_merge.setter
    def allow_rebase_with_merge(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "allow_rebase_with_merge", value)

    @property
    @pulumi.getter(name="allowSquash")
    def allow_squash(self) -> Optional[pulumi.Input[bool]]:
        """
        Allow squash merge. Defaults to `false`
        """
        return pulumi.get(self, "allow_squash")

    @allow_squash.setter
    def allow_squash(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "allow_squash", value)


@pulumi.input_type
class BranchPolicyMergeTypesSettingsScopeArgs:
    def __init__(__self__, *,
                 match_type: Optional[pulumi.Input[str]] = None,
                 repository_id: Optional[pulumi.Input[str]] = None,
                 repository_ref: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] match_type: The match type to use when applying the policy. Supported values are `Exact` (default), `Prefix` or `DefaultBranch`.
        :param pulumi.Input[str] repository_id: The repository ID. Needed only if the scope of the policy will be limited to a single repository. If `match_type` is `DefaultBranch`, this should not be defined.
        :param pulumi.Input[str] repository_ref: The ref pattern to use for the match when `match_type` other than `DefaultBranch`. If `match_type` is `Exact`, this should be a qualified ref such as `refs/heads/master`. If `match_type` is `Prefix`, this should be a ref path such as `refs/heads/releases`.
        """
        if match_type is not None:
            pulumi.set(__self__, "match_type", match_type)
        if repository_id is not None:
            pulumi.set(__self__, "repository_id", repository_id)
        if repository_ref is not None:
            pulumi.set(__self__, "repository_ref", repository_ref)

    @property
    @pulumi.getter(name="matchType")
    def match_type(self) -> Optional[pulumi.Input[str]]:
        """
        The match type to use when applying the policy. Supported values are `Exact` (default), `Prefix` or `DefaultBranch`.
        """
        return pulumi.get(self, "match_type")

    @match_type.setter
    def match_type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "match_type", value)

    @property
    @pulumi.getter(name="repositoryId")
    def repository_id(self) -> Optional[pulumi.Input[str]]:
        """
        The repository ID. Needed only if the scope of the policy will be limited to a single repository. If `match_type` is `DefaultBranch`, this should not be defined.
        """
        return pulumi.get(self, "repository_id")

    @repository_id.setter
    def repository_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "repository_id", value)

    @property
    @pulumi.getter(name="repositoryRef")
    def repository_ref(self) -> Optional[pulumi.Input[str]]:
        """
        The ref pattern to use for the match when `match_type` other than `DefaultBranch`. If `match_type` is `Exact`, this should be a qualified ref such as `refs/heads/master`. If `match_type` is `Prefix`, this should be a ref path such as `refs/heads/releases`.
        """
        return pulumi.get(self, "repository_ref")

    @repository_ref.setter
    def repository_ref(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "repository_ref", value)


@pulumi.input_type
class BranchPolicyMinReviewersSettingsArgs:
    def __init__(__self__, *,
                 scopes: pulumi.Input[Sequence[pulumi.Input['BranchPolicyMinReviewersSettingsScopeArgs']]],
                 allow_completion_with_rejects_or_waits: Optional[pulumi.Input[bool]] = None,
                 last_pusher_cannot_approve: Optional[pulumi.Input[bool]] = None,
                 on_last_iteration_require_vote: Optional[pulumi.Input[bool]] = None,
                 on_push_reset_all_votes: Optional[pulumi.Input[bool]] = None,
                 on_push_reset_approved_votes: Optional[pulumi.Input[bool]] = None,
                 reviewer_count: Optional[pulumi.Input[int]] = None,
                 submitter_can_vote: Optional[pulumi.Input[bool]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input['BranchPolicyMinReviewersSettingsScopeArgs']]] scopes: A `scope` block as defined below. Controls which repositories and branches the policy will be enabled for. This block must be defined at least once.
        :param pulumi.Input[bool] allow_completion_with_rejects_or_waits: Allow completion even if some reviewers vote to wait or reject. Defaults to `false`.
        :param pulumi.Input[bool] last_pusher_cannot_approve: Prohibit the most recent pusher from approving their own changes. Defaults to `false`.
        :param pulumi.Input[bool] on_last_iteration_require_vote: On last iteration require vote. Defaults to `false`.
        :param pulumi.Input[bool] on_push_reset_all_votes: When new changes are pushed reset all code reviewer votes. Defaults to `false`.
               
               > **Note:** If `on_push_reset_all_votes` is `true` then `on_push_reset_approved_votes` will be set to `true`. To enable `on_push_reset_approved_votes`, you need explicitly set `on_push_reset_all_votes` `false` or not configure.
        :param pulumi.Input[bool] on_push_reset_approved_votes: When new changes are pushed reset all approval votes (does not reset votes to reject or wait). Defaults to `false`.
        :param pulumi.Input[int] reviewer_count: The number of reviewers needed to approve.
        :param pulumi.Input[bool] submitter_can_vote: Allow requesters to approve their own changes. Defaults to `false`.
        """
        pulumi.set(__self__, "scopes", scopes)
        if allow_completion_with_rejects_or_waits is not None:
            pulumi.set(__self__, "allow_completion_with_rejects_or_waits", allow_completion_with_rejects_or_waits)
        if last_pusher_cannot_approve is not None:
            pulumi.set(__self__, "last_pusher_cannot_approve", last_pusher_cannot_approve)
        if on_last_iteration_require_vote is not None:
            pulumi.set(__self__, "on_last_iteration_require_vote", on_last_iteration_require_vote)
        if on_push_reset_all_votes is not None:
            pulumi.set(__self__, "on_push_reset_all_votes", on_push_reset_all_votes)
        if on_push_reset_approved_votes is not None:
            pulumi.set(__self__, "on_push_reset_approved_votes", on_push_reset_approved_votes)
        if reviewer_count is not None:
            pulumi.set(__self__, "reviewer_count", reviewer_count)
        if submitter_can_vote is not None:
            pulumi.set(__self__, "submitter_can_vote", submitter_can_vote)

    @property
    @pulumi.getter
    def scopes(self) -> pulumi.Input[Sequence[pulumi.Input['BranchPolicyMinReviewersSettingsScopeArgs']]]:
        """
        A `scope` block as defined below. Controls which repositories and branches the policy will be enabled for. This block must be defined at least once.
        """
        return pulumi.get(self, "scopes")

    @scopes.setter
    def scopes(self, value: pulumi.Input[Sequence[pulumi.Input['BranchPolicyMinReviewersSettingsScopeArgs']]]):
        pulumi.set(self, "scopes", value)

    @property
    @pulumi.getter(name="allowCompletionWithRejectsOrWaits")
    def allow_completion_with_rejects_or_waits(self) -> Optional[pulumi.Input[bool]]:
        """
        Allow completion even if some reviewers vote to wait or reject. Defaults to `false`.
        """
        return pulumi.get(self, "allow_completion_with_rejects_or_waits")

    @allow_completion_with_rejects_or_waits.setter
    def allow_completion_with_rejects_or_waits(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "allow_completion_with_rejects_or_waits", value)

    @property
    @pulumi.getter(name="lastPusherCannotApprove")
    def last_pusher_cannot_approve(self) -> Optional[pulumi.Input[bool]]:
        """
        Prohibit the most recent pusher from approving their own changes. Defaults to `false`.
        """
        return pulumi.get(self, "last_pusher_cannot_approve")

    @last_pusher_cannot_approve.setter
    def last_pusher_cannot_approve(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "last_pusher_cannot_approve", value)

    @property
    @pulumi.getter(name="onLastIterationRequireVote")
    def on_last_iteration_require_vote(self) -> Optional[pulumi.Input[bool]]:
        """
        On last iteration require vote. Defaults to `false`.
        """
        return pulumi.get(self, "on_last_iteration_require_vote")

    @on_last_iteration_require_vote.setter
    def on_last_iteration_require_vote(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "on_last_iteration_require_vote", value)

    @property
    @pulumi.getter(name="onPushResetAllVotes")
    def on_push_reset_all_votes(self) -> Optional[pulumi.Input[bool]]:
        """
        When new changes are pushed reset all code reviewer votes. Defaults to `false`.

        > **Note:** If `on_push_reset_all_votes` is `true` then `on_push_reset_approved_votes` will be set to `true`. To enable `on_push_reset_approved_votes`, you need explicitly set `on_push_reset_all_votes` `false` or not configure.
        """
        return pulumi.get(self, "on_push_reset_all_votes")

    @on_push_reset_all_votes.setter
    def on_push_reset_all_votes(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "on_push_reset_all_votes", value)

    @property
    @pulumi.getter(name="onPushResetApprovedVotes")
    def on_push_reset_approved_votes(self) -> Optional[pulumi.Input[bool]]:
        """
        When new changes are pushed reset all approval votes (does not reset votes to reject or wait). Defaults to `false`.
        """
        return pulumi.get(self, "on_push_reset_approved_votes")

    @on_push_reset_approved_votes.setter
    def on_push_reset_approved_votes(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "on_push_reset_approved_votes", value)

    @property
    @pulumi.getter(name="reviewerCount")
    def reviewer_count(self) -> Optional[pulumi.Input[int]]:
        """
        The number of reviewers needed to approve.
        """
        return pulumi.get(self, "reviewer_count")

    @reviewer_count.setter
    def reviewer_count(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "reviewer_count", value)

    @property
    @pulumi.getter(name="submitterCanVote")
    def submitter_can_vote(self) -> Optional[pulumi.Input[bool]]:
        """
        Allow requesters to approve their own changes. Defaults to `false`.
        """
        return pulumi.get(self, "submitter_can_vote")

    @submitter_can_vote.setter
    def submitter_can_vote(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "submitter_can_vote", value)


@pulumi.input_type
class BranchPolicyMinReviewersSettingsScopeArgs:
    def __init__(__self__, *,
                 match_type: Optional[pulumi.Input[str]] = None,
                 repository_id: Optional[pulumi.Input[str]] = None,
                 repository_ref: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] match_type: The match type to use when applying the policy. Supported values are `Exact` (default), `Prefix` or `DefaultBranch`.
        :param pulumi.Input[str] repository_id: The repository ID. Needed only if the scope of the policy will be limited to a single repository. If `match_type` is `DefaultBranch`, this should not be defined.
        :param pulumi.Input[str] repository_ref: The ref pattern to use for the match when `match_type` other than `DefaultBranch`. If `match_type` is `Exact`, this should be a qualified ref such as `refs/heads/master`. If `match_type` is `Prefix`, this should be a ref path such as `refs/heads/releases`.
        """
        if match_type is not None:
            pulumi.set(__self__, "match_type", match_type)
        if repository_id is not None:
            pulumi.set(__self__, "repository_id", repository_id)
        if repository_ref is not None:
            pulumi.set(__self__, "repository_ref", repository_ref)

    @property
    @pulumi.getter(name="matchType")
    def match_type(self) -> Optional[pulumi.Input[str]]:
        """
        The match type to use when applying the policy. Supported values are `Exact` (default), `Prefix` or `DefaultBranch`.
        """
        return pulumi.get(self, "match_type")

    @match_type.setter
    def match_type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "match_type", value)

    @property
    @pulumi.getter(name="repositoryId")
    def repository_id(self) -> Optional[pulumi.Input[str]]:
        """
        The repository ID. Needed only if the scope of the policy will be limited to a single repository. If `match_type` is `DefaultBranch`, this should not be defined.
        """
        return pulumi.get(self, "repository_id")

    @repository_id.setter
    def repository_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "repository_id", value)

    @property
    @pulumi.getter(name="repositoryRef")
    def repository_ref(self) -> Optional[pulumi.Input[str]]:
        """
        The ref pattern to use for the match when `match_type` other than `DefaultBranch`. If `match_type` is `Exact`, this should be a qualified ref such as `refs/heads/master`. If `match_type` is `Prefix`, this should be a ref path such as `refs/heads/releases`.
        """
        return pulumi.get(self, "repository_ref")

    @repository_ref.setter
    def repository_ref(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "repository_ref", value)


@pulumi.input_type
class BranchPolicyStatusCheckSettingsArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[str],
                 scopes: pulumi.Input[Sequence[pulumi.Input['BranchPolicyStatusCheckSettingsScopeArgs']]],
                 applicability: Optional[pulumi.Input[str]] = None,
                 author_id: Optional[pulumi.Input[str]] = None,
                 display_name: Optional[pulumi.Input[str]] = None,
                 filename_patterns: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 genre: Optional[pulumi.Input[str]] = None,
                 invalidate_on_update: Optional[pulumi.Input[bool]] = None):
        """
        :param pulumi.Input[str] name: The status name to check.
        :param pulumi.Input[Sequence[pulumi.Input['BranchPolicyStatusCheckSettingsScopeArgs']]] scopes: Controls which repositories and branches the policy will be enabled for. This block must be defined
               at least once.
        :param pulumi.Input[str] applicability: Policy applicability. If policy `applicability` is `default`, apply unless "Not Applicable" 
               status is posted to the pull request. If policy `applicability` is `conditional`, policy is applied only after a status
               is posted to the pull request.
        :param pulumi.Input[str] author_id: The authorized user can post the status.
        :param pulumi.Input[str] display_name: The display name.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] filename_patterns: If a path filter is set, the policy will only apply when files which match the filter are changes. Not setting this field means that the policy will always apply. You can specify absolute paths and wildcards. Example: `["/WebApp/Models/Data.cs", "/WebApp/*", "*.cs"]`. Paths prefixed with "!" are excluded. Example: `["/WebApp/*", "!/WebApp/Tests/*"]`. Order is significant.
        :param pulumi.Input[str] genre: The genre of the status to check (see [Microsoft Documentation](https://docs.microsoft.com/en-us/azure/devops/repos/git/pull-request-status?view=azure-devops#status-policy))
        :param pulumi.Input[bool] invalidate_on_update: Reset status whenever there are new changes.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "scopes", scopes)
        if applicability is not None:
            pulumi.set(__self__, "applicability", applicability)
        if author_id is not None:
            pulumi.set(__self__, "author_id", author_id)
        if display_name is not None:
            pulumi.set(__self__, "display_name", display_name)
        if filename_patterns is not None:
            pulumi.set(__self__, "filename_patterns", filename_patterns)
        if genre is not None:
            pulumi.set(__self__, "genre", genre)
        if invalidate_on_update is not None:
            pulumi.set(__self__, "invalidate_on_update", invalidate_on_update)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        The status name to check.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def scopes(self) -> pulumi.Input[Sequence[pulumi.Input['BranchPolicyStatusCheckSettingsScopeArgs']]]:
        """
        Controls which repositories and branches the policy will be enabled for. This block must be defined
        at least once.
        """
        return pulumi.get(self, "scopes")

    @scopes.setter
    def scopes(self, value: pulumi.Input[Sequence[pulumi.Input['BranchPolicyStatusCheckSettingsScopeArgs']]]):
        pulumi.set(self, "scopes", value)

    @property
    @pulumi.getter
    def applicability(self) -> Optional[pulumi.Input[str]]:
        """
        Policy applicability. If policy `applicability` is `default`, apply unless "Not Applicable" 
        status is posted to the pull request. If policy `applicability` is `conditional`, policy is applied only after a status
        is posted to the pull request.
        """
        return pulumi.get(self, "applicability")

    @applicability.setter
    def applicability(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "applicability", value)

    @property
    @pulumi.getter(name="authorId")
    def author_id(self) -> Optional[pulumi.Input[str]]:
        """
        The authorized user can post the status.
        """
        return pulumi.get(self, "author_id")

    @author_id.setter
    def author_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "author_id", value)

    @property
    @pulumi.getter(name="displayName")
    def display_name(self) -> Optional[pulumi.Input[str]]:
        """
        The display name.
        """
        return pulumi.get(self, "display_name")

    @display_name.setter
    def display_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "display_name", value)

    @property
    @pulumi.getter(name="filenamePatterns")
    def filename_patterns(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        If a path filter is set, the policy will only apply when files which match the filter are changes. Not setting this field means that the policy will always apply. You can specify absolute paths and wildcards. Example: `["/WebApp/Models/Data.cs", "/WebApp/*", "*.cs"]`. Paths prefixed with "!" are excluded. Example: `["/WebApp/*", "!/WebApp/Tests/*"]`. Order is significant.
        """
        return pulumi.get(self, "filename_patterns")

    @filename_patterns.setter
    def filename_patterns(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "filename_patterns", value)

    @property
    @pulumi.getter
    def genre(self) -> Optional[pulumi.Input[str]]:
        """
        The genre of the status to check (see [Microsoft Documentation](https://docs.microsoft.com/en-us/azure/devops/repos/git/pull-request-status?view=azure-devops#status-policy))
        """
        return pulumi.get(self, "genre")

    @genre.setter
    def genre(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "genre", value)

    @property
    @pulumi.getter(name="invalidateOnUpdate")
    def invalidate_on_update(self) -> Optional[pulumi.Input[bool]]:
        """
        Reset status whenever there are new changes.
        """
        return pulumi.get(self, "invalidate_on_update")

    @invalidate_on_update.setter
    def invalidate_on_update(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "invalidate_on_update", value)


@pulumi.input_type
class BranchPolicyStatusCheckSettingsScopeArgs:
    def __init__(__self__, *,
                 match_type: Optional[pulumi.Input[str]] = None,
                 repository_id: Optional[pulumi.Input[str]] = None,
                 repository_ref: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] match_type: The match type to use when applying the policy. Supported values are `Exact` (default), `Prefix` or `DefaultBranch`.
        :param pulumi.Input[str] repository_id: The repository ID. Needed only if the scope of the policy will be limited to a single repository. If `match_type` is `DefaultBranch`, this should not be defined.
        :param pulumi.Input[str] repository_ref: The ref pattern to use for the match when `match_type` other than `DefaultBranch`. If `match_type` is `Exact`, this should be a qualified ref such as `refs/heads/master`. If `match_type` is `Prefix`, this should be a ref path such as `refs/heads/releases`.
        """
        if match_type is not None:
            pulumi.set(__self__, "match_type", match_type)
        if repository_id is not None:
            pulumi.set(__self__, "repository_id", repository_id)
        if repository_ref is not None:
            pulumi.set(__self__, "repository_ref", repository_ref)

    @property
    @pulumi.getter(name="matchType")
    def match_type(self) -> Optional[pulumi.Input[str]]:
        """
        The match type to use when applying the policy. Supported values are `Exact` (default), `Prefix` or `DefaultBranch`.
        """
        return pulumi.get(self, "match_type")

    @match_type.setter
    def match_type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "match_type", value)

    @property
    @pulumi.getter(name="repositoryId")
    def repository_id(self) -> Optional[pulumi.Input[str]]:
        """
        The repository ID. Needed only if the scope of the policy will be limited to a single repository. If `match_type` is `DefaultBranch`, this should not be defined.
        """
        return pulumi.get(self, "repository_id")

    @repository_id.setter
    def repository_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "repository_id", value)

    @property
    @pulumi.getter(name="repositoryRef")
    def repository_ref(self) -> Optional[pulumi.Input[str]]:
        """
        The ref pattern to use for the match when `match_type` other than `DefaultBranch`. If `match_type` is `Exact`, this should be a qualified ref such as `refs/heads/master`. If `match_type` is `Prefix`, this should be a ref path such as `refs/heads/releases`.
        """
        return pulumi.get(self, "repository_ref")

    @repository_ref.setter
    def repository_ref(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "repository_ref", value)


@pulumi.input_type
class BranchPolicyWorkItemLinkingSettingsArgs:
    def __init__(__self__, *,
                 scopes: pulumi.Input[Sequence[pulumi.Input['BranchPolicyWorkItemLinkingSettingsScopeArgs']]]):
        """
        :param pulumi.Input[Sequence[pulumi.Input['BranchPolicyWorkItemLinkingSettingsScopeArgs']]] scopes: Controls which repositories and branches the policy will be enabled for. This block must be defined at least once.
        """
        pulumi.set(__self__, "scopes", scopes)

    @property
    @pulumi.getter
    def scopes(self) -> pulumi.Input[Sequence[pulumi.Input['BranchPolicyWorkItemLinkingSettingsScopeArgs']]]:
        """
        Controls which repositories and branches the policy will be enabled for. This block must be defined at least once.
        """
        return pulumi.get(self, "scopes")

    @scopes.setter
    def scopes(self, value: pulumi.Input[Sequence[pulumi.Input['BranchPolicyWorkItemLinkingSettingsScopeArgs']]]):
        pulumi.set(self, "scopes", value)


@pulumi.input_type
class BranchPolicyWorkItemLinkingSettingsScopeArgs:
    def __init__(__self__, *,
                 match_type: Optional[pulumi.Input[str]] = None,
                 repository_id: Optional[pulumi.Input[str]] = None,
                 repository_ref: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] match_type: The match type to use when applying the policy. Supported values are `Exact` (default), `Prefix` or `DefaultBranch`.
        :param pulumi.Input[str] repository_id: The repository ID. Needed only if the scope of the policy will be limited to a single repository. If `match_type` is `DefaultBranch`, this should not be defined.
        :param pulumi.Input[str] repository_ref: The ref pattern to use for the match when `match_type` other than `DefaultBranch`. If `match_type` is `Exact`, this should be a qualified ref such as `refs/heads/master`. If `match_type` is `Prefix`, this should be a ref path such as `refs/heads/releases`.
        """
        if match_type is not None:
            pulumi.set(__self__, "match_type", match_type)
        if repository_id is not None:
            pulumi.set(__self__, "repository_id", repository_id)
        if repository_ref is not None:
            pulumi.set(__self__, "repository_ref", repository_ref)

    @property
    @pulumi.getter(name="matchType")
    def match_type(self) -> Optional[pulumi.Input[str]]:
        """
        The match type to use when applying the policy. Supported values are `Exact` (default), `Prefix` or `DefaultBranch`.
        """
        return pulumi.get(self, "match_type")

    @match_type.setter
    def match_type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "match_type", value)

    @property
    @pulumi.getter(name="repositoryId")
    def repository_id(self) -> Optional[pulumi.Input[str]]:
        """
        The repository ID. Needed only if the scope of the policy will be limited to a single repository. If `match_type` is `DefaultBranch`, this should not be defined.
        """
        return pulumi.get(self, "repository_id")

    @repository_id.setter
    def repository_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "repository_id", value)

    @property
    @pulumi.getter(name="repositoryRef")
    def repository_ref(self) -> Optional[pulumi.Input[str]]:
        """
        The ref pattern to use for the match when `match_type` other than `DefaultBranch`. If `match_type` is `Exact`, this should be a qualified ref such as `refs/heads/master`. If `match_type` is `Prefix`, this should be a ref path such as `refs/heads/releases`.
        """
        return pulumi.get(self, "repository_ref")

    @repository_ref.setter
    def repository_ref(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "repository_ref", value)


@pulumi.input_type
class BuildDefinitionCiTriggerArgs:
    def __init__(__self__, *,
                 override: Optional[pulumi.Input['BuildDefinitionCiTriggerOverrideArgs']] = None,
                 use_yaml: Optional[pulumi.Input[bool]] = None):
        """
        :param pulumi.Input['BuildDefinitionCiTriggerOverrideArgs'] override: Override the azure-pipeline file and use a this configuration for all builds.
        :param pulumi.Input[bool] use_yaml: Use the azure-pipeline file for the build configuration. Defaults to `false`.
        """
        if override is not None:
            pulumi.set(__self__, "override", override)
        if use_yaml is not None:
            pulumi.set(__self__, "use_yaml", use_yaml)

    @property
    @pulumi.getter
    def override(self) -> Optional[pulumi.Input['BuildDefinitionCiTriggerOverrideArgs']]:
        """
        Override the azure-pipeline file and use a this configuration for all builds.
        """
        return pulumi.get(self, "override")

    @override.setter
    def override(self, value: Optional[pulumi.Input['BuildDefinitionCiTriggerOverrideArgs']]):
        pulumi.set(self, "override", value)

    @property
    @pulumi.getter(name="useYaml")
    def use_yaml(self) -> Optional[pulumi.Input[bool]]:
        """
        Use the azure-pipeline file for the build configuration. Defaults to `false`.
        """
        return pulumi.get(self, "use_yaml")

    @use_yaml.setter
    def use_yaml(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "use_yaml", value)


@pulumi.input_type
class BuildDefinitionCiTriggerOverrideArgs:
    def __init__(__self__, *,
                 batch: Optional[pulumi.Input[bool]] = None,
                 branch_filters: Optional[pulumi.Input[Sequence[pulumi.Input['BuildDefinitionCiTriggerOverrideBranchFilterArgs']]]] = None,
                 max_concurrent_builds_per_branch: Optional[pulumi.Input[int]] = None,
                 path_filters: Optional[pulumi.Input[Sequence[pulumi.Input['BuildDefinitionCiTriggerOverridePathFilterArgs']]]] = None,
                 polling_interval: Optional[pulumi.Input[int]] = None,
                 polling_job_id: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[bool] batch: If you set batch to true, when a pipeline is running, the system waits until the run is completed, then starts another run with all changes that have not yet been built. Defaults to `true`.
        :param pulumi.Input[Sequence[pulumi.Input['BuildDefinitionCiTriggerOverrideBranchFilterArgs']]] branch_filters: The branches to include and exclude from the trigger.
        :param pulumi.Input[int] max_concurrent_builds_per_branch: The number of max builds per branch. Defaults to `1`.
        :param pulumi.Input[Sequence[pulumi.Input['BuildDefinitionCiTriggerOverridePathFilterArgs']]] path_filters: Specify file paths to include or exclude. Note that the wildcard syntax is different between branches/tags and file paths.
        :param pulumi.Input[int] polling_interval: How often the external repository is polled. Defaults to `0`.
        :param pulumi.Input[str] polling_job_id: This is the ID of the polling job that polls the external repository. Once the build definition is saved/updated, this value is set.
        """
        if batch is not None:
            pulumi.set(__self__, "batch", batch)
        if branch_filters is not None:
            pulumi.set(__self__, "branch_filters", branch_filters)
        if max_concurrent_builds_per_branch is not None:
            pulumi.set(__self__, "max_concurrent_builds_per_branch", max_concurrent_builds_per_branch)
        if path_filters is not None:
            pulumi.set(__self__, "path_filters", path_filters)
        if polling_interval is not None:
            pulumi.set(__self__, "polling_interval", polling_interval)
        if polling_job_id is not None:
            pulumi.set(__self__, "polling_job_id", polling_job_id)

    @property
    @pulumi.getter
    def batch(self) -> Optional[pulumi.Input[bool]]:
        """
        If you set batch to true, when a pipeline is running, the system waits until the run is completed, then starts another run with all changes that have not yet been built. Defaults to `true`.
        """
        return pulumi.get(self, "batch")

    @batch.setter
    def batch(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "batch", value)

    @property
    @pulumi.getter(name="branchFilters")
    def branch_filters(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['BuildDefinitionCiTriggerOverrideBranchFilterArgs']]]]:
        """
        The branches to include and exclude from the trigger.
        """
        return pulumi.get(self, "branch_filters")

    @branch_filters.setter
    def branch_filters(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['BuildDefinitionCiTriggerOverrideBranchFilterArgs']]]]):
        pulumi.set(self, "branch_filters", value)

    @property
    @pulumi.getter(name="maxConcurrentBuildsPerBranch")
    def max_concurrent_builds_per_branch(self) -> Optional[pulumi.Input[int]]:
        """
        The number of max builds per branch. Defaults to `1`.
        """
        return pulumi.get(self, "max_concurrent_builds_per_branch")

    @max_concurrent_builds_per_branch.setter
    def max_concurrent_builds_per_branch(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "max_concurrent_builds_per_branch", value)

    @property
    @pulumi.getter(name="pathFilters")
    def path_filters(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['BuildDefinitionCiTriggerOverridePathFilterArgs']]]]:
        """
        Specify file paths to include or exclude. Note that the wildcard syntax is different between branches/tags and file paths.
        """
        return pulumi.get(self, "path_filters")

    @path_filters.setter
    def path_filters(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['BuildDefinitionCiTriggerOverridePathFilterArgs']]]]):
        pulumi.set(self, "path_filters", value)

    @property
    @pulumi.getter(name="pollingInterval")
    def polling_interval(self) -> Optional[pulumi.Input[int]]:
        """
        How often the external repository is polled. Defaults to `0`.
        """
        return pulumi.get(self, "polling_interval")

    @polling_interval.setter
    def polling_interval(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "polling_interval", value)

    @property
    @pulumi.getter(name="pollingJobId")
    def polling_job_id(self) -> Optional[pulumi.Input[str]]:
        """
        This is the ID of the polling job that polls the external repository. Once the build definition is saved/updated, this value is set.
        """
        return pulumi.get(self, "polling_job_id")

    @polling_job_id.setter
    def polling_job_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "polling_job_id", value)


@pulumi.input_type
class BuildDefinitionCiTriggerOverrideBranchFilterArgs:
    def __init__(__self__, *,
                 excludes: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 includes: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input[str]]] excludes: List of branch patterns to exclude.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] includes: List of branch patterns to include.
        """
        if excludes is not None:
            pulumi.set(__self__, "excludes", excludes)
        if includes is not None:
            pulumi.set(__self__, "includes", includes)

    @property
    @pulumi.getter
    def excludes(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        List of branch patterns to exclude.
        """
        return pulumi.get(self, "excludes")

    @excludes.setter
    def excludes(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "excludes", value)

    @property
    @pulumi.getter
    def includes(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        List of branch patterns to include.
        """
        return pulumi.get(self, "includes")

    @includes.setter
    def includes(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "includes", value)


@pulumi.input_type
class BuildDefinitionCiTriggerOverridePathFilterArgs:
    def __init__(__self__, *,
                 excludes: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 includes: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input[str]]] excludes: List of path patterns to exclude.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] includes: List of path patterns to include.
        """
        if excludes is not None:
            pulumi.set(__self__, "excludes", excludes)
        if includes is not None:
            pulumi.set(__self__, "includes", includes)

    @property
    @pulumi.getter
    def excludes(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        List of path patterns to exclude.
        """
        return pulumi.get(self, "excludes")

    @excludes.setter
    def excludes(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "excludes", value)

    @property
    @pulumi.getter
    def includes(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        List of path patterns to include.
        """
        return pulumi.get(self, "includes")

    @includes.setter
    def includes(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "includes", value)


@pulumi.input_type
class BuildDefinitionFeatureArgs:
    def __init__(__self__, *,
                 skip_first_run: Optional[pulumi.Input[bool]] = None):
        """
        :param pulumi.Input[bool] skip_first_run: Trigger the pipeline to run after the creation. Defaults to `true`.
               
               > **Note** The first run(`skip_first_run = false`) will only be triggered on create.
        """
        if skip_first_run is not None:
            pulumi.set(__self__, "skip_first_run", skip_first_run)

    @property
    @pulumi.getter(name="skipFirstRun")
    def skip_first_run(self) -> Optional[pulumi.Input[bool]]:
        """
        Trigger the pipeline to run after the creation. Defaults to `true`.

        > **Note** The first run(`skip_first_run = false`) will only be triggered on create.
        """
        return pulumi.get(self, "skip_first_run")

    @skip_first_run.setter
    def skip_first_run(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "skip_first_run", value)


@pulumi.input_type
class BuildDefinitionPullRequestTriggerArgs:
    def __init__(__self__, *,
                 forks: pulumi.Input['BuildDefinitionPullRequestTriggerForksArgs'],
                 comment_required: Optional[pulumi.Input[str]] = None,
                 initial_branch: Optional[pulumi.Input[str]] = None,
                 override: Optional[pulumi.Input['BuildDefinitionPullRequestTriggerOverrideArgs']] = None,
                 use_yaml: Optional[pulumi.Input[bool]] = None):
        """
        :param pulumi.Input['BuildDefinitionPullRequestTriggerForksArgs'] forks: Set permissions for Forked repositories.
        :param pulumi.Input['BuildDefinitionPullRequestTriggerOverrideArgs'] override: Override the azure-pipeline file and use this configuration for all builds.
        :param pulumi.Input[bool] use_yaml: Use the azure-pipeline file for the build configuration. Defaults to `false`.
        """
        pulumi.set(__self__, "forks", forks)
        if comment_required is not None:
            pulumi.set(__self__, "comment_required", comment_required)
        if initial_branch is not None:
            pulumi.set(__self__, "initial_branch", initial_branch)
        if override is not None:
            pulumi.set(__self__, "override", override)
        if use_yaml is not None:
            pulumi.set(__self__, "use_yaml", use_yaml)

    @property
    @pulumi.getter
    def forks(self) -> pulumi.Input['BuildDefinitionPullRequestTriggerForksArgs']:
        """
        Set permissions for Forked repositories.
        """
        return pulumi.get(self, "forks")

    @forks.setter
    def forks(self, value: pulumi.Input['BuildDefinitionPullRequestTriggerForksArgs']):
        pulumi.set(self, "forks", value)

    @property
    @pulumi.getter(name="commentRequired")
    def comment_required(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "comment_required")

    @comment_required.setter
    def comment_required(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "comment_required", value)

    @property
    @pulumi.getter(name="initialBranch")
    def initial_branch(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "initial_branch")

    @initial_branch.setter
    def initial_branch(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "initial_branch", value)

    @property
    @pulumi.getter
    def override(self) -> Optional[pulumi.Input['BuildDefinitionPullRequestTriggerOverrideArgs']]:
        """
        Override the azure-pipeline file and use this configuration for all builds.
        """
        return pulumi.get(self, "override")

    @override.setter
    def override(self, value: Optional[pulumi.Input['BuildDefinitionPullRequestTriggerOverrideArgs']]):
        pulumi.set(self, "override", value)

    @property
    @pulumi.getter(name="useYaml")
    def use_yaml(self) -> Optional[pulumi.Input[bool]]:
        """
        Use the azure-pipeline file for the build configuration. Defaults to `false`.
        """
        return pulumi.get(self, "use_yaml")

    @use_yaml.setter
    def use_yaml(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "use_yaml", value)


@pulumi.input_type
class BuildDefinitionPullRequestTriggerForksArgs:
    def __init__(__self__, *,
                 enabled: pulumi.Input[bool],
                 share_secrets: pulumi.Input[bool]):
        """
        :param pulumi.Input[bool] enabled: Build pull requests from forks of this repository.
        :param pulumi.Input[bool] share_secrets: Make secrets available to builds of forks.
        """
        pulumi.set(__self__, "enabled", enabled)
        pulumi.set(__self__, "share_secrets", share_secrets)

    @property
    @pulumi.getter
    def enabled(self) -> pulumi.Input[bool]:
        """
        Build pull requests from forks of this repository.
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: pulumi.Input[bool]):
        pulumi.set(self, "enabled", value)

    @property
    @pulumi.getter(name="shareSecrets")
    def share_secrets(self) -> pulumi.Input[bool]:
        """
        Make secrets available to builds of forks.
        """
        return pulumi.get(self, "share_secrets")

    @share_secrets.setter
    def share_secrets(self, value: pulumi.Input[bool]):
        pulumi.set(self, "share_secrets", value)


@pulumi.input_type
class BuildDefinitionPullRequestTriggerOverrideArgs:
    def __init__(__self__, *,
                 auto_cancel: Optional[pulumi.Input[bool]] = None,
                 branch_filters: Optional[pulumi.Input[Sequence[pulumi.Input['BuildDefinitionPullRequestTriggerOverrideBranchFilterArgs']]]] = None,
                 path_filters: Optional[pulumi.Input[Sequence[pulumi.Input['BuildDefinitionPullRequestTriggerOverridePathFilterArgs']]]] = None):
        """
        :param pulumi.Input[bool] auto_cancel: . Defaults to `true`.
        :param pulumi.Input[Sequence[pulumi.Input['BuildDefinitionPullRequestTriggerOverrideBranchFilterArgs']]] branch_filters: The branches to include and exclude from the trigger.
        :param pulumi.Input[Sequence[pulumi.Input['BuildDefinitionPullRequestTriggerOverridePathFilterArgs']]] path_filters: Specify file paths to include or exclude. Note that the wildcard syntax is different between branches/tags and file paths.
        """
        if auto_cancel is not None:
            pulumi.set(__self__, "auto_cancel", auto_cancel)
        if branch_filters is not None:
            pulumi.set(__self__, "branch_filters", branch_filters)
        if path_filters is not None:
            pulumi.set(__self__, "path_filters", path_filters)

    @property
    @pulumi.getter(name="autoCancel")
    def auto_cancel(self) -> Optional[pulumi.Input[bool]]:
        """
        . Defaults to `true`.
        """
        return pulumi.get(self, "auto_cancel")

    @auto_cancel.setter
    def auto_cancel(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "auto_cancel", value)

    @property
    @pulumi.getter(name="branchFilters")
    def branch_filters(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['BuildDefinitionPullRequestTriggerOverrideBranchFilterArgs']]]]:
        """
        The branches to include and exclude from the trigger.
        """
        return pulumi.get(self, "branch_filters")

    @branch_filters.setter
    def branch_filters(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['BuildDefinitionPullRequestTriggerOverrideBranchFilterArgs']]]]):
        pulumi.set(self, "branch_filters", value)

    @property
    @pulumi.getter(name="pathFilters")
    def path_filters(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['BuildDefinitionPullRequestTriggerOverridePathFilterArgs']]]]:
        """
        Specify file paths to include or exclude. Note that the wildcard syntax is different between branches/tags and file paths.
        """
        return pulumi.get(self, "path_filters")

    @path_filters.setter
    def path_filters(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['BuildDefinitionPullRequestTriggerOverridePathFilterArgs']]]]):
        pulumi.set(self, "path_filters", value)


@pulumi.input_type
class BuildDefinitionPullRequestTriggerOverrideBranchFilterArgs:
    def __init__(__self__, *,
                 excludes: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 includes: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input[str]]] excludes: List of branch patterns to exclude.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] includes: List of branch patterns to include.
        """
        if excludes is not None:
            pulumi.set(__self__, "excludes", excludes)
        if includes is not None:
            pulumi.set(__self__, "includes", includes)

    @property
    @pulumi.getter
    def excludes(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        List of branch patterns to exclude.
        """
        return pulumi.get(self, "excludes")

    @excludes.setter
    def excludes(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "excludes", value)

    @property
    @pulumi.getter
    def includes(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        List of branch patterns to include.
        """
        return pulumi.get(self, "includes")

    @includes.setter
    def includes(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "includes", value)


@pulumi.input_type
class BuildDefinitionPullRequestTriggerOverridePathFilterArgs:
    def __init__(__self__, *,
                 excludes: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 includes: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input[str]]] excludes: List of path patterns to exclude.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] includes: List of path patterns to include.
        """
        if excludes is not None:
            pulumi.set(__self__, "excludes", excludes)
        if includes is not None:
            pulumi.set(__self__, "includes", includes)

    @property
    @pulumi.getter
    def excludes(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        List of path patterns to exclude.
        """
        return pulumi.get(self, "excludes")

    @excludes.setter
    def excludes(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "excludes", value)

    @property
    @pulumi.getter
    def includes(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        List of path patterns to include.
        """
        return pulumi.get(self, "includes")

    @includes.setter
    def includes(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "includes", value)


@pulumi.input_type
class BuildDefinitionRepositoryArgs:
    def __init__(__self__, *,
                 repo_id: pulumi.Input[str],
                 repo_type: pulumi.Input[str],
                 yml_path: pulumi.Input[str],
                 branch_name: Optional[pulumi.Input[str]] = None,
                 github_enterprise_url: Optional[pulumi.Input[str]] = None,
                 report_build_status: Optional[pulumi.Input[bool]] = None,
                 service_connection_id: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] repo_id: The id of the repository. For `TfsGit` repos, this is simply the ID of the repository. For `Github` repos, this will take the form of `<GitHub Org>/<Repo Name>`. For `Bitbucket` repos, this will take the form of `<Workspace ID>/<Repo Name>`.
        :param pulumi.Input[str] repo_type: The repository type. Valid values: `GitHub` or `TfsGit` or `Bitbucket` or `GitHub Enterprise`. Defaults to `GitHub`. If `repo_type` is `GitHubEnterprise`, must use existing project and GitHub Enterprise service connection.
        :param pulumi.Input[str] yml_path: The path of the Yaml file describing the build definition.
        :param pulumi.Input[str] branch_name: The branch name for which builds are triggered. Defaults to `master`.
        :param pulumi.Input[str] github_enterprise_url: The Github Enterprise URL. Used if `repo_type` is `GithubEnterprise`.
        :param pulumi.Input[bool] report_build_status: Report build status. Default is true.
        :param pulumi.Input[str] service_connection_id: The service connection ID. Used if the `repo_type` is `GitHub` or `GitHubEnterprise`.
        """
        pulumi.set(__self__, "repo_id", repo_id)
        pulumi.set(__self__, "repo_type", repo_type)
        pulumi.set(__self__, "yml_path", yml_path)
        if branch_name is not None:
            pulumi.set(__self__, "branch_name", branch_name)
        if github_enterprise_url is not None:
            pulumi.set(__self__, "github_enterprise_url", github_enterprise_url)
        if report_build_status is not None:
            pulumi.set(__self__, "report_build_status", report_build_status)
        if service_connection_id is not None:
            pulumi.set(__self__, "service_connection_id", service_connection_id)

    @property
    @pulumi.getter(name="repoId")
    def repo_id(self) -> pulumi.Input[str]:
        """
        The id of the repository. For `TfsGit` repos, this is simply the ID of the repository. For `Github` repos, this will take the form of `<GitHub Org>/<Repo Name>`. For `Bitbucket` repos, this will take the form of `<Workspace ID>/<Repo Name>`.
        """
        return pulumi.get(self, "repo_id")

    @repo_id.setter
    def repo_id(self, value: pulumi.Input[str]):
        pulumi.set(self, "repo_id", value)

    @property
    @pulumi.getter(name="repoType")
    def repo_type(self) -> pulumi.Input[str]:
        """
        The repository type. Valid values: `GitHub` or `TfsGit` or `Bitbucket` or `GitHub Enterprise`. Defaults to `GitHub`. If `repo_type` is `GitHubEnterprise`, must use existing project and GitHub Enterprise service connection.
        """
        return pulumi.get(self, "repo_type")

    @repo_type.setter
    def repo_type(self, value: pulumi.Input[str]):
        pulumi.set(self, "repo_type", value)

    @property
    @pulumi.getter(name="ymlPath")
    def yml_path(self) -> pulumi.Input[str]:
        """
        The path of the Yaml file describing the build definition.
        """
        return pulumi.get(self, "yml_path")

    @yml_path.setter
    def yml_path(self, value: pulumi.Input[str]):
        pulumi.set(self, "yml_path", value)

    @property
    @pulumi.getter(name="branchName")
    def branch_name(self) -> Optional[pulumi.Input[str]]:
        """
        The branch name for which builds are triggered. Defaults to `master`.
        """
        return pulumi.get(self, "branch_name")

    @branch_name.setter
    def branch_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "branch_name", value)

    @property
    @pulumi.getter(name="githubEnterpriseUrl")
    def github_enterprise_url(self) -> Optional[pulumi.Input[str]]:
        """
        The Github Enterprise URL. Used if `repo_type` is `GithubEnterprise`.
        """
        return pulumi.get(self, "github_enterprise_url")

    @github_enterprise_url.setter
    def github_enterprise_url(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "github_enterprise_url", value)

    @property
    @pulumi.getter(name="reportBuildStatus")
    def report_build_status(self) -> Optional[pulumi.Input[bool]]:
        """
        Report build status. Default is true.
        """
        return pulumi.get(self, "report_build_status")

    @report_build_status.setter
    def report_build_status(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "report_build_status", value)

    @property
    @pulumi.getter(name="serviceConnectionId")
    def service_connection_id(self) -> Optional[pulumi.Input[str]]:
        """
        The service connection ID. Used if the `repo_type` is `GitHub` or `GitHubEnterprise`.
        """
        return pulumi.get(self, "service_connection_id")

    @service_connection_id.setter
    def service_connection_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "service_connection_id", value)


@pulumi.input_type
class BuildDefinitionScheduleArgs:
    def __init__(__self__, *,
                 days_to_builds: pulumi.Input[Sequence[pulumi.Input[str]]],
                 branch_filters: Optional[pulumi.Input[Sequence[pulumi.Input['BuildDefinitionScheduleBranchFilterArgs']]]] = None,
                 schedule_job_id: Optional[pulumi.Input[str]] = None,
                 schedule_only_with_changes: Optional[pulumi.Input[bool]] = None,
                 start_hours: Optional[pulumi.Input[int]] = None,
                 start_minutes: Optional[pulumi.Input[int]] = None,
                 time_zone: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input[str]]] days_to_builds: When to build. Valid values: `Mon`, `Tue`, `Wed`, `Thu`, `Fri`, `Sat`, `Sun`.
        :param pulumi.Input[Sequence[pulumi.Input['BuildDefinitionScheduleBranchFilterArgs']]] branch_filters: block supports the following:
        :param pulumi.Input[str] schedule_job_id: The ID of the schedule job
        :param pulumi.Input[bool] schedule_only_with_changes: Schedule builds if the source or pipeline has changed. Defaults to `true`.
        :param pulumi.Input[int] start_hours: Build start hour. Defaults to `0`. Valid values: `0 ~ 23`.
        :param pulumi.Input[int] start_minutes: Build start minute. Defaults to `0`. Valid values: `0 ~ 59`.
        :param pulumi.Input[str] time_zone: Build time zone. Defaults to `(UTC) Coordinated Universal Time`. Valid values: 
               `(UTC-12:00) International Date Line West`,
               `(UTC-11:00) Coordinated Universal Time-11`,
               `(UTC-10:00) Aleutian Islands`,
               `(UTC-10:00) Hawaii`,
               `(UTC-09:30) Marquesas Islands`,
               `(UTC-09:00) Alaska`,
               `(UTC-09:00) Coordinated Universal Time-09`,
               `(UTC-08:00) Baja California`,
               `(UTC-08:00) Coordinated Universal Time-08`,
               `(UTC-08:00) Pacific Time (US &Canada)`,
               `(UTC-07:00) Arizona`,
               `(UTC-07:00) Chihuahua, La Paz, Mazatlan`,
               `(UTC-07:00) Mountain Time (US &Canada)`,
               `(UTC-07:00) Yukon`,
               `(UTC-06:00) Central America`,
               `(UTC-06:00) Central Time (US &Canada)`,
               `(UTC-06:00) Easter Island`,
               `(UTC-06:00) Guadalajara, Mexico City, Monterrey`,
               `(UTC-06:00) Saskatchewan`,
               `(UTC-05:00) Bogota, Lima, Quito, Rio Branco`,
               `(UTC-05:00) Chetumal`,
               `(UTC-05:00) Eastern Time (US &Canada)`,
               `(UTC-05:00) Haiti`,
               `(UTC-05:00) Havana`,
               `(UTC-05:00) Indiana (East)`,
               `(UTC-05:00) Turks and Caicos`,
               `(UTC-04:00) Asuncion`,
               `(UTC-04:00) Atlantic Time (Canada)`,
               `(UTC-04:00) Caracas`,
               `(UTC-04:00) Cuiaba`,
               `(UTC-04:00) Georgetown, La Paz, Manaus, San Juan`,
               `(UTC-04:00) Santiago`,
               `(UTC-03:30) Newfoundland`,
               `(UTC-03:00) Araguaina`,
               `(UTC-03:00) Brasilia`,
               `(UTC-03:00) Cayenne, Fortaleza`,
               `(UTC-03:00) City of Buenos Aires`,
               `(UTC-03:00) Greenland`,
               `(UTC-03:00) Montevideo`,
               `(UTC-03:00) Punta Arenas`,
               `(UTC-03:00) Saint Pierre and Miquelon`,
               `(UTC-03:00) Salvador`,
               `(UTC-02:00) Coordinated Universal Time-02`,
               `(UTC-02:00) Mid-Atlantic - Old`,
               `(UTC-01:00) Azores`,
               `(UTC-01:00) Cabo Verde Is.`,
               `(UTC) Coordinated Universal Time`,
               `(UTC+00:00) Dublin, Edinburgh, Lisbon, London`,
               `(UTC+00:00) Monrovia, Reykjavik`,
               `(UTC+00:00) Sao Tome`,
               `(UTC+01:00) Casablanca`,
               `(UTC+01:00) Amsterdam, Berlin, Bern, Rome, Stockholm, Vienna`,
               `(UTC+01:00) Belgrade, Bratislava, Budapest, Ljubljana, Prague`,
               `(UTC+01:00) Brussels, Copenhagen, Madrid, Paris`,
               `(UTC+01:00) Sarajevo, Skopje, Warsaw, Zagreb`,
               `(UTC+01:00) West Central Africa`,
               `(UTC+02:00) Amman`,
               `(UTC+02:00) Athens, Bucharest`,
               `(UTC+02:00) Beirut`,
               `(UTC+02:00) Cairo`,
               `(UTC+02:00) Chisinau`,
               `(UTC+02:00) Damascus`,
               `(UTC+02:00) Gaza, Hebron`,
               `(UTC+02:00) Harare, Pretoria`,
               `(UTC+02:00) Helsinki, Kyiv, Riga, Sofia, Tallinn, Vilnius`,
               `(UTC+02:00) Jerusalem`,
               `(UTC+02:00) Juba`,
               `(UTC+02:00) Kaliningrad`,
               `(UTC+02:00) Khartoum`,
               `(UTC+02:00) Tripoli`,
               `(UTC+02:00) Windhoek`,
               `(UTC+03:00) Baghdad`,
               `(UTC+03:00) Istanbul`,
               `(UTC+03:00) Kuwait, Riyadh`,
               `(UTC+03:00) Minsk`,
               `(UTC+03:00) Moscow, St. Petersburg`,
               `(UTC+03:00) Nairobi`,
               `(UTC+03:00) Volgograd`,
               `(UTC+03:30) Tehran`,
               `(UTC+04:00) Abu Dhabi, Muscat`,
               `(UTC+04:00) Astrakhan, Ulyanovsk`,
               `(UTC+04:00) Baku`,
               `(UTC+04:00) Izhevsk, Samara`,
               `(UTC+04:00) Port Louis`,
               `(UTC+04:00) Saratov`,
               `(UTC+04:00) Tbilisi`,
               `(UTC+04:00) Yerevan`,
               `(UTC+04:30) Kabul`,
               `(UTC+05:00) Ashgabat, Tashkent`,
               `(UTC+05:00) Ekaterinburg`,
               `(UTC+05:00) Islamabad, Karachi`,
               `(UTC+05:00) Qyzylorda`,
               `(UTC+05:30) Chennai, Kolkata, Mumbai, New Delhi`,
               `(UTC+05:30) Sri Jayawardenepura`,
               `(UTC+05:45) Kathmandu`,
               `(UTC+06:00) Astana`,
               `(UTC+06:00) Dhaka`,
               `(UTC+06:00) Omsk`,
               `(UTC+06:30) Yangon (Rangoon)`,
               `(UTC+07:00) Bangkok, Hanoi, Jakarta`,
               `(UTC+07:00) Barnaul, Gorno-Altaysk`,
               `(UTC+07:00) Hovd`,
               `(UTC+07:00) Krasnoyarsk`,
               `(UTC+07:00) Novosibirsk`,
               `(UTC+07:00) Tomsk`,
               `(UTC+08:00) Beijing, Chongqing, Hong Kong, Urumqi`,
               `(UTC+08:00) Irkutsk`,
               `(UTC+08:00) Kuala Lumpur, Singapore`,
               `(UTC+08:00) Perth`,
               `(UTC+08:00) Taipei`,
               `(UTC+08:00) Ulaanbaatar`,
               `(UTC+08:45) Eucla`,
               `(UTC+09:00) Chita`,
               `(UTC+09:00) Osaka, Sapporo, Tokyo`,
               `(UTC+09:00) Pyongyang`,
               `(UTC+09:00) Seoul`,
               `(UTC+09:00) Yakutsk`,
               `(UTC+09:30) Adelaide`,
               `(UTC+09:30) Darwin`,
               `(UTC+10:00) Brisbane`,
               `(UTC+10:00) Canberra, Melbourne, Sydney`,
               `(UTC+10:00) Guam, Port Moresby`,
               `(UTC+10:00) Hobart`,
               `(UTC+10:00) Vladivostok`,
               `(UTC+10:30) Lord Howe Island`,
               `(UTC+11:00) Bougainville Island`,
               `(UTC+11:00) Chokurdakh`,
               `(UTC+11:00) Magadan`,
               `(UTC+11:00) Norfolk Island`,
               `(UTC+11:00) Sakhalin`,
               `(UTC+11:00) Solomon Is., New Caledonia`,
               `(UTC+12:00) Anadyr, Petropavlovsk-Kamchatsky`,
               `(UTC+12:00) Auckland, Wellington`,
               `(UTC+12:00) Coordinated Universal Time+12`,
               `(UTC+12:00) Fiji`,
               `(UTC+12:00) Petropavlovsk-Kamchatsky - Old`,
               `(UTC+12:45) Chatham Islands`,
               `(UTC+13:00) Coordinated Universal Time+13`,
               `(UTC+13:00) Nuku'alofa`,
               `(UTC+13:00) Samoa`,
               `(UTC+14:00) Kiritimati Island`.
        """
        pulumi.set(__self__, "days_to_builds", days_to_builds)
        if branch_filters is not None:
            pulumi.set(__self__, "branch_filters", branch_filters)
        if schedule_job_id is not None:
            pulumi.set(__self__, "schedule_job_id", schedule_job_id)
        if schedule_only_with_changes is not None:
            pulumi.set(__self__, "schedule_only_with_changes", schedule_only_with_changes)
        if start_hours is not None:
            pulumi.set(__self__, "start_hours", start_hours)
        if start_minutes is not None:
            pulumi.set(__self__, "start_minutes", start_minutes)
        if time_zone is not None:
            pulumi.set(__self__, "time_zone", time_zone)

    @property
    @pulumi.getter(name="daysToBuilds")
    def days_to_builds(self) -> pulumi.Input[Sequence[pulumi.Input[str]]]:
        """
        When to build. Valid values: `Mon`, `Tue`, `Wed`, `Thu`, `Fri`, `Sat`, `Sun`.
        """
        return pulumi.get(self, "days_to_builds")

    @days_to_builds.setter
    def days_to_builds(self, value: pulumi.Input[Sequence[pulumi.Input[str]]]):
        pulumi.set(self, "days_to_builds", value)

    @property
    @pulumi.getter(name="branchFilters")
    def branch_filters(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['BuildDefinitionScheduleBranchFilterArgs']]]]:
        """
        block supports the following:
        """
        return pulumi.get(self, "branch_filters")

    @branch_filters.setter
    def branch_filters(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['BuildDefinitionScheduleBranchFilterArgs']]]]):
        pulumi.set(self, "branch_filters", value)

    @property
    @pulumi.getter(name="scheduleJobId")
    def schedule_job_id(self) -> Optional[pulumi.Input[str]]:
        """
        The ID of the schedule job
        """
        return pulumi.get(self, "schedule_job_id")

    @schedule_job_id.setter
    def schedule_job_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "schedule_job_id", value)

    @property
    @pulumi.getter(name="scheduleOnlyWithChanges")
    def schedule_only_with_changes(self) -> Optional[pulumi.Input[bool]]:
        """
        Schedule builds if the source or pipeline has changed. Defaults to `true`.
        """
        return pulumi.get(self, "schedule_only_with_changes")

    @schedule_only_with_changes.setter
    def schedule_only_with_changes(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "schedule_only_with_changes", value)

    @property
    @pulumi.getter(name="startHours")
    def start_hours(self) -> Optional[pulumi.Input[int]]:
        """
        Build start hour. Defaults to `0`. Valid values: `0 ~ 23`.
        """
        return pulumi.get(self, "start_hours")

    @start_hours.setter
    def start_hours(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "start_hours", value)

    @property
    @pulumi.getter(name="startMinutes")
    def start_minutes(self) -> Optional[pulumi.Input[int]]:
        """
        Build start minute. Defaults to `0`. Valid values: `0 ~ 59`.
        """
        return pulumi.get(self, "start_minutes")

    @start_minutes.setter
    def start_minutes(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "start_minutes", value)

    @property
    @pulumi.getter(name="timeZone")
    def time_zone(self) -> Optional[pulumi.Input[str]]:
        """
        Build time zone. Defaults to `(UTC) Coordinated Universal Time`. Valid values: 
        `(UTC-12:00) International Date Line West`,
        `(UTC-11:00) Coordinated Universal Time-11`,
        `(UTC-10:00) Aleutian Islands`,
        `(UTC-10:00) Hawaii`,
        `(UTC-09:30) Marquesas Islands`,
        `(UTC-09:00) Alaska`,
        `(UTC-09:00) Coordinated Universal Time-09`,
        `(UTC-08:00) Baja California`,
        `(UTC-08:00) Coordinated Universal Time-08`,
        `(UTC-08:00) Pacific Time (US &Canada)`,
        `(UTC-07:00) Arizona`,
        `(UTC-07:00) Chihuahua, La Paz, Mazatlan`,
        `(UTC-07:00) Mountain Time (US &Canada)`,
        `(UTC-07:00) Yukon`,
        `(UTC-06:00) Central America`,
        `(UTC-06:00) Central Time (US &Canada)`,
        `(UTC-06:00) Easter Island`,
        `(UTC-06:00) Guadalajara, Mexico City, Monterrey`,
        `(UTC-06:00) Saskatchewan`,
        `(UTC-05:00) Bogota, Lima, Quito, Rio Branco`,
        `(UTC-05:00) Chetumal`,
        `(UTC-05:00) Eastern Time (US &Canada)`,
        `(UTC-05:00) Haiti`,
        `(UTC-05:00) Havana`,
        `(UTC-05:00) Indiana (East)`,
        `(UTC-05:00) Turks and Caicos`,
        `(UTC-04:00) Asuncion`,
        `(UTC-04:00) Atlantic Time (Canada)`,
        `(UTC-04:00) Caracas`,
        `(UTC-04:00) Cuiaba`,
        `(UTC-04:00) Georgetown, La Paz, Manaus, San Juan`,
        `(UTC-04:00) Santiago`,
        `(UTC-03:30) Newfoundland`,
        `(UTC-03:00) Araguaina`,
        `(UTC-03:00) Brasilia`,
        `(UTC-03:00) Cayenne, Fortaleza`,
        `(UTC-03:00) City of Buenos Aires`,
        `(UTC-03:00) Greenland`,
        `(UTC-03:00) Montevideo`,
        `(UTC-03:00) Punta Arenas`,
        `(UTC-03:00) Saint Pierre and Miquelon`,
        `(UTC-03:00) Salvador`,
        `(UTC-02:00) Coordinated Universal Time-02`,
        `(UTC-02:00) Mid-Atlantic - Old`,
        `(UTC-01:00) Azores`,
        `(UTC-01:00) Cabo Verde Is.`,
        `(UTC) Coordinated Universal Time`,
        `(UTC+00:00) Dublin, Edinburgh, Lisbon, London`,
        `(UTC+00:00) Monrovia, Reykjavik`,
        `(UTC+00:00) Sao Tome`,
        `(UTC+01:00) Casablanca`,
        `(UTC+01:00) Amsterdam, Berlin, Bern, Rome, Stockholm, Vienna`,
        `(UTC+01:00) Belgrade, Bratislava, Budapest, Ljubljana, Prague`,
        `(UTC+01:00) Brussels, Copenhagen, Madrid, Paris`,
        `(UTC+01:00) Sarajevo, Skopje, Warsaw, Zagreb`,
        `(UTC+01:00) West Central Africa`,
        `(UTC+02:00) Amman`,
        `(UTC+02:00) Athens, Bucharest`,
        `(UTC+02:00) Beirut`,
        `(UTC+02:00) Cairo`,
        `(UTC+02:00) Chisinau`,
        `(UTC+02:00) Damascus`,
        `(UTC+02:00) Gaza, Hebron`,
        `(UTC+02:00) Harare, Pretoria`,
        `(UTC+02:00) Helsinki, Kyiv, Riga, Sofia, Tallinn, Vilnius`,
        `(UTC+02:00) Jerusalem`,
        `(UTC+02:00) Juba`,
        `(UTC+02:00) Kaliningrad`,
        `(UTC+02:00) Khartoum`,
        `(UTC+02:00) Tripoli`,
        `(UTC+02:00) Windhoek`,
        `(UTC+03:00) Baghdad`,
        `(UTC+03:00) Istanbul`,
        `(UTC+03:00) Kuwait, Riyadh`,
        `(UTC+03:00) Minsk`,
        `(UTC+03:00) Moscow, St. Petersburg`,
        `(UTC+03:00) Nairobi`,
        `(UTC+03:00) Volgograd`,
        `(UTC+03:30) Tehran`,
        `(UTC+04:00) Abu Dhabi, Muscat`,
        `(UTC+04:00) Astrakhan, Ulyanovsk`,
        `(UTC+04:00) Baku`,
        `(UTC+04:00) Izhevsk, Samara`,
        `(UTC+04:00) Port Louis`,
        `(UTC+04:00) Saratov`,
        `(UTC+04:00) Tbilisi`,
        `(UTC+04:00) Yerevan`,
        `(UTC+04:30) Kabul`,
        `(UTC+05:00) Ashgabat, Tashkent`,
        `(UTC+05:00) Ekaterinburg`,
        `(UTC+05:00) Islamabad, Karachi`,
        `(UTC+05:00) Qyzylorda`,
        `(UTC+05:30) Chennai, Kolkata, Mumbai, New Delhi`,
        `(UTC+05:30) Sri Jayawardenepura`,
        `(UTC+05:45) Kathmandu`,
        `(UTC+06:00) Astana`,
        `(UTC+06:00) Dhaka`,
        `(UTC+06:00) Omsk`,
        `(UTC+06:30) Yangon (Rangoon)`,
        `(UTC+07:00) Bangkok, Hanoi, Jakarta`,
        `(UTC+07:00) Barnaul, Gorno-Altaysk`,
        `(UTC+07:00) Hovd`,
        `(UTC+07:00) Krasnoyarsk`,
        `(UTC+07:00) Novosibirsk`,
        `(UTC+07:00) Tomsk`,
        `(UTC+08:00) Beijing, Chongqing, Hong Kong, Urumqi`,
        `(UTC+08:00) Irkutsk`,
        `(UTC+08:00) Kuala Lumpur, Singapore`,
        `(UTC+08:00) Perth`,
        `(UTC+08:00) Taipei`,
        `(UTC+08:00) Ulaanbaatar`,
        `(UTC+08:45) Eucla`,
        `(UTC+09:00) Chita`,
        `(UTC+09:00) Osaka, Sapporo, Tokyo`,
        `(UTC+09:00) Pyongyang`,
        `(UTC+09:00) Seoul`,
        `(UTC+09:00) Yakutsk`,
        `(UTC+09:30) Adelaide`,
        `(UTC+09:30) Darwin`,
        `(UTC+10:00) Brisbane`,
        `(UTC+10:00) Canberra, Melbourne, Sydney`,
        `(UTC+10:00) Guam, Port Moresby`,
        `(UTC+10:00) Hobart`,
        `(UTC+10:00) Vladivostok`,
        `(UTC+10:30) Lord Howe Island`,
        `(UTC+11:00) Bougainville Island`,
        `(UTC+11:00) Chokurdakh`,
        `(UTC+11:00) Magadan`,
        `(UTC+11:00) Norfolk Island`,
        `(UTC+11:00) Sakhalin`,
        `(UTC+11:00) Solomon Is., New Caledonia`,
        `(UTC+12:00) Anadyr, Petropavlovsk-Kamchatsky`,
        `(UTC+12:00) Auckland, Wellington`,
        `(UTC+12:00) Coordinated Universal Time+12`,
        `(UTC+12:00) Fiji`,
        `(UTC+12:00) Petropavlovsk-Kamchatsky - Old`,
        `(UTC+12:45) Chatham Islands`,
        `(UTC+13:00) Coordinated Universal Time+13`,
        `(UTC+13:00) Nuku'alofa`,
        `(UTC+13:00) Samoa`,
        `(UTC+14:00) Kiritimati Island`.
        """
        return pulumi.get(self, "time_zone")

    @time_zone.setter
    def time_zone(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "time_zone", value)


@pulumi.input_type
class BuildDefinitionScheduleBranchFilterArgs:
    def __init__(__self__, *,
                 excludes: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 includes: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input[str]]] excludes: List of branch patterns to exclude.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] includes: List of branch patterns to include.
        """
        if excludes is not None:
            pulumi.set(__self__, "excludes", excludes)
        if includes is not None:
            pulumi.set(__self__, "includes", includes)

    @property
    @pulumi.getter
    def excludes(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        List of branch patterns to exclude.
        """
        return pulumi.get(self, "excludes")

    @excludes.setter
    def excludes(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "excludes", value)

    @property
    @pulumi.getter
    def includes(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        List of branch patterns to include.
        """
        return pulumi.get(self, "includes")

    @includes.setter
    def includes(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "includes", value)


@pulumi.input_type
class BuildDefinitionVariableArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[str],
                 allow_override: Optional[pulumi.Input[bool]] = None,
                 is_secret: Optional[pulumi.Input[bool]] = None,
                 secret_value: Optional[pulumi.Input[str]] = None,
                 value: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] name: The name of the variable.
        :param pulumi.Input[bool] allow_override: True if the variable can be overridden. Defaults to `true`.
        :param pulumi.Input[bool] is_secret: True if the variable is a secret. Defaults to `false`.
        :param pulumi.Input[str] secret_value: The secret value of the variable. Used when `is_secret` set to `true`.
        :param pulumi.Input[str] value: The value of the variable.
        """
        pulumi.set(__self__, "name", name)
        if allow_override is not None:
            pulumi.set(__self__, "allow_override", allow_override)
        if is_secret is not None:
            pulumi.set(__self__, "is_secret", is_secret)
        if secret_value is not None:
            pulumi.set(__self__, "secret_value", secret_value)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        The name of the variable.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter(name="allowOverride")
    def allow_override(self) -> Optional[pulumi.Input[bool]]:
        """
        True if the variable can be overridden. Defaults to `true`.
        """
        return pulumi.get(self, "allow_override")

    @allow_override.setter
    def allow_override(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "allow_override", value)

    @property
    @pulumi.getter(name="isSecret")
    def is_secret(self) -> Optional[pulumi.Input[bool]]:
        """
        True if the variable is a secret. Defaults to `false`.
        """
        return pulumi.get(self, "is_secret")

    @is_secret.setter
    def is_secret(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "is_secret", value)

    @property
    @pulumi.getter(name="secretValue")
    def secret_value(self) -> Optional[pulumi.Input[str]]:
        """
        The secret value of the variable. Used when `is_secret` set to `true`.
        """
        return pulumi.get(self, "secret_value")

    @secret_value.setter
    def secret_value(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "secret_value", value)

    @property
    @pulumi.getter
    def value(self) -> Optional[pulumi.Input[str]]:
        """
        The value of the variable.
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "value", value)


@pulumi.input_type
class CheckRequiredTemplateRequiredTemplateArgs:
    def __init__(__self__, *,
                 repository_name: pulumi.Input[str],
                 repository_ref: pulumi.Input[str],
                 template_path: pulumi.Input[str],
                 repository_type: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] repository_name: The name of the repository storing the template.
        :param pulumi.Input[str] repository_ref: The branch in which the template will be referenced.
        :param pulumi.Input[str] template_path: The path to the template yaml.
        :param pulumi.Input[str] repository_type: The type of the repository storing the template. Valid values: `azuregit`, `github`, `bitbucket`. Defaults to `azuregit`.
        """
        pulumi.set(__self__, "repository_name", repository_name)
        pulumi.set(__self__, "repository_ref", repository_ref)
        pulumi.set(__self__, "template_path", template_path)
        if repository_type is not None:
            pulumi.set(__self__, "repository_type", repository_type)

    @property
    @pulumi.getter(name="repositoryName")
    def repository_name(self) -> pulumi.Input[str]:
        """
        The name of the repository storing the template.
        """
        return pulumi.get(self, "repository_name")

    @repository_name.setter
    def repository_name(self, value: pulumi.Input[str]):
        pulumi.set(self, "repository_name", value)

    @property
    @pulumi.getter(name="repositoryRef")
    def repository_ref(self) -> pulumi.Input[str]:
        """
        The branch in which the template will be referenced.
        """
        return pulumi.get(self, "repository_ref")

    @repository_ref.setter
    def repository_ref(self, value: pulumi.Input[str]):
        pulumi.set(self, "repository_ref", value)

    @property
    @pulumi.getter(name="templatePath")
    def template_path(self) -> pulumi.Input[str]:
        """
        The path to the template yaml.
        """
        return pulumi.get(self, "template_path")

    @template_path.setter
    def template_path(self, value: pulumi.Input[str]):
        pulumi.set(self, "template_path", value)

    @property
    @pulumi.getter(name="repositoryType")
    def repository_type(self) -> Optional[pulumi.Input[str]]:
        """
        The type of the repository storing the template. Valid values: `azuregit`, `github`, `bitbucket`. Defaults to `azuregit`.
        """
        return pulumi.get(self, "repository_type")

    @repository_type.setter
    def repository_type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "repository_type", value)


@pulumi.input_type
class GitInitializationArgs:
    def __init__(__self__, *,
                 init_type: pulumi.Input[str],
                 service_connection_id: Optional[pulumi.Input[str]] = None,
                 source_type: Optional[pulumi.Input[str]] = None,
                 source_url: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] init_type: The type of repository to create. Valid values: `Uninitialized`, `Clean` or `Import`.
        :param pulumi.Input[str] service_connection_id: The id of service connection used to authenticate to a private repository for import initialization.
        :param pulumi.Input[str] source_type: Type of the source repository. Used if the `init_type` is `Import`. Valid values: `Git`.
        :param pulumi.Input[str] source_url: The URL of the source repository. Used if the `init_type` is `Import`.
        """
        pulumi.set(__self__, "init_type", init_type)
        if service_connection_id is not None:
            pulumi.set(__self__, "service_connection_id", service_connection_id)
        if source_type is not None:
            pulumi.set(__self__, "source_type", source_type)
        if source_url is not None:
            pulumi.set(__self__, "source_url", source_url)

    @property
    @pulumi.getter(name="initType")
    def init_type(self) -> pulumi.Input[str]:
        """
        The type of repository to create. Valid values: `Uninitialized`, `Clean` or `Import`.
        """
        return pulumi.get(self, "init_type")

    @init_type.setter
    def init_type(self, value: pulumi.Input[str]):
        pulumi.set(self, "init_type", value)

    @property
    @pulumi.getter(name="serviceConnectionId")
    def service_connection_id(self) -> Optional[pulumi.Input[str]]:
        """
        The id of service connection used to authenticate to a private repository for import initialization.
        """
        return pulumi.get(self, "service_connection_id")

    @service_connection_id.setter
    def service_connection_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "service_connection_id", value)

    @property
    @pulumi.getter(name="sourceType")
    def source_type(self) -> Optional[pulumi.Input[str]]:
        """
        Type of the source repository. Used if the `init_type` is `Import`. Valid values: `Git`.
        """
        return pulumi.get(self, "source_type")

    @source_type.setter
    def source_type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "source_type", value)

    @property
    @pulumi.getter(name="sourceUrl")
    def source_url(self) -> Optional[pulumi.Input[str]]:
        """
        The URL of the source repository. Used if the `init_type` is `Import`.
        """
        return pulumi.get(self, "source_url")

    @source_url.setter
    def source_url(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "source_url", value)


@pulumi.input_type
class ServiceEndpointArtifactoryAuthenticationBasicArgs:
    def __init__(__self__, *,
                 password: pulumi.Input[str],
                 username: pulumi.Input[str]):
        """
        :param pulumi.Input[str] password: Artifactory Password.
        :param pulumi.Input[str] username: Artifactory Username.
        """
        pulumi.set(__self__, "password", password)
        pulumi.set(__self__, "username", username)

    @property
    @pulumi.getter
    def password(self) -> pulumi.Input[str]:
        """
        Artifactory Password.
        """
        return pulumi.get(self, "password")

    @password.setter
    def password(self, value: pulumi.Input[str]):
        pulumi.set(self, "password", value)

    @property
    @pulumi.getter
    def username(self) -> pulumi.Input[str]:
        """
        Artifactory Username.
        """
        return pulumi.get(self, "username")

    @username.setter
    def username(self, value: pulumi.Input[str]):
        pulumi.set(self, "username", value)


@pulumi.input_type
class ServiceEndpointArtifactoryAuthenticationTokenArgs:
    def __init__(__self__, *,
                 token: pulumi.Input[str]):
        """
        :param pulumi.Input[str] token: Authentication Token generated through Artifactory.
        """
        pulumi.set(__self__, "token", token)

    @property
    @pulumi.getter
    def token(self) -> pulumi.Input[str]:
        """
        Authentication Token generated through Artifactory.
        """
        return pulumi.get(self, "token")

    @token.setter
    def token(self, value: pulumi.Input[str]):
        pulumi.set(self, "token", value)


@pulumi.input_type
class ServiceEndpointAzureRMCredentialsArgs:
    def __init__(__self__, *,
                 serviceprincipalid: pulumi.Input[str],
                 serviceprincipalkey: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] serviceprincipalid: The service principal application Id
        :param pulumi.Input[str] serviceprincipalkey: The service principal secret. This not required if `service_endpoint_authentication_scheme` is set to `WorkloadIdentityFederation`.
        """
        pulumi.set(__self__, "serviceprincipalid", serviceprincipalid)
        if serviceprincipalkey is not None:
            pulumi.set(__self__, "serviceprincipalkey", serviceprincipalkey)

    @property
    @pulumi.getter
    def serviceprincipalid(self) -> pulumi.Input[str]:
        """
        The service principal application Id
        """
        return pulumi.get(self, "serviceprincipalid")

    @serviceprincipalid.setter
    def serviceprincipalid(self, value: pulumi.Input[str]):
        pulumi.set(self, "serviceprincipalid", value)

    @property
    @pulumi.getter
    def serviceprincipalkey(self) -> Optional[pulumi.Input[str]]:
        """
        The service principal secret. This not required if `service_endpoint_authentication_scheme` is set to `WorkloadIdentityFederation`.
        """
        return pulumi.get(self, "serviceprincipalkey")

    @serviceprincipalkey.setter
    def serviceprincipalkey(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "serviceprincipalkey", value)


@pulumi.input_type
class ServiceEndpointGitHubAuthOauthArgs:
    def __init__(__self__, *,
                 oauth_configuration_id: pulumi.Input[str]):
        pulumi.set(__self__, "oauth_configuration_id", oauth_configuration_id)

    @property
    @pulumi.getter(name="oauthConfigurationId")
    def oauth_configuration_id(self) -> pulumi.Input[str]:
        return pulumi.get(self, "oauth_configuration_id")

    @oauth_configuration_id.setter
    def oauth_configuration_id(self, value: pulumi.Input[str]):
        pulumi.set(self, "oauth_configuration_id", value)


@pulumi.input_type
class ServiceEndpointGitHubAuthPersonalArgs:
    def __init__(__self__, *,
                 personal_access_token: pulumi.Input[str]):
        """
        :param pulumi.Input[str] personal_access_token: The Personal Access Token for GitHub.
        """
        pulumi.set(__self__, "personal_access_token", personal_access_token)

    @property
    @pulumi.getter(name="personalAccessToken")
    def personal_access_token(self) -> pulumi.Input[str]:
        """
        The Personal Access Token for GitHub.
        """
        return pulumi.get(self, "personal_access_token")

    @personal_access_token.setter
    def personal_access_token(self, value: pulumi.Input[str]):
        pulumi.set(self, "personal_access_token", value)


@pulumi.input_type
class ServiceEndpointGitHubEnterpriseAuthPersonalArgs:
    def __init__(__self__, *,
                 personal_access_token: pulumi.Input[str]):
        """
        :param pulumi.Input[str] personal_access_token: The Personal Access Token for GitHub.
        """
        pulumi.set(__self__, "personal_access_token", personal_access_token)

    @property
    @pulumi.getter(name="personalAccessToken")
    def personal_access_token(self) -> pulumi.Input[str]:
        """
        The Personal Access Token for GitHub.
        """
        return pulumi.get(self, "personal_access_token")

    @personal_access_token.setter
    def personal_access_token(self, value: pulumi.Input[str]):
        pulumi.set(self, "personal_access_token", value)


@pulumi.input_type
class ServiceEndpointKubernetesAzureSubscriptionArgs:
    def __init__(__self__, *,
                 cluster_name: pulumi.Input[str],
                 resourcegroup_id: pulumi.Input[str],
                 subscription_id: pulumi.Input[str],
                 subscription_name: pulumi.Input[str],
                 tenant_id: pulumi.Input[str],
                 azure_environment: Optional[pulumi.Input[str]] = None,
                 cluster_admin: Optional[pulumi.Input[bool]] = None,
                 namespace: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] cluster_name: The name of the Kubernetes cluster.
        :param pulumi.Input[str] resourcegroup_id: The resource group name, to which the Kubernetes cluster is deployed.
        :param pulumi.Input[str] subscription_id: The id of the Azure subscription.
        :param pulumi.Input[str] subscription_name: The name of the Azure subscription.
        :param pulumi.Input[str] tenant_id: The id of the tenant used by the subscription.
        :param pulumi.Input[str] azure_environment: Azure environment refers to whether the public cloud offering or domestic (government) clouds are being used. Currently, only the public cloud is supported. The value must be AzureCloud. This is also the default-value.
        :param pulumi.Input[bool] cluster_admin: Set this option to allow use cluster admin credentials.
        :param pulumi.Input[str] namespace: The Kubernetes namespace. Default value is "default".
        """
        pulumi.set(__self__, "cluster_name", cluster_name)
        pulumi.set(__self__, "resourcegroup_id", resourcegroup_id)
        pulumi.set(__self__, "subscription_id", subscription_id)
        pulumi.set(__self__, "subscription_name", subscription_name)
        pulumi.set(__self__, "tenant_id", tenant_id)
        if azure_environment is not None:
            pulumi.set(__self__, "azure_environment", azure_environment)
        if cluster_admin is not None:
            pulumi.set(__self__, "cluster_admin", cluster_admin)
        if namespace is not None:
            pulumi.set(__self__, "namespace", namespace)

    @property
    @pulumi.getter(name="clusterName")
    def cluster_name(self) -> pulumi.Input[str]:
        """
        The name of the Kubernetes cluster.
        """
        return pulumi.get(self, "cluster_name")

    @cluster_name.setter
    def cluster_name(self, value: pulumi.Input[str]):
        pulumi.set(self, "cluster_name", value)

    @property
    @pulumi.getter(name="resourcegroupId")
    def resourcegroup_id(self) -> pulumi.Input[str]:
        """
        The resource group name, to which the Kubernetes cluster is deployed.
        """
        return pulumi.get(self, "resourcegroup_id")

    @resourcegroup_id.setter
    def resourcegroup_id(self, value: pulumi.Input[str]):
        pulumi.set(self, "resourcegroup_id", value)

    @property
    @pulumi.getter(name="subscriptionId")
    def subscription_id(self) -> pulumi.Input[str]:
        """
        The id of the Azure subscription.
        """
        return pulumi.get(self, "subscription_id")

    @subscription_id.setter
    def subscription_id(self, value: pulumi.Input[str]):
        pulumi.set(self, "subscription_id", value)

    @property
    @pulumi.getter(name="subscriptionName")
    def subscription_name(self) -> pulumi.Input[str]:
        """
        The name of the Azure subscription.
        """
        return pulumi.get(self, "subscription_name")

    @subscription_name.setter
    def subscription_name(self, value: pulumi.Input[str]):
        pulumi.set(self, "subscription_name", value)

    @property
    @pulumi.getter(name="tenantId")
    def tenant_id(self) -> pulumi.Input[str]:
        """
        The id of the tenant used by the subscription.
        """
        return pulumi.get(self, "tenant_id")

    @tenant_id.setter
    def tenant_id(self, value: pulumi.Input[str]):
        pulumi.set(self, "tenant_id", value)

    @property
    @pulumi.getter(name="azureEnvironment")
    def azure_environment(self) -> Optional[pulumi.Input[str]]:
        """
        Azure environment refers to whether the public cloud offering or domestic (government) clouds are being used. Currently, only the public cloud is supported. The value must be AzureCloud. This is also the default-value.
        """
        return pulumi.get(self, "azure_environment")

    @azure_environment.setter
    def azure_environment(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "azure_environment", value)

    @property
    @pulumi.getter(name="clusterAdmin")
    def cluster_admin(self) -> Optional[pulumi.Input[bool]]:
        """
        Set this option to allow use cluster admin credentials.
        """
        return pulumi.get(self, "cluster_admin")

    @cluster_admin.setter
    def cluster_admin(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "cluster_admin", value)

    @property
    @pulumi.getter
    def namespace(self) -> Optional[pulumi.Input[str]]:
        """
        The Kubernetes namespace. Default value is "default".
        """
        return pulumi.get(self, "namespace")

    @namespace.setter
    def namespace(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "namespace", value)


@pulumi.input_type
class ServiceEndpointKubernetesKubeconfigArgs:
    def __init__(__self__, *,
                 kube_config: pulumi.Input[str],
                 accept_untrusted_certs: Optional[pulumi.Input[bool]] = None,
                 cluster_context: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] kube_config: The content of the kubeconfig in yaml notation to be used to communicate with the API-Server of Kubernetes.
        :param pulumi.Input[bool] accept_untrusted_certs: Set this option to allow clients to accept a self-signed certificate.
        :param pulumi.Input[str] cluster_context: Context within the kubeconfig file that is to be used for identifying the cluster. Default value is the current-context set in kubeconfig.
        """
        pulumi.set(__self__, "kube_config", kube_config)
        if accept_untrusted_certs is not None:
            pulumi.set(__self__, "accept_untrusted_certs", accept_untrusted_certs)
        if cluster_context is not None:
            pulumi.set(__self__, "cluster_context", cluster_context)

    @property
    @pulumi.getter(name="kubeConfig")
    def kube_config(self) -> pulumi.Input[str]:
        """
        The content of the kubeconfig in yaml notation to be used to communicate with the API-Server of Kubernetes.
        """
        return pulumi.get(self, "kube_config")

    @kube_config.setter
    def kube_config(self, value: pulumi.Input[str]):
        pulumi.set(self, "kube_config", value)

    @property
    @pulumi.getter(name="acceptUntrustedCerts")
    def accept_untrusted_certs(self) -> Optional[pulumi.Input[bool]]:
        """
        Set this option to allow clients to accept a self-signed certificate.
        """
        return pulumi.get(self, "accept_untrusted_certs")

    @accept_untrusted_certs.setter
    def accept_untrusted_certs(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "accept_untrusted_certs", value)

    @property
    @pulumi.getter(name="clusterContext")
    def cluster_context(self) -> Optional[pulumi.Input[str]]:
        """
        Context within the kubeconfig file that is to be used for identifying the cluster. Default value is the current-context set in kubeconfig.
        """
        return pulumi.get(self, "cluster_context")

    @cluster_context.setter
    def cluster_context(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "cluster_context", value)


@pulumi.input_type
class ServiceEndpointKubernetesServiceAccountArgs:
    def __init__(__self__, *,
                 ca_cert: pulumi.Input[str],
                 token: pulumi.Input[str]):
        """
        :param pulumi.Input[str] ca_cert: The certificate from a Kubernetes secret object.
        :param pulumi.Input[str] token: The token from a Kubernetes secret object.
        """
        pulumi.set(__self__, "ca_cert", ca_cert)
        pulumi.set(__self__, "token", token)

    @property
    @pulumi.getter(name="caCert")
    def ca_cert(self) -> pulumi.Input[str]:
        """
        The certificate from a Kubernetes secret object.
        """
        return pulumi.get(self, "ca_cert")

    @ca_cert.setter
    def ca_cert(self, value: pulumi.Input[str]):
        pulumi.set(self, "ca_cert", value)

    @property
    @pulumi.getter
    def token(self) -> pulumi.Input[str]:
        """
        The token from a Kubernetes secret object.
        """
        return pulumi.get(self, "token")

    @token.setter
    def token(self, value: pulumi.Input[str]):
        pulumi.set(self, "token", value)


@pulumi.input_type
class ServiceEndpointPipelineAuthPersonalArgs:
    def __init__(__self__, *,
                 personal_access_token: pulumi.Input[str]):
        """
        :param pulumi.Input[str] personal_access_token: The Personal Access Token for Azure DevOps Pipeline. It also can be set with AZDO_PERSONAL_ACCESS_TOKEN environment variable.
        """
        pulumi.set(__self__, "personal_access_token", personal_access_token)

    @property
    @pulumi.getter(name="personalAccessToken")
    def personal_access_token(self) -> pulumi.Input[str]:
        """
        The Personal Access Token for Azure DevOps Pipeline. It also can be set with AZDO_PERSONAL_ACCESS_TOKEN environment variable.
        """
        return pulumi.get(self, "personal_access_token")

    @personal_access_token.setter
    def personal_access_token(self, value: pulumi.Input[str]):
        pulumi.set(self, "personal_access_token", value)


@pulumi.input_type
class ServiceEndpointServiceFabricAzureActiveDirectoryArgs:
    def __init__(__self__, *,
                 password: pulumi.Input[str],
                 server_certificate_lookup: pulumi.Input[str],
                 username: pulumi.Input[str],
                 server_certificate_common_name: Optional[pulumi.Input[str]] = None,
                 server_certificate_thumbprint: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] password: Password for the Azure Active Directory account.
        :param pulumi.Input[str] server_certificate_lookup: Verification mode for the cluster. Possible values include `Thumbprint` or `CommonName`.
        :param pulumi.Input[str] username: Specify an Azure Active Directory account.
        :param pulumi.Input[str] server_certificate_common_name: The common name(s) of the cluster's certificate(s). This is used to verify the identity of the cluster. This value overrides the publish profile. Separate multiple common names with a comma (',')
        :param pulumi.Input[str] server_certificate_thumbprint: The thumbprint(s) of the cluster's certificate(s). This is used to verify the identity of the cluster. This value overrides the publish profile. Separate multiple thumbprints with a comma (',')
        """
        pulumi.set(__self__, "password", password)
        pulumi.set(__self__, "server_certificate_lookup", server_certificate_lookup)
        pulumi.set(__self__, "username", username)
        if server_certificate_common_name is not None:
            pulumi.set(__self__, "server_certificate_common_name", server_certificate_common_name)
        if server_certificate_thumbprint is not None:
            pulumi.set(__self__, "server_certificate_thumbprint", server_certificate_thumbprint)

    @property
    @pulumi.getter
    def password(self) -> pulumi.Input[str]:
        """
        Password for the Azure Active Directory account.
        """
        return pulumi.get(self, "password")

    @password.setter
    def password(self, value: pulumi.Input[str]):
        pulumi.set(self, "password", value)

    @property
    @pulumi.getter(name="serverCertificateLookup")
    def server_certificate_lookup(self) -> pulumi.Input[str]:
        """
        Verification mode for the cluster. Possible values include `Thumbprint` or `CommonName`.
        """
        return pulumi.get(self, "server_certificate_lookup")

    @server_certificate_lookup.setter
    def server_certificate_lookup(self, value: pulumi.Input[str]):
        pulumi.set(self, "server_certificate_lookup", value)

    @property
    @pulumi.getter
    def username(self) -> pulumi.Input[str]:
        """
        Specify an Azure Active Directory account.
        """
        return pulumi.get(self, "username")

    @username.setter
    def username(self, value: pulumi.Input[str]):
        pulumi.set(self, "username", value)

    @property
    @pulumi.getter(name="serverCertificateCommonName")
    def server_certificate_common_name(self) -> Optional[pulumi.Input[str]]:
        """
        The common name(s) of the cluster's certificate(s). This is used to verify the identity of the cluster. This value overrides the publish profile. Separate multiple common names with a comma (',')
        """
        return pulumi.get(self, "server_certificate_common_name")

    @server_certificate_common_name.setter
    def server_certificate_common_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "server_certificate_common_name", value)

    @property
    @pulumi.getter(name="serverCertificateThumbprint")
    def server_certificate_thumbprint(self) -> Optional[pulumi.Input[str]]:
        """
        The thumbprint(s) of the cluster's certificate(s). This is used to verify the identity of the cluster. This value overrides the publish profile. Separate multiple thumbprints with a comma (',')
        """
        return pulumi.get(self, "server_certificate_thumbprint")

    @server_certificate_thumbprint.setter
    def server_certificate_thumbprint(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "server_certificate_thumbprint", value)


@pulumi.input_type
class ServiceEndpointServiceFabricCertificateArgs:
    def __init__(__self__, *,
                 client_certificate: pulumi.Input[str],
                 server_certificate_lookup: pulumi.Input[str],
                 client_certificate_password: Optional[pulumi.Input[str]] = None,
                 server_certificate_common_name: Optional[pulumi.Input[str]] = None,
                 server_certificate_thumbprint: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] client_certificate: Base64 encoding of the cluster's client certificate file.
        :param pulumi.Input[str] server_certificate_lookup: Verification mode for the cluster. Possible values include `Thumbprint` or `CommonName`.
        :param pulumi.Input[str] client_certificate_password: Password for the certificate.
        :param pulumi.Input[str] server_certificate_common_name: The common name(s) of the cluster's certificate(s). This is used to verify the identity of the cluster. This value overrides the publish profile. Separate multiple common names with a comma (',')
        :param pulumi.Input[str] server_certificate_thumbprint: The thumbprint(s) of the cluster's certificate(s). This is used to verify the identity of the cluster. This value overrides the publish profile. Separate multiple thumbprints with a comma (',')
        """
        pulumi.set(__self__, "client_certificate", client_certificate)
        pulumi.set(__self__, "server_certificate_lookup", server_certificate_lookup)
        if client_certificate_password is not None:
            pulumi.set(__self__, "client_certificate_password", client_certificate_password)
        if server_certificate_common_name is not None:
            pulumi.set(__self__, "server_certificate_common_name", server_certificate_common_name)
        if server_certificate_thumbprint is not None:
            pulumi.set(__self__, "server_certificate_thumbprint", server_certificate_thumbprint)

    @property
    @pulumi.getter(name="clientCertificate")
    def client_certificate(self) -> pulumi.Input[str]:
        """
        Base64 encoding of the cluster's client certificate file.
        """
        return pulumi.get(self, "client_certificate")

    @client_certificate.setter
    def client_certificate(self, value: pulumi.Input[str]):
        pulumi.set(self, "client_certificate", value)

    @property
    @pulumi.getter(name="serverCertificateLookup")
    def server_certificate_lookup(self) -> pulumi.Input[str]:
        """
        Verification mode for the cluster. Possible values include `Thumbprint` or `CommonName`.
        """
        return pulumi.get(self, "server_certificate_lookup")

    @server_certificate_lookup.setter
    def server_certificate_lookup(self, value: pulumi.Input[str]):
        pulumi.set(self, "server_certificate_lookup", value)

    @property
    @pulumi.getter(name="clientCertificatePassword")
    def client_certificate_password(self) -> Optional[pulumi.Input[str]]:
        """
        Password for the certificate.
        """
        return pulumi.get(self, "client_certificate_password")

    @client_certificate_password.setter
    def client_certificate_password(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "client_certificate_password", value)

    @property
    @pulumi.getter(name="serverCertificateCommonName")
    def server_certificate_common_name(self) -> Optional[pulumi.Input[str]]:
        """
        The common name(s) of the cluster's certificate(s). This is used to verify the identity of the cluster. This value overrides the publish profile. Separate multiple common names with a comma (',')
        """
        return pulumi.get(self, "server_certificate_common_name")

    @server_certificate_common_name.setter
    def server_certificate_common_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "server_certificate_common_name", value)

    @property
    @pulumi.getter(name="serverCertificateThumbprint")
    def server_certificate_thumbprint(self) -> Optional[pulumi.Input[str]]:
        """
        The thumbprint(s) of the cluster's certificate(s). This is used to verify the identity of the cluster. This value overrides the publish profile. Separate multiple thumbprints with a comma (',')
        """
        return pulumi.get(self, "server_certificate_thumbprint")

    @server_certificate_thumbprint.setter
    def server_certificate_thumbprint(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "server_certificate_thumbprint", value)


@pulumi.input_type
class ServiceEndpointServiceFabricNoneArgs:
    def __init__(__self__, *,
                 cluster_spn: Optional[pulumi.Input[str]] = None,
                 unsecured: Optional[pulumi.Input[bool]] = None):
        """
        :param pulumi.Input[str] cluster_spn: Fully qualified domain SPN for gMSA account. This is applicable only if `unsecured` option is disabled.
        :param pulumi.Input[bool] unsecured: Skip using windows security for authentication.
        """
        if cluster_spn is not None:
            pulumi.set(__self__, "cluster_spn", cluster_spn)
        if unsecured is not None:
            pulumi.set(__self__, "unsecured", unsecured)

    @property
    @pulumi.getter(name="clusterSpn")
    def cluster_spn(self) -> Optional[pulumi.Input[str]]:
        """
        Fully qualified domain SPN for gMSA account. This is applicable only if `unsecured` option is disabled.
        """
        return pulumi.get(self, "cluster_spn")

    @cluster_spn.setter
    def cluster_spn(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "cluster_spn", value)

    @property
    @pulumi.getter
    def unsecured(self) -> Optional[pulumi.Input[bool]]:
        """
        Skip using windows security for authentication.
        """
        return pulumi.get(self, "unsecured")

    @unsecured.setter
    def unsecured(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "unsecured", value)


@pulumi.input_type
class ServiceendpointArgocdAuthenticationBasicArgs:
    def __init__(__self__, *,
                 password: pulumi.Input[str],
                 username: pulumi.Input[str]):
        """
        :param pulumi.Input[str] password: ArgoCD Password.
        :param pulumi.Input[str] username: ArgoCD Username.
        """
        pulumi.set(__self__, "password", password)
        pulumi.set(__self__, "username", username)

    @property
    @pulumi.getter
    def password(self) -> pulumi.Input[str]:
        """
        ArgoCD Password.
        """
        return pulumi.get(self, "password")

    @password.setter
    def password(self, value: pulumi.Input[str]):
        pulumi.set(self, "password", value)

    @property
    @pulumi.getter
    def username(self) -> pulumi.Input[str]:
        """
        ArgoCD Username.
        """
        return pulumi.get(self, "username")

    @username.setter
    def username(self, value: pulumi.Input[str]):
        pulumi.set(self, "username", value)


@pulumi.input_type
class ServiceendpointArgocdAuthenticationTokenArgs:
    def __init__(__self__, *,
                 token: pulumi.Input[str]):
        """
        :param pulumi.Input[str] token: Authentication Token generated through ArgoCD.
        """
        pulumi.set(__self__, "token", token)

    @property
    @pulumi.getter
    def token(self) -> pulumi.Input[str]:
        """
        Authentication Token generated through ArgoCD.
        """
        return pulumi.get(self, "token")

    @token.setter
    def token(self, value: pulumi.Input[str]):
        pulumi.set(self, "token", value)


@pulumi.input_type
class ServiceendpointExternaltfsAuthPersonalArgs:
    def __init__(__self__, *,
                 personal_access_token: pulumi.Input[str]):
        """
        :param pulumi.Input[str] personal_access_token: The Personal Access Token for Azure DevOps Organization.
        """
        pulumi.set(__self__, "personal_access_token", personal_access_token)

    @property
    @pulumi.getter(name="personalAccessToken")
    def personal_access_token(self) -> pulumi.Input[str]:
        """
        The Personal Access Token for Azure DevOps Organization.
        """
        return pulumi.get(self, "personal_access_token")

    @personal_access_token.setter
    def personal_access_token(self, value: pulumi.Input[str]):
        pulumi.set(self, "personal_access_token", value)


@pulumi.input_type
class ServiceendpointJfrogArtifactoryV2AuthenticationBasicArgs:
    def __init__(__self__, *,
                 password: pulumi.Input[str],
                 username: pulumi.Input[str]):
        """
        :param pulumi.Input[str] password: Artifactory Password.
        :param pulumi.Input[str] username: Artifactory Username.
        """
        pulumi.set(__self__, "password", password)
        pulumi.set(__self__, "username", username)

    @property
    @pulumi.getter
    def password(self) -> pulumi.Input[str]:
        """
        Artifactory Password.
        """
        return pulumi.get(self, "password")

    @password.setter
    def password(self, value: pulumi.Input[str]):
        pulumi.set(self, "password", value)

    @property
    @pulumi.getter
    def username(self) -> pulumi.Input[str]:
        """
        Artifactory Username.
        """
        return pulumi.get(self, "username")

    @username.setter
    def username(self, value: pulumi.Input[str]):
        pulumi.set(self, "username", value)


@pulumi.input_type
class ServiceendpointJfrogArtifactoryV2AuthenticationTokenArgs:
    def __init__(__self__, *,
                 token: pulumi.Input[str]):
        """
        :param pulumi.Input[str] token: Authentication Token generated through Artifactory.
        """
        pulumi.set(__self__, "token", token)

    @property
    @pulumi.getter
    def token(self) -> pulumi.Input[str]:
        """
        Authentication Token generated through Artifactory.
        """
        return pulumi.get(self, "token")

    @token.setter
    def token(self, value: pulumi.Input[str]):
        pulumi.set(self, "token", value)


@pulumi.input_type
class ServiceendpointJfrogDistributionV2AuthenticationBasicArgs:
    def __init__(__self__, *,
                 password: pulumi.Input[str],
                 username: pulumi.Input[str]):
        """
        :param pulumi.Input[str] password: Artifactory Password.
        :param pulumi.Input[str] username: Artifactory Username.
        """
        pulumi.set(__self__, "password", password)
        pulumi.set(__self__, "username", username)

    @property
    @pulumi.getter
    def password(self) -> pulumi.Input[str]:
        """
        Artifactory Password.
        """
        return pulumi.get(self, "password")

    @password.setter
    def password(self, value: pulumi.Input[str]):
        pulumi.set(self, "password", value)

    @property
    @pulumi.getter
    def username(self) -> pulumi.Input[str]:
        """
        Artifactory Username.
        """
        return pulumi.get(self, "username")

    @username.setter
    def username(self, value: pulumi.Input[str]):
        pulumi.set(self, "username", value)


@pulumi.input_type
class ServiceendpointJfrogDistributionV2AuthenticationTokenArgs:
    def __init__(__self__, *,
                 token: pulumi.Input[str]):
        """
        :param pulumi.Input[str] token: Authentication Token generated through Artifactory.
        """
        pulumi.set(__self__, "token", token)

    @property
    @pulumi.getter
    def token(self) -> pulumi.Input[str]:
        """
        Authentication Token generated through Artifactory.
        """
        return pulumi.get(self, "token")

    @token.setter
    def token(self, value: pulumi.Input[str]):
        pulumi.set(self, "token", value)


@pulumi.input_type
class ServiceendpointJfrogPlatformV2AuthenticationBasicArgs:
    def __init__(__self__, *,
                 password: pulumi.Input[str],
                 username: pulumi.Input[str]):
        """
        :param pulumi.Input[str] password: Artifactory Password.
        :param pulumi.Input[str] username: Artifactory Username.
        """
        pulumi.set(__self__, "password", password)
        pulumi.set(__self__, "username", username)

    @property
    @pulumi.getter
    def password(self) -> pulumi.Input[str]:
        """
        Artifactory Password.
        """
        return pulumi.get(self, "password")

    @password.setter
    def password(self, value: pulumi.Input[str]):
        pulumi.set(self, "password", value)

    @property
    @pulumi.getter
    def username(self) -> pulumi.Input[str]:
        """
        Artifactory Username.
        """
        return pulumi.get(self, "username")

    @username.setter
    def username(self, value: pulumi.Input[str]):
        pulumi.set(self, "username", value)


@pulumi.input_type
class ServiceendpointJfrogPlatformV2AuthenticationTokenArgs:
    def __init__(__self__, *,
                 token: pulumi.Input[str]):
        """
        :param pulumi.Input[str] token: Authentication Token generated through Artifactory.
        """
        pulumi.set(__self__, "token", token)

    @property
    @pulumi.getter
    def token(self) -> pulumi.Input[str]:
        """
        Authentication Token generated through Artifactory.
        """
        return pulumi.get(self, "token")

    @token.setter
    def token(self, value: pulumi.Input[str]):
        pulumi.set(self, "token", value)


@pulumi.input_type
class ServiceendpointJfrogXrayV2AuthenticationBasicArgs:
    def __init__(__self__, *,
                 password: pulumi.Input[str],
                 username: pulumi.Input[str]):
        """
        :param pulumi.Input[str] password: Artifactory Password.
        :param pulumi.Input[str] username: Artifactory Username.
        """
        pulumi.set(__self__, "password", password)
        pulumi.set(__self__, "username", username)

    @property
    @pulumi.getter
    def password(self) -> pulumi.Input[str]:
        """
        Artifactory Password.
        """
        return pulumi.get(self, "password")

    @password.setter
    def password(self, value: pulumi.Input[str]):
        pulumi.set(self, "password", value)

    @property
    @pulumi.getter
    def username(self) -> pulumi.Input[str]:
        """
        Artifactory Username.
        """
        return pulumi.get(self, "username")

    @username.setter
    def username(self, value: pulumi.Input[str]):
        pulumi.set(self, "username", value)


@pulumi.input_type
class ServiceendpointJfrogXrayV2AuthenticationTokenArgs:
    def __init__(__self__, *,
                 token: pulumi.Input[str]):
        """
        :param pulumi.Input[str] token: Authentication Token generated through Artifactory.
        """
        pulumi.set(__self__, "token", token)

    @property
    @pulumi.getter
    def token(self) -> pulumi.Input[str]:
        """
        Authentication Token generated through Artifactory.
        """
        return pulumi.get(self, "token")

    @token.setter
    def token(self, value: pulumi.Input[str]):
        pulumi.set(self, "token", value)


@pulumi.input_type
class ServiceendpointMavenAuthenticationBasicArgs:
    def __init__(__self__, *,
                 password: pulumi.Input[str],
                 username: pulumi.Input[str]):
        """
        :param pulumi.Input[str] password: The password Maven Repository.
        :param pulumi.Input[str] username: The Username of the Maven Repository.
        """
        pulumi.set(__self__, "password", password)
        pulumi.set(__self__, "username", username)

    @property
    @pulumi.getter
    def password(self) -> pulumi.Input[str]:
        """
        The password Maven Repository.
        """
        return pulumi.get(self, "password")

    @password.setter
    def password(self, value: pulumi.Input[str]):
        pulumi.set(self, "password", value)

    @property
    @pulumi.getter
    def username(self) -> pulumi.Input[str]:
        """
        The Username of the Maven Repository.
        """
        return pulumi.get(self, "username")

    @username.setter
    def username(self, value: pulumi.Input[str]):
        pulumi.set(self, "username", value)


@pulumi.input_type
class ServiceendpointMavenAuthenticationTokenArgs:
    def __init__(__self__, *,
                 token: pulumi.Input[str]):
        """
        :param pulumi.Input[str] token: Authentication Token generated through maven repository.
        """
        pulumi.set(__self__, "token", token)

    @property
    @pulumi.getter
    def token(self) -> pulumi.Input[str]:
        """
        Authentication Token generated through maven repository.
        """
        return pulumi.get(self, "token")

    @token.setter
    def token(self, value: pulumi.Input[str]):
        pulumi.set(self, "token", value)


@pulumi.input_type
class VariableGroupKeyVaultArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[str],
                 service_endpoint_id: pulumi.Input[str],
                 search_depth: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input[str] name: The name of the Azure key vault to link secrets from as variables.
        :param pulumi.Input[str] service_endpoint_id: The id of the Azure subscription endpoint to access the key vault.
        :param pulumi.Input[int] search_depth: Set the Azure Key Vault Secret search depth. Defaults to `20`.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "service_endpoint_id", service_endpoint_id)
        if search_depth is not None:
            pulumi.set(__self__, "search_depth", search_depth)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        The name of the Azure key vault to link secrets from as variables.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter(name="serviceEndpointId")
    def service_endpoint_id(self) -> pulumi.Input[str]:
        """
        The id of the Azure subscription endpoint to access the key vault.
        """
        return pulumi.get(self, "service_endpoint_id")

    @service_endpoint_id.setter
    def service_endpoint_id(self, value: pulumi.Input[str]):
        pulumi.set(self, "service_endpoint_id", value)

    @property
    @pulumi.getter(name="searchDepth")
    def search_depth(self) -> Optional[pulumi.Input[int]]:
        """
        Set the Azure Key Vault Secret search depth. Defaults to `20`.
        """
        return pulumi.get(self, "search_depth")

    @search_depth.setter
    def search_depth(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "search_depth", value)


@pulumi.input_type
class VariableGroupVariableArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[str],
                 content_type: Optional[pulumi.Input[str]] = None,
                 enabled: Optional[pulumi.Input[bool]] = None,
                 expires: Optional[pulumi.Input[str]] = None,
                 is_secret: Optional[pulumi.Input[bool]] = None,
                 secret_value: Optional[pulumi.Input[str]] = None,
                 value: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] name: The key value used for the variable. Must be unique within the Variable Group.
        :param pulumi.Input[bool] is_secret: A boolean flag describing if the variable value is sensitive. Defaults to `false`.
        :param pulumi.Input[str] secret_value: The secret value of the variable. If omitted, it will default to empty string. Used when `is_secret` set to `true`.
        :param pulumi.Input[str] value: The value of the variable. If omitted, it will default to empty string.
        """
        pulumi.set(__self__, "name", name)
        if content_type is not None:
            pulumi.set(__self__, "content_type", content_type)
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if expires is not None:
            pulumi.set(__self__, "expires", expires)
        if is_secret is not None:
            pulumi.set(__self__, "is_secret", is_secret)
        if secret_value is not None:
            pulumi.set(__self__, "secret_value", secret_value)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        The key value used for the variable. Must be unique within the Variable Group.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter(name="contentType")
    def content_type(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "content_type")

    @content_type.setter
    def content_type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "content_type", value)

    @property
    @pulumi.getter
    def enabled(self) -> Optional[pulumi.Input[bool]]:
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "enabled", value)

    @property
    @pulumi.getter
    def expires(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "expires")

    @expires.setter
    def expires(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "expires", value)

    @property
    @pulumi.getter(name="isSecret")
    def is_secret(self) -> Optional[pulumi.Input[bool]]:
        """
        A boolean flag describing if the variable value is sensitive. Defaults to `false`.
        """
        return pulumi.get(self, "is_secret")

    @is_secret.setter
    def is_secret(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "is_secret", value)

    @property
    @pulumi.getter(name="secretValue")
    def secret_value(self) -> Optional[pulumi.Input[str]]:
        """
        The secret value of the variable. If omitted, it will default to empty string. Used when `is_secret` set to `true`.
        """
        return pulumi.get(self, "secret_value")

    @secret_value.setter
    def secret_value(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "secret_value", value)

    @property
    @pulumi.getter
    def value(self) -> Optional[pulumi.Input[str]]:
        """
        The value of the variable. If omitted, it will default to empty string.
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "value", value)


