# coding=utf-8
# *** WARNING: this file was generated by the Pulumi Terraform Bridge (tfgen) Tool. ***
# *** Do not edit by hand unless you're certain you know what you are doing! ***

import warnings
import pulumi
import pulumi.runtime
from typing import Any, Mapping, Optional, Sequence, Union, overload
from . import _utilities
from . import outputs

__all__ = [
    'BranchPolicyAutoReviewersSettings',
    'BranchPolicyAutoReviewersSettingsScope',
    'BranchPolicyBuildValidationSettings',
    'BranchPolicyBuildValidationSettingsScope',
    'BranchPolicyCommentResolutionSettings',
    'BranchPolicyCommentResolutionSettingsScope',
    'BranchPolicyMergeTypesSettings',
    'BranchPolicyMergeTypesSettingsScope',
    'BranchPolicyMinReviewersSettings',
    'BranchPolicyMinReviewersSettingsScope',
    'BranchPolicyWorkItemLinkingSettings',
    'BranchPolicyWorkItemLinkingSettingsScope',
    'BuildDefinitionCiTrigger',
    'BuildDefinitionCiTriggerOverride',
    'BuildDefinitionCiTriggerOverrideBranchFilter',
    'BuildDefinitionCiTriggerOverridePathFilter',
    'BuildDefinitionPullRequestTrigger',
    'BuildDefinitionPullRequestTriggerForks',
    'BuildDefinitionPullRequestTriggerOverride',
    'BuildDefinitionPullRequestTriggerOverrideBranchFilter',
    'BuildDefinitionPullRequestTriggerOverridePathFilter',
    'BuildDefinitionRepository',
    'BuildDefinitionVariable',
    'GitInitialization',
    'ServiceEndpointArtifactoryAuthenticationBasic',
    'ServiceEndpointArtifactoryAuthenticationToken',
    'ServiceEndpointAzureRMCredentials',
    'ServiceEndpointGitHubAuthOauth',
    'ServiceEndpointGitHubAuthPersonal',
    'ServiceEndpointGitHubEnterpriseAuthPersonal',
    'ServiceEndpointKubernetesAzureSubscription',
    'ServiceEndpointKubernetesKubeconfig',
    'ServiceEndpointKubernetesServiceAccount',
    'ServiceEndpointPipelineAuthPersonal',
    'VariableGroupKeyVault',
    'VariableGroupVariable',
    'GetAreaChildrenResult',
    'GetIterationChildrenResult',
    'GetPoolsAgentPoolResult',
    'GetProjectsProjectResult',
    'GetRepositoriesRepositoryResult',
    'GetUsersUserResult',
]

@pulumi.output_type
class BranchPolicyAutoReviewersSettings(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "autoReviewerIds":
            suggest = "auto_reviewer_ids"
        elif key == "pathFilters":
            suggest = "path_filters"
        elif key == "submitterCanVote":
            suggest = "submitter_can_vote"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in BranchPolicyAutoReviewersSettings. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        BranchPolicyAutoReviewersSettings.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        BranchPolicyAutoReviewersSettings.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 auto_reviewer_ids: Sequence[str],
                 scopes: Sequence['outputs.BranchPolicyAutoReviewersSettingsScope'],
                 message: Optional[str] = None,
                 path_filters: Optional[Sequence[str]] = None,
                 submitter_can_vote: Optional[bool] = None):
        """
        :param Sequence[str] auto_reviewer_ids: Required reviewers ids. Supports multiples user Ids.
        :param Sequence['BranchPolicyAutoReviewersSettingsScopeArgs'] scopes: Controls which repositories and branches the policy will be enabled for. This block must be defined at least once.
        :param str message: Activity feed message, Message will appear in the activity feed of pull requests with automatically added reviewers.
        :param Sequence[str] path_filters: Filter path(s) on which the policy is applied. Supports absolute paths, wildcards and multiple paths. Example: /WebApp/Models/Data.cs, /WebApp/* or *.cs,/WebApp/Models/Data.cs;ClientApp/Models/Data.cs.
        :param bool submitter_can_vote: Controls whether or not the submitter's vote counts. Defaults to `false`.
        """
        pulumi.set(__self__, "auto_reviewer_ids", auto_reviewer_ids)
        pulumi.set(__self__, "scopes", scopes)
        if message is not None:
            pulumi.set(__self__, "message", message)
        if path_filters is not None:
            pulumi.set(__self__, "path_filters", path_filters)
        if submitter_can_vote is not None:
            pulumi.set(__self__, "submitter_can_vote", submitter_can_vote)

    @property
    @pulumi.getter(name="autoReviewerIds")
    def auto_reviewer_ids(self) -> Sequence[str]:
        """
        Required reviewers ids. Supports multiples user Ids.
        """
        return pulumi.get(self, "auto_reviewer_ids")

    @property
    @pulumi.getter
    def scopes(self) -> Sequence['outputs.BranchPolicyAutoReviewersSettingsScope']:
        """
        Controls which repositories and branches the policy will be enabled for. This block must be defined at least once.
        """
        return pulumi.get(self, "scopes")

    @property
    @pulumi.getter
    def message(self) -> Optional[str]:
        """
        Activity feed message, Message will appear in the activity feed of pull requests with automatically added reviewers.
        """
        return pulumi.get(self, "message")

    @property
    @pulumi.getter(name="pathFilters")
    def path_filters(self) -> Optional[Sequence[str]]:
        """
        Filter path(s) on which the policy is applied. Supports absolute paths, wildcards and multiple paths. Example: /WebApp/Models/Data.cs, /WebApp/* or *.cs,/WebApp/Models/Data.cs;ClientApp/Models/Data.cs.
        """
        return pulumi.get(self, "path_filters")

    @property
    @pulumi.getter(name="submitterCanVote")
    def submitter_can_vote(self) -> Optional[bool]:
        """
        Controls whether or not the submitter's vote counts. Defaults to `false`.
        """
        return pulumi.get(self, "submitter_can_vote")


@pulumi.output_type
class BranchPolicyAutoReviewersSettingsScope(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "matchType":
            suggest = "match_type"
        elif key == "repositoryId":
            suggest = "repository_id"
        elif key == "repositoryRef":
            suggest = "repository_ref"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in BranchPolicyAutoReviewersSettingsScope. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        BranchPolicyAutoReviewersSettingsScope.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        BranchPolicyAutoReviewersSettingsScope.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 match_type: Optional[str] = None,
                 repository_id: Optional[str] = None,
                 repository_ref: Optional[str] = None):
        """
        :param str match_type: The match type to use when applying the policy. Supported values are `Exact` (default) or `Prefix`.
        :param str repository_id: The repository ID. Needed only if the scope of the policy will be limited to a single repository.
        :param str repository_ref: The ref pattern to use for the match. If `match_type` is `Exact`, this should be a qualified ref such as `refs/heads/master`. If `match_type` is `Prefix`, this should be a ref path such as `refs/heads/releases`.
        """
        if match_type is not None:
            pulumi.set(__self__, "match_type", match_type)
        if repository_id is not None:
            pulumi.set(__self__, "repository_id", repository_id)
        if repository_ref is not None:
            pulumi.set(__self__, "repository_ref", repository_ref)

    @property
    @pulumi.getter(name="matchType")
    def match_type(self) -> Optional[str]:
        """
        The match type to use when applying the policy. Supported values are `Exact` (default) or `Prefix`.
        """
        return pulumi.get(self, "match_type")

    @property
    @pulumi.getter(name="repositoryId")
    def repository_id(self) -> Optional[str]:
        """
        The repository ID. Needed only if the scope of the policy will be limited to a single repository.
        """
        return pulumi.get(self, "repository_id")

    @property
    @pulumi.getter(name="repositoryRef")
    def repository_ref(self) -> Optional[str]:
        """
        The ref pattern to use for the match. If `match_type` is `Exact`, this should be a qualified ref such as `refs/heads/master`. If `match_type` is `Prefix`, this should be a ref path such as `refs/heads/releases`.
        """
        return pulumi.get(self, "repository_ref")


@pulumi.output_type
class BranchPolicyBuildValidationSettings(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "buildDefinitionId":
            suggest = "build_definition_id"
        elif key == "displayName":
            suggest = "display_name"
        elif key == "filenamePatterns":
            suggest = "filename_patterns"
        elif key == "manualQueueOnly":
            suggest = "manual_queue_only"
        elif key == "queueOnSourceUpdateOnly":
            suggest = "queue_on_source_update_only"
        elif key == "validDuration":
            suggest = "valid_duration"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in BranchPolicyBuildValidationSettings. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        BranchPolicyBuildValidationSettings.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        BranchPolicyBuildValidationSettings.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 build_definition_id: int,
                 display_name: str,
                 scopes: Sequence['outputs.BranchPolicyBuildValidationSettingsScope'],
                 filename_patterns: Optional[Sequence[str]] = None,
                 manual_queue_only: Optional[bool] = None,
                 queue_on_source_update_only: Optional[bool] = None,
                 valid_duration: Optional[int] = None):
        """
        :param int build_definition_id: The ID of the build to monitor for the policy.
        :param str display_name: The display name for the policy.
        :param Sequence['BranchPolicyBuildValidationSettingsScopeArgs'] scopes: Controls which repositories and branches the policy will be enabled for. This block must be defined at least once.
        :param Sequence[str] filename_patterns: If a path filter is set, the policy wil only apply when files which match the filter are changes. Not setting this field means that the policy will always apply. You can specify absolute paths and wildcards. Example: `["/WebApp/Models/Data.cs", "/WebApp/*", "*.cs"]`. Paths prefixed with "!" are excluded. Example: `["/WebApp/*", "!/WebApp/Tests/*"]`. Order is significant.
        :param bool manual_queue_only: If set to true, the build will need to be manually queued. Defaults to `false`
        :param bool queue_on_source_update_only: True if the build should queue on source updates only. Defaults to `true`.
        :param int valid_duration: The number of minutes for which the build is valid. If `0`, the build will not expire. Defaults to `720` (12 hours).
        """
        pulumi.set(__self__, "build_definition_id", build_definition_id)
        pulumi.set(__self__, "display_name", display_name)
        pulumi.set(__self__, "scopes", scopes)
        if filename_patterns is not None:
            pulumi.set(__self__, "filename_patterns", filename_patterns)
        if manual_queue_only is not None:
            pulumi.set(__self__, "manual_queue_only", manual_queue_only)
        if queue_on_source_update_only is not None:
            pulumi.set(__self__, "queue_on_source_update_only", queue_on_source_update_only)
        if valid_duration is not None:
            pulumi.set(__self__, "valid_duration", valid_duration)

    @property
    @pulumi.getter(name="buildDefinitionId")
    def build_definition_id(self) -> int:
        """
        The ID of the build to monitor for the policy.
        """
        return pulumi.get(self, "build_definition_id")

    @property
    @pulumi.getter(name="displayName")
    def display_name(self) -> str:
        """
        The display name for the policy.
        """
        return pulumi.get(self, "display_name")

    @property
    @pulumi.getter
    def scopes(self) -> Sequence['outputs.BranchPolicyBuildValidationSettingsScope']:
        """
        Controls which repositories and branches the policy will be enabled for. This block must be defined at least once.
        """
        return pulumi.get(self, "scopes")

    @property
    @pulumi.getter(name="filenamePatterns")
    def filename_patterns(self) -> Optional[Sequence[str]]:
        """
        If a path filter is set, the policy wil only apply when files which match the filter are changes. Not setting this field means that the policy will always apply. You can specify absolute paths and wildcards. Example: `["/WebApp/Models/Data.cs", "/WebApp/*", "*.cs"]`. Paths prefixed with "!" are excluded. Example: `["/WebApp/*", "!/WebApp/Tests/*"]`. Order is significant.
        """
        return pulumi.get(self, "filename_patterns")

    @property
    @pulumi.getter(name="manualQueueOnly")
    def manual_queue_only(self) -> Optional[bool]:
        """
        If set to true, the build will need to be manually queued. Defaults to `false`
        """
        return pulumi.get(self, "manual_queue_only")

    @property
    @pulumi.getter(name="queueOnSourceUpdateOnly")
    def queue_on_source_update_only(self) -> Optional[bool]:
        """
        True if the build should queue on source updates only. Defaults to `true`.
        """
        return pulumi.get(self, "queue_on_source_update_only")

    @property
    @pulumi.getter(name="validDuration")
    def valid_duration(self) -> Optional[int]:
        """
        The number of minutes for which the build is valid. If `0`, the build will not expire. Defaults to `720` (12 hours).
        """
        return pulumi.get(self, "valid_duration")


@pulumi.output_type
class BranchPolicyBuildValidationSettingsScope(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "matchType":
            suggest = "match_type"
        elif key == "repositoryId":
            suggest = "repository_id"
        elif key == "repositoryRef":
            suggest = "repository_ref"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in BranchPolicyBuildValidationSettingsScope. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        BranchPolicyBuildValidationSettingsScope.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        BranchPolicyBuildValidationSettingsScope.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 match_type: Optional[str] = None,
                 repository_id: Optional[str] = None,
                 repository_ref: Optional[str] = None):
        """
        :param str match_type: The match type to use when applying the policy. Supported values are `Exact` (default) or `Prefix`.
        :param str repository_id: The repository ID. Needed only if the scope of the policy will be limited to a single repository.
        :param str repository_ref: The ref pattern to use for the match. If `match_type` is `Exact`, this should be a qualified ref such as `refs/heads/master`. If `match_type` is `Prefix`, this should be a ref path such as `refs/heads/releases`.
        """
        if match_type is not None:
            pulumi.set(__self__, "match_type", match_type)
        if repository_id is not None:
            pulumi.set(__self__, "repository_id", repository_id)
        if repository_ref is not None:
            pulumi.set(__self__, "repository_ref", repository_ref)

    @property
    @pulumi.getter(name="matchType")
    def match_type(self) -> Optional[str]:
        """
        The match type to use when applying the policy. Supported values are `Exact` (default) or `Prefix`.
        """
        return pulumi.get(self, "match_type")

    @property
    @pulumi.getter(name="repositoryId")
    def repository_id(self) -> Optional[str]:
        """
        The repository ID. Needed only if the scope of the policy will be limited to a single repository.
        """
        return pulumi.get(self, "repository_id")

    @property
    @pulumi.getter(name="repositoryRef")
    def repository_ref(self) -> Optional[str]:
        """
        The ref pattern to use for the match. If `match_type` is `Exact`, this should be a qualified ref such as `refs/heads/master`. If `match_type` is `Prefix`, this should be a ref path such as `refs/heads/releases`.
        """
        return pulumi.get(self, "repository_ref")


@pulumi.output_type
class BranchPolicyCommentResolutionSettings(dict):
    def __init__(__self__, *,
                 scopes: Sequence['outputs.BranchPolicyCommentResolutionSettingsScope']):
        """
        :param Sequence['BranchPolicyCommentResolutionSettingsScopeArgs'] scopes: Controls which repositories and branches the policy will be enabled for. This block must be defined at least once.
        """
        pulumi.set(__self__, "scopes", scopes)

    @property
    @pulumi.getter
    def scopes(self) -> Sequence['outputs.BranchPolicyCommentResolutionSettingsScope']:
        """
        Controls which repositories and branches the policy will be enabled for. This block must be defined at least once.
        """
        return pulumi.get(self, "scopes")


@pulumi.output_type
class BranchPolicyCommentResolutionSettingsScope(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "matchType":
            suggest = "match_type"
        elif key == "repositoryId":
            suggest = "repository_id"
        elif key == "repositoryRef":
            suggest = "repository_ref"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in BranchPolicyCommentResolutionSettingsScope. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        BranchPolicyCommentResolutionSettingsScope.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        BranchPolicyCommentResolutionSettingsScope.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 match_type: Optional[str] = None,
                 repository_id: Optional[str] = None,
                 repository_ref: Optional[str] = None):
        """
        :param str match_type: The match type to use when applying the policy. Supported values are `Exact` (default) or `Prefix`.
        :param str repository_id: The repository ID. Needed only if the scope of the policy will be limited to a single repository.
        :param str repository_ref: The ref pattern to use for the match. If `match_type` is `Exact`, this should be a qualified ref such as `refs/heads/master`. If `match_type` is `Prefix`, this should be a ref path such as `refs/heads/releases`.
        """
        if match_type is not None:
            pulumi.set(__self__, "match_type", match_type)
        if repository_id is not None:
            pulumi.set(__self__, "repository_id", repository_id)
        if repository_ref is not None:
            pulumi.set(__self__, "repository_ref", repository_ref)

    @property
    @pulumi.getter(name="matchType")
    def match_type(self) -> Optional[str]:
        """
        The match type to use when applying the policy. Supported values are `Exact` (default) or `Prefix`.
        """
        return pulumi.get(self, "match_type")

    @property
    @pulumi.getter(name="repositoryId")
    def repository_id(self) -> Optional[str]:
        """
        The repository ID. Needed only if the scope of the policy will be limited to a single repository.
        """
        return pulumi.get(self, "repository_id")

    @property
    @pulumi.getter(name="repositoryRef")
    def repository_ref(self) -> Optional[str]:
        """
        The ref pattern to use for the match. If `match_type` is `Exact`, this should be a qualified ref such as `refs/heads/master`. If `match_type` is `Prefix`, this should be a ref path such as `refs/heads/releases`.
        """
        return pulumi.get(self, "repository_ref")


@pulumi.output_type
class BranchPolicyMergeTypesSettings(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "allowBasicNoFastForward":
            suggest = "allow_basic_no_fast_forward"
        elif key == "allowRebaseAndFastForward":
            suggest = "allow_rebase_and_fast_forward"
        elif key == "allowRebaseWithMerge":
            suggest = "allow_rebase_with_merge"
        elif key == "allowSquash":
            suggest = "allow_squash"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in BranchPolicyMergeTypesSettings. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        BranchPolicyMergeTypesSettings.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        BranchPolicyMergeTypesSettings.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 scopes: Sequence['outputs.BranchPolicyMergeTypesSettingsScope'],
                 allow_basic_no_fast_forward: Optional[bool] = None,
                 allow_rebase_and_fast_forward: Optional[bool] = None,
                 allow_rebase_with_merge: Optional[bool] = None,
                 allow_squash: Optional[bool] = None):
        """
        :param Sequence['BranchPolicyMergeTypesSettingsScopeArgs'] scopes: Controls which repositories and branches the policy will be enabled for. This block must be defined at least once.
        :param bool allow_basic_no_fast_forward: Allow basic merge with no fast forward. Defaults to `false`.
        :param bool allow_rebase_and_fast_forward: Allow rebase with fast forward. Defaults to `false`.
        :param bool allow_rebase_with_merge: Allow rebase with merge commit. Defaults to `false`.
        :param bool allow_squash: Allow squash merge. Defaults to `false`
        """
        pulumi.set(__self__, "scopes", scopes)
        if allow_basic_no_fast_forward is not None:
            pulumi.set(__self__, "allow_basic_no_fast_forward", allow_basic_no_fast_forward)
        if allow_rebase_and_fast_forward is not None:
            pulumi.set(__self__, "allow_rebase_and_fast_forward", allow_rebase_and_fast_forward)
        if allow_rebase_with_merge is not None:
            pulumi.set(__self__, "allow_rebase_with_merge", allow_rebase_with_merge)
        if allow_squash is not None:
            pulumi.set(__self__, "allow_squash", allow_squash)

    @property
    @pulumi.getter
    def scopes(self) -> Sequence['outputs.BranchPolicyMergeTypesSettingsScope']:
        """
        Controls which repositories and branches the policy will be enabled for. This block must be defined at least once.
        """
        return pulumi.get(self, "scopes")

    @property
    @pulumi.getter(name="allowBasicNoFastForward")
    def allow_basic_no_fast_forward(self) -> Optional[bool]:
        """
        Allow basic merge with no fast forward. Defaults to `false`.
        """
        return pulumi.get(self, "allow_basic_no_fast_forward")

    @property
    @pulumi.getter(name="allowRebaseAndFastForward")
    def allow_rebase_and_fast_forward(self) -> Optional[bool]:
        """
        Allow rebase with fast forward. Defaults to `false`.
        """
        return pulumi.get(self, "allow_rebase_and_fast_forward")

    @property
    @pulumi.getter(name="allowRebaseWithMerge")
    def allow_rebase_with_merge(self) -> Optional[bool]:
        """
        Allow rebase with merge commit. Defaults to `false`.
        """
        return pulumi.get(self, "allow_rebase_with_merge")

    @property
    @pulumi.getter(name="allowSquash")
    def allow_squash(self) -> Optional[bool]:
        """
        Allow squash merge. Defaults to `false`
        """
        return pulumi.get(self, "allow_squash")


@pulumi.output_type
class BranchPolicyMergeTypesSettingsScope(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "matchType":
            suggest = "match_type"
        elif key == "repositoryId":
            suggest = "repository_id"
        elif key == "repositoryRef":
            suggest = "repository_ref"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in BranchPolicyMergeTypesSettingsScope. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        BranchPolicyMergeTypesSettingsScope.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        BranchPolicyMergeTypesSettingsScope.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 match_type: Optional[str] = None,
                 repository_id: Optional[str] = None,
                 repository_ref: Optional[str] = None):
        """
        :param str match_type: The match type to use when applying the policy. Supported values are `Exact` (default) or `Prefix`.
        :param str repository_id: The repository ID. Needed only if the scope of the policy will be limited to a single repository.
        :param str repository_ref: The ref pattern to use for the match. If `match_type` is `Exact`, this should be a qualified ref such as `refs/heads/master`. If `match_type` is `Prefix`, this should be a ref path such as `refs/heads/releases`.
        """
        if match_type is not None:
            pulumi.set(__self__, "match_type", match_type)
        if repository_id is not None:
            pulumi.set(__self__, "repository_id", repository_id)
        if repository_ref is not None:
            pulumi.set(__self__, "repository_ref", repository_ref)

    @property
    @pulumi.getter(name="matchType")
    def match_type(self) -> Optional[str]:
        """
        The match type to use when applying the policy. Supported values are `Exact` (default) or `Prefix`.
        """
        return pulumi.get(self, "match_type")

    @property
    @pulumi.getter(name="repositoryId")
    def repository_id(self) -> Optional[str]:
        """
        The repository ID. Needed only if the scope of the policy will be limited to a single repository.
        """
        return pulumi.get(self, "repository_id")

    @property
    @pulumi.getter(name="repositoryRef")
    def repository_ref(self) -> Optional[str]:
        """
        The ref pattern to use for the match. If `match_type` is `Exact`, this should be a qualified ref such as `refs/heads/master`. If `match_type` is `Prefix`, this should be a ref path such as `refs/heads/releases`.
        """
        return pulumi.get(self, "repository_ref")


@pulumi.output_type
class BranchPolicyMinReviewersSettings(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "allowCompletionWithRejectsOrWaits":
            suggest = "allow_completion_with_rejects_or_waits"
        elif key == "lastPusherCannotApprove":
            suggest = "last_pusher_cannot_approve"
        elif key == "onLastIterationRequireVote":
            suggest = "on_last_iteration_require_vote"
        elif key == "onPushResetAllVotes":
            suggest = "on_push_reset_all_votes"
        elif key == "onPushResetApprovedVotes":
            suggest = "on_push_reset_approved_votes"
        elif key == "reviewerCount":
            suggest = "reviewer_count"
        elif key == "submitterCanVote":
            suggest = "submitter_can_vote"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in BranchPolicyMinReviewersSettings. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        BranchPolicyMinReviewersSettings.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        BranchPolicyMinReviewersSettings.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 scopes: Sequence['outputs.BranchPolicyMinReviewersSettingsScope'],
                 allow_completion_with_rejects_or_waits: Optional[bool] = None,
                 last_pusher_cannot_approve: Optional[bool] = None,
                 on_last_iteration_require_vote: Optional[bool] = None,
                 on_push_reset_all_votes: Optional[bool] = None,
                 on_push_reset_approved_votes: Optional[bool] = None,
                 reviewer_count: Optional[int] = None,
                 submitter_can_vote: Optional[bool] = None):
        """
        :param Sequence['BranchPolicyMinReviewersSettingsScopeArgs'] scopes: Controls which repositories and branches the policy will be enabled for. This block must be defined at least once.
        :param bool allow_completion_with_rejects_or_waits: Allow completion even if some reviewers vote to wait or reject. Defaults to `false`.
        :param bool last_pusher_cannot_approve: Prohibit the most recent pusher from approving their own changes. Defaults to `false`.
        :param bool on_last_iteration_require_vote: On last iteration require vote. Defaults to `false`.
        :param bool on_push_reset_all_votes: When new changes are pushed reset all code reviewer votes. Defaults to `false`.
        :param bool on_push_reset_approved_votes: When new changes are pushed reset all approval votes (does not reset votes to reject or wait). Defaults to `false`.
        :param int reviewer_count: The number of reviewers needed to approve.
        :param bool submitter_can_vote: Allow requesters to approve their own changes. Defaults to `false`.
        """
        pulumi.set(__self__, "scopes", scopes)
        if allow_completion_with_rejects_or_waits is not None:
            pulumi.set(__self__, "allow_completion_with_rejects_or_waits", allow_completion_with_rejects_or_waits)
        if last_pusher_cannot_approve is not None:
            pulumi.set(__self__, "last_pusher_cannot_approve", last_pusher_cannot_approve)
        if on_last_iteration_require_vote is not None:
            pulumi.set(__self__, "on_last_iteration_require_vote", on_last_iteration_require_vote)
        if on_push_reset_all_votes is not None:
            pulumi.set(__self__, "on_push_reset_all_votes", on_push_reset_all_votes)
        if on_push_reset_approved_votes is not None:
            pulumi.set(__self__, "on_push_reset_approved_votes", on_push_reset_approved_votes)
        if reviewer_count is not None:
            pulumi.set(__self__, "reviewer_count", reviewer_count)
        if submitter_can_vote is not None:
            pulumi.set(__self__, "submitter_can_vote", submitter_can_vote)

    @property
    @pulumi.getter
    def scopes(self) -> Sequence['outputs.BranchPolicyMinReviewersSettingsScope']:
        """
        Controls which repositories and branches the policy will be enabled for. This block must be defined at least once.
        """
        return pulumi.get(self, "scopes")

    @property
    @pulumi.getter(name="allowCompletionWithRejectsOrWaits")
    def allow_completion_with_rejects_or_waits(self) -> Optional[bool]:
        """
        Allow completion even if some reviewers vote to wait or reject. Defaults to `false`.
        """
        return pulumi.get(self, "allow_completion_with_rejects_or_waits")

    @property
    @pulumi.getter(name="lastPusherCannotApprove")
    def last_pusher_cannot_approve(self) -> Optional[bool]:
        """
        Prohibit the most recent pusher from approving their own changes. Defaults to `false`.
        """
        return pulumi.get(self, "last_pusher_cannot_approve")

    @property
    @pulumi.getter(name="onLastIterationRequireVote")
    def on_last_iteration_require_vote(self) -> Optional[bool]:
        """
        On last iteration require vote. Defaults to `false`.
        """
        return pulumi.get(self, "on_last_iteration_require_vote")

    @property
    @pulumi.getter(name="onPushResetAllVotes")
    def on_push_reset_all_votes(self) -> Optional[bool]:
        """
        When new changes are pushed reset all code reviewer votes. Defaults to `false`.
        """
        return pulumi.get(self, "on_push_reset_all_votes")

    @property
    @pulumi.getter(name="onPushResetApprovedVotes")
    def on_push_reset_approved_votes(self) -> Optional[bool]:
        """
        When new changes are pushed reset all approval votes (does not reset votes to reject or wait). Defaults to `false`.
        """
        return pulumi.get(self, "on_push_reset_approved_votes")

    @property
    @pulumi.getter(name="reviewerCount")
    def reviewer_count(self) -> Optional[int]:
        """
        The number of reviewers needed to approve.
        """
        return pulumi.get(self, "reviewer_count")

    @property
    @pulumi.getter(name="submitterCanVote")
    def submitter_can_vote(self) -> Optional[bool]:
        """
        Allow requesters to approve their own changes. Defaults to `false`.
        """
        return pulumi.get(self, "submitter_can_vote")


@pulumi.output_type
class BranchPolicyMinReviewersSettingsScope(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "matchType":
            suggest = "match_type"
        elif key == "repositoryId":
            suggest = "repository_id"
        elif key == "repositoryRef":
            suggest = "repository_ref"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in BranchPolicyMinReviewersSettingsScope. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        BranchPolicyMinReviewersSettingsScope.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        BranchPolicyMinReviewersSettingsScope.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 match_type: Optional[str] = None,
                 repository_id: Optional[str] = None,
                 repository_ref: Optional[str] = None):
        """
        :param str match_type: The match type to use when applying the policy. Supported values are `Exact` (default) or `Prefix`.
        :param str repository_id: The repository ID. Needed only if the scope of the policy will be limited to a single repository.
        :param str repository_ref: The ref pattern to use for the match. If `match_type` is `Exact`, this should be a qualified ref such as `refs/heads/master`. If `match_type` is `Prefix`, this should be a ref path such as `refs/heads/releases`.
        """
        if match_type is not None:
            pulumi.set(__self__, "match_type", match_type)
        if repository_id is not None:
            pulumi.set(__self__, "repository_id", repository_id)
        if repository_ref is not None:
            pulumi.set(__self__, "repository_ref", repository_ref)

    @property
    @pulumi.getter(name="matchType")
    def match_type(self) -> Optional[str]:
        """
        The match type to use when applying the policy. Supported values are `Exact` (default) or `Prefix`.
        """
        return pulumi.get(self, "match_type")

    @property
    @pulumi.getter(name="repositoryId")
    def repository_id(self) -> Optional[str]:
        """
        The repository ID. Needed only if the scope of the policy will be limited to a single repository.
        """
        return pulumi.get(self, "repository_id")

    @property
    @pulumi.getter(name="repositoryRef")
    def repository_ref(self) -> Optional[str]:
        """
        The ref pattern to use for the match. If `match_type` is `Exact`, this should be a qualified ref such as `refs/heads/master`. If `match_type` is `Prefix`, this should be a ref path such as `refs/heads/releases`.
        """
        return pulumi.get(self, "repository_ref")


@pulumi.output_type
class BranchPolicyWorkItemLinkingSettings(dict):
    def __init__(__self__, *,
                 scopes: Sequence['outputs.BranchPolicyWorkItemLinkingSettingsScope']):
        """
        :param Sequence['BranchPolicyWorkItemLinkingSettingsScopeArgs'] scopes: Controls which repositories and branches the policy will be enabled for. This block must be defined at least once.
        """
        pulumi.set(__self__, "scopes", scopes)

    @property
    @pulumi.getter
    def scopes(self) -> Sequence['outputs.BranchPolicyWorkItemLinkingSettingsScope']:
        """
        Controls which repositories and branches the policy will be enabled for. This block must be defined at least once.
        """
        return pulumi.get(self, "scopes")


@pulumi.output_type
class BranchPolicyWorkItemLinkingSettingsScope(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "matchType":
            suggest = "match_type"
        elif key == "repositoryId":
            suggest = "repository_id"
        elif key == "repositoryRef":
            suggest = "repository_ref"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in BranchPolicyWorkItemLinkingSettingsScope. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        BranchPolicyWorkItemLinkingSettingsScope.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        BranchPolicyWorkItemLinkingSettingsScope.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 match_type: Optional[str] = None,
                 repository_id: Optional[str] = None,
                 repository_ref: Optional[str] = None):
        """
        :param str match_type: The match type to use when applying the policy. Supported values are `Exact` (default) or `Prefix`.
        :param str repository_id: The repository ID. Needed only if the scope of the policy will be limited to a single repository.
        :param str repository_ref: The ref pattern to use for the match. If `match_type` is `Exact`, this should be a qualified ref such as `refs/heads/master`. If `match_type` is `Prefix`, this should be a ref path such as `refs/heads/releases`.
        """
        if match_type is not None:
            pulumi.set(__self__, "match_type", match_type)
        if repository_id is not None:
            pulumi.set(__self__, "repository_id", repository_id)
        if repository_ref is not None:
            pulumi.set(__self__, "repository_ref", repository_ref)

    @property
    @pulumi.getter(name="matchType")
    def match_type(self) -> Optional[str]:
        """
        The match type to use when applying the policy. Supported values are `Exact` (default) or `Prefix`.
        """
        return pulumi.get(self, "match_type")

    @property
    @pulumi.getter(name="repositoryId")
    def repository_id(self) -> Optional[str]:
        """
        The repository ID. Needed only if the scope of the policy will be limited to a single repository.
        """
        return pulumi.get(self, "repository_id")

    @property
    @pulumi.getter(name="repositoryRef")
    def repository_ref(self) -> Optional[str]:
        """
        The ref pattern to use for the match. If `match_type` is `Exact`, this should be a qualified ref such as `refs/heads/master`. If `match_type` is `Prefix`, this should be a ref path such as `refs/heads/releases`.
        """
        return pulumi.get(self, "repository_ref")


@pulumi.output_type
class BuildDefinitionCiTrigger(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "useYaml":
            suggest = "use_yaml"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in BuildDefinitionCiTrigger. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        BuildDefinitionCiTrigger.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        BuildDefinitionCiTrigger.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 override: Optional['outputs.BuildDefinitionCiTriggerOverride'] = None,
                 use_yaml: Optional[bool] = None):
        """
        :param 'BuildDefinitionCiTriggerOverrideArgs' override: Override the azure-pipeline file and use a this configuration for all builds.
        :param bool use_yaml: Use the azure-pipeline file for the build configuration. Defaults to `false`.
        """
        if override is not None:
            pulumi.set(__self__, "override", override)
        if use_yaml is not None:
            pulumi.set(__self__, "use_yaml", use_yaml)

    @property
    @pulumi.getter
    def override(self) -> Optional['outputs.BuildDefinitionCiTriggerOverride']:
        """
        Override the azure-pipeline file and use a this configuration for all builds.
        """
        return pulumi.get(self, "override")

    @property
    @pulumi.getter(name="useYaml")
    def use_yaml(self) -> Optional[bool]:
        """
        Use the azure-pipeline file for the build configuration. Defaults to `false`.
        """
        return pulumi.get(self, "use_yaml")


@pulumi.output_type
class BuildDefinitionCiTriggerOverride(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "branchFilters":
            suggest = "branch_filters"
        elif key == "maxConcurrentBuildsPerBranch":
            suggest = "max_concurrent_builds_per_branch"
        elif key == "pathFilters":
            suggest = "path_filters"
        elif key == "pollingInterval":
            suggest = "polling_interval"
        elif key == "pollingJobId":
            suggest = "polling_job_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in BuildDefinitionCiTriggerOverride. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        BuildDefinitionCiTriggerOverride.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        BuildDefinitionCiTriggerOverride.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 batch: Optional[bool] = None,
                 branch_filters: Optional[Sequence['outputs.BuildDefinitionCiTriggerOverrideBranchFilter']] = None,
                 max_concurrent_builds_per_branch: Optional[int] = None,
                 path_filters: Optional[Sequence['outputs.BuildDefinitionCiTriggerOverridePathFilter']] = None,
                 polling_interval: Optional[int] = None,
                 polling_job_id: Optional[str] = None):
        """
        :param bool batch: If you set batch to true, when a pipeline is running, the system waits until the run is completed, then starts another run with all changes that have not yet been built. Defaults to `true`.
        :param Sequence['BuildDefinitionCiTriggerOverrideBranchFilterArgs'] branch_filters: The branches to include and exclude from the trigger.
        :param int max_concurrent_builds_per_branch: The number of max builds per branch. Defaults to `1`.
        :param Sequence['BuildDefinitionCiTriggerOverridePathFilterArgs'] path_filters: Specify file paths to include or exclude. Note that the wildcard syntax is different between branches/tags and file paths.
        :param int polling_interval: How often the external repository is polled. Defaults to `0`.
        :param str polling_job_id: This is the ID of the polling job that polls the external repository. Once the build definition is saved/updated, this value is set.
        """
        if batch is not None:
            pulumi.set(__self__, "batch", batch)
        if branch_filters is not None:
            pulumi.set(__self__, "branch_filters", branch_filters)
        if max_concurrent_builds_per_branch is not None:
            pulumi.set(__self__, "max_concurrent_builds_per_branch", max_concurrent_builds_per_branch)
        if path_filters is not None:
            pulumi.set(__self__, "path_filters", path_filters)
        if polling_interval is not None:
            pulumi.set(__self__, "polling_interval", polling_interval)
        if polling_job_id is not None:
            pulumi.set(__self__, "polling_job_id", polling_job_id)

    @property
    @pulumi.getter
    def batch(self) -> Optional[bool]:
        """
        If you set batch to true, when a pipeline is running, the system waits until the run is completed, then starts another run with all changes that have not yet been built. Defaults to `true`.
        """
        return pulumi.get(self, "batch")

    @property
    @pulumi.getter(name="branchFilters")
    def branch_filters(self) -> Optional[Sequence['outputs.BuildDefinitionCiTriggerOverrideBranchFilter']]:
        """
        The branches to include and exclude from the trigger.
        """
        return pulumi.get(self, "branch_filters")

    @property
    @pulumi.getter(name="maxConcurrentBuildsPerBranch")
    def max_concurrent_builds_per_branch(self) -> Optional[int]:
        """
        The number of max builds per branch. Defaults to `1`.
        """
        return pulumi.get(self, "max_concurrent_builds_per_branch")

    @property
    @pulumi.getter(name="pathFilters")
    def path_filters(self) -> Optional[Sequence['outputs.BuildDefinitionCiTriggerOverridePathFilter']]:
        """
        Specify file paths to include or exclude. Note that the wildcard syntax is different between branches/tags and file paths.
        """
        return pulumi.get(self, "path_filters")

    @property
    @pulumi.getter(name="pollingInterval")
    def polling_interval(self) -> Optional[int]:
        """
        How often the external repository is polled. Defaults to `0`.
        """
        return pulumi.get(self, "polling_interval")

    @property
    @pulumi.getter(name="pollingJobId")
    def polling_job_id(self) -> Optional[str]:
        """
        This is the ID of the polling job that polls the external repository. Once the build definition is saved/updated, this value is set.
        """
        return pulumi.get(self, "polling_job_id")


@pulumi.output_type
class BuildDefinitionCiTriggerOverrideBranchFilter(dict):
    def __init__(__self__, *,
                 excludes: Optional[Sequence[str]] = None,
                 includes: Optional[Sequence[str]] = None):
        """
        :param Sequence[str] excludes: List of branch patterns to exclude.
        :param Sequence[str] includes: List of branch patterns to include.
        """
        if excludes is not None:
            pulumi.set(__self__, "excludes", excludes)
        if includes is not None:
            pulumi.set(__self__, "includes", includes)

    @property
    @pulumi.getter
    def excludes(self) -> Optional[Sequence[str]]:
        """
        List of branch patterns to exclude.
        """
        return pulumi.get(self, "excludes")

    @property
    @pulumi.getter
    def includes(self) -> Optional[Sequence[str]]:
        """
        List of branch patterns to include.
        """
        return pulumi.get(self, "includes")


@pulumi.output_type
class BuildDefinitionCiTriggerOverridePathFilter(dict):
    def __init__(__self__, *,
                 excludes: Optional[Sequence[str]] = None,
                 includes: Optional[Sequence[str]] = None):
        """
        :param Sequence[str] excludes: List of branch patterns to exclude.
        :param Sequence[str] includes: List of branch patterns to include.
        """
        if excludes is not None:
            pulumi.set(__self__, "excludes", excludes)
        if includes is not None:
            pulumi.set(__self__, "includes", includes)

    @property
    @pulumi.getter
    def excludes(self) -> Optional[Sequence[str]]:
        """
        List of branch patterns to exclude.
        """
        return pulumi.get(self, "excludes")

    @property
    @pulumi.getter
    def includes(self) -> Optional[Sequence[str]]:
        """
        List of branch patterns to include.
        """
        return pulumi.get(self, "includes")


@pulumi.output_type
class BuildDefinitionPullRequestTrigger(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "commentRequired":
            suggest = "comment_required"
        elif key == "initialBranch":
            suggest = "initial_branch"
        elif key == "useYaml":
            suggest = "use_yaml"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in BuildDefinitionPullRequestTrigger. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        BuildDefinitionPullRequestTrigger.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        BuildDefinitionPullRequestTrigger.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 forks: 'outputs.BuildDefinitionPullRequestTriggerForks',
                 comment_required: Optional[str] = None,
                 initial_branch: Optional[str] = None,
                 override: Optional['outputs.BuildDefinitionPullRequestTriggerOverride'] = None,
                 use_yaml: Optional[bool] = None):
        """
        :param 'BuildDefinitionPullRequestTriggerForksArgs' forks: Set permissions for Forked repositories.
        :param 'BuildDefinitionPullRequestTriggerOverrideArgs' override: Override the azure-pipeline file and use this configuration for all builds.
        :param bool use_yaml: Use the azure-pipeline file for the build configuration. Defaults to `false`.
        """
        pulumi.set(__self__, "forks", forks)
        if comment_required is not None:
            pulumi.set(__self__, "comment_required", comment_required)
        if initial_branch is not None:
            pulumi.set(__self__, "initial_branch", initial_branch)
        if override is not None:
            pulumi.set(__self__, "override", override)
        if use_yaml is not None:
            pulumi.set(__self__, "use_yaml", use_yaml)

    @property
    @pulumi.getter
    def forks(self) -> 'outputs.BuildDefinitionPullRequestTriggerForks':
        """
        Set permissions for Forked repositories.
        """
        return pulumi.get(self, "forks")

    @property
    @pulumi.getter(name="commentRequired")
    def comment_required(self) -> Optional[str]:
        return pulumi.get(self, "comment_required")

    @property
    @pulumi.getter(name="initialBranch")
    def initial_branch(self) -> Optional[str]:
        return pulumi.get(self, "initial_branch")

    @property
    @pulumi.getter
    def override(self) -> Optional['outputs.BuildDefinitionPullRequestTriggerOverride']:
        """
        Override the azure-pipeline file and use this configuration for all builds.
        """
        return pulumi.get(self, "override")

    @property
    @pulumi.getter(name="useYaml")
    def use_yaml(self) -> Optional[bool]:
        """
        Use the azure-pipeline file for the build configuration. Defaults to `false`.
        """
        return pulumi.get(self, "use_yaml")


@pulumi.output_type
class BuildDefinitionPullRequestTriggerForks(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "shareSecrets":
            suggest = "share_secrets"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in BuildDefinitionPullRequestTriggerForks. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        BuildDefinitionPullRequestTriggerForks.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        BuildDefinitionPullRequestTriggerForks.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 enabled: bool,
                 share_secrets: bool):
        """
        :param bool enabled: Build pull requests form forms of this repository.
        :param bool share_secrets: Make secrets available to builds of forks.
        """
        pulumi.set(__self__, "enabled", enabled)
        pulumi.set(__self__, "share_secrets", share_secrets)

    @property
    @pulumi.getter
    def enabled(self) -> bool:
        """
        Build pull requests form forms of this repository.
        """
        return pulumi.get(self, "enabled")

    @property
    @pulumi.getter(name="shareSecrets")
    def share_secrets(self) -> bool:
        """
        Make secrets available to builds of forks.
        """
        return pulumi.get(self, "share_secrets")


@pulumi.output_type
class BuildDefinitionPullRequestTriggerOverride(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "autoCancel":
            suggest = "auto_cancel"
        elif key == "branchFilters":
            suggest = "branch_filters"
        elif key == "pathFilters":
            suggest = "path_filters"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in BuildDefinitionPullRequestTriggerOverride. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        BuildDefinitionPullRequestTriggerOverride.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        BuildDefinitionPullRequestTriggerOverride.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 auto_cancel: Optional[bool] = None,
                 branch_filters: Optional[Sequence['outputs.BuildDefinitionPullRequestTriggerOverrideBranchFilter']] = None,
                 path_filters: Optional[Sequence['outputs.BuildDefinitionPullRequestTriggerOverridePathFilter']] = None):
        """
        :param bool auto_cancel: . Defaults to `true`.
        :param Sequence['BuildDefinitionPullRequestTriggerOverrideBranchFilterArgs'] branch_filters: The branches to include and exclude from the trigger.
        :param Sequence['BuildDefinitionPullRequestTriggerOverridePathFilterArgs'] path_filters: Specify file paths to include or exclude. Note that the wildcard syntax is different between branches/tags and file paths.
        """
        if auto_cancel is not None:
            pulumi.set(__self__, "auto_cancel", auto_cancel)
        if branch_filters is not None:
            pulumi.set(__self__, "branch_filters", branch_filters)
        if path_filters is not None:
            pulumi.set(__self__, "path_filters", path_filters)

    @property
    @pulumi.getter(name="autoCancel")
    def auto_cancel(self) -> Optional[bool]:
        """
        . Defaults to `true`.
        """
        return pulumi.get(self, "auto_cancel")

    @property
    @pulumi.getter(name="branchFilters")
    def branch_filters(self) -> Optional[Sequence['outputs.BuildDefinitionPullRequestTriggerOverrideBranchFilter']]:
        """
        The branches to include and exclude from the trigger.
        """
        return pulumi.get(self, "branch_filters")

    @property
    @pulumi.getter(name="pathFilters")
    def path_filters(self) -> Optional[Sequence['outputs.BuildDefinitionPullRequestTriggerOverridePathFilter']]:
        """
        Specify file paths to include or exclude. Note that the wildcard syntax is different between branches/tags and file paths.
        """
        return pulumi.get(self, "path_filters")


@pulumi.output_type
class BuildDefinitionPullRequestTriggerOverrideBranchFilter(dict):
    def __init__(__self__, *,
                 excludes: Optional[Sequence[str]] = None,
                 includes: Optional[Sequence[str]] = None):
        """
        :param Sequence[str] excludes: List of branch patterns to exclude.
        :param Sequence[str] includes: List of branch patterns to include.
        """
        if excludes is not None:
            pulumi.set(__self__, "excludes", excludes)
        if includes is not None:
            pulumi.set(__self__, "includes", includes)

    @property
    @pulumi.getter
    def excludes(self) -> Optional[Sequence[str]]:
        """
        List of branch patterns to exclude.
        """
        return pulumi.get(self, "excludes")

    @property
    @pulumi.getter
    def includes(self) -> Optional[Sequence[str]]:
        """
        List of branch patterns to include.
        """
        return pulumi.get(self, "includes")


@pulumi.output_type
class BuildDefinitionPullRequestTriggerOverridePathFilter(dict):
    def __init__(__self__, *,
                 excludes: Optional[Sequence[str]] = None,
                 includes: Optional[Sequence[str]] = None):
        """
        :param Sequence[str] excludes: List of branch patterns to exclude.
        :param Sequence[str] includes: List of branch patterns to include.
        """
        if excludes is not None:
            pulumi.set(__self__, "excludes", excludes)
        if includes is not None:
            pulumi.set(__self__, "includes", includes)

    @property
    @pulumi.getter
    def excludes(self) -> Optional[Sequence[str]]:
        """
        List of branch patterns to exclude.
        """
        return pulumi.get(self, "excludes")

    @property
    @pulumi.getter
    def includes(self) -> Optional[Sequence[str]]:
        """
        List of branch patterns to include.
        """
        return pulumi.get(self, "includes")


@pulumi.output_type
class BuildDefinitionRepository(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "repoId":
            suggest = "repo_id"
        elif key == "repoType":
            suggest = "repo_type"
        elif key == "ymlPath":
            suggest = "yml_path"
        elif key == "branchName":
            suggest = "branch_name"
        elif key == "githubEnterpriseUrl":
            suggest = "github_enterprise_url"
        elif key == "reportBuildStatus":
            suggest = "report_build_status"
        elif key == "serviceConnectionId":
            suggest = "service_connection_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in BuildDefinitionRepository. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        BuildDefinitionRepository.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        BuildDefinitionRepository.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 repo_id: str,
                 repo_type: str,
                 yml_path: str,
                 branch_name: Optional[str] = None,
                 github_enterprise_url: Optional[str] = None,
                 report_build_status: Optional[bool] = None,
                 service_connection_id: Optional[str] = None):
        """
        :param str repo_id: The id of the repository. For `TfsGit` repos, this is simply the ID of the repository. For `Github` repos, this will take the form of `<GitHub Org>/<Repo Name>`. For `Bitbucket` repos, this will take the form of `<Workspace ID>/<Repo Name>`.
        :param str repo_type: The repository type. Valid values: `GitHub` or `TfsGit` or `Bitbucket` or `GitHub Enterprise`. Defaults to `GitHub`. If `repo_type` is `GitHubEnterprise`, must use existing project and GitHub Enterprise service connection.
        :param str yml_path: The path of the Yaml file describing the build definition.
        :param str branch_name: The branch name for which builds are triggered. Defaults to `master`.
        :param str github_enterprise_url: The Github Enterprise URL. Used if `repo_type` is `GithubEnterprise`.
        :param bool report_build_status: Report build status. Default is true.
        :param str service_connection_id: The service connection ID. Used if the `repo_type` is `GitHub` or `GitHubEnterprise`.
        """
        pulumi.set(__self__, "repo_id", repo_id)
        pulumi.set(__self__, "repo_type", repo_type)
        pulumi.set(__self__, "yml_path", yml_path)
        if branch_name is not None:
            pulumi.set(__self__, "branch_name", branch_name)
        if github_enterprise_url is not None:
            pulumi.set(__self__, "github_enterprise_url", github_enterprise_url)
        if report_build_status is not None:
            pulumi.set(__self__, "report_build_status", report_build_status)
        if service_connection_id is not None:
            pulumi.set(__self__, "service_connection_id", service_connection_id)

    @property
    @pulumi.getter(name="repoId")
    def repo_id(self) -> str:
        """
        The id of the repository. For `TfsGit` repos, this is simply the ID of the repository. For `Github` repos, this will take the form of `<GitHub Org>/<Repo Name>`. For `Bitbucket` repos, this will take the form of `<Workspace ID>/<Repo Name>`.
        """
        return pulumi.get(self, "repo_id")

    @property
    @pulumi.getter(name="repoType")
    def repo_type(self) -> str:
        """
        The repository type. Valid values: `GitHub` or `TfsGit` or `Bitbucket` or `GitHub Enterprise`. Defaults to `GitHub`. If `repo_type` is `GitHubEnterprise`, must use existing project and GitHub Enterprise service connection.
        """
        return pulumi.get(self, "repo_type")

    @property
    @pulumi.getter(name="ymlPath")
    def yml_path(self) -> str:
        """
        The path of the Yaml file describing the build definition.
        """
        return pulumi.get(self, "yml_path")

    @property
    @pulumi.getter(name="branchName")
    def branch_name(self) -> Optional[str]:
        """
        The branch name for which builds are triggered. Defaults to `master`.
        """
        return pulumi.get(self, "branch_name")

    @property
    @pulumi.getter(name="githubEnterpriseUrl")
    def github_enterprise_url(self) -> Optional[str]:
        """
        The Github Enterprise URL. Used if `repo_type` is `GithubEnterprise`.
        """
        return pulumi.get(self, "github_enterprise_url")

    @property
    @pulumi.getter(name="reportBuildStatus")
    def report_build_status(self) -> Optional[bool]:
        """
        Report build status. Default is true.
        """
        return pulumi.get(self, "report_build_status")

    @property
    @pulumi.getter(name="serviceConnectionId")
    def service_connection_id(self) -> Optional[str]:
        """
        The service connection ID. Used if the `repo_type` is `GitHub` or `GitHubEnterprise`.
        """
        return pulumi.get(self, "service_connection_id")


@pulumi.output_type
class BuildDefinitionVariable(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "allowOverride":
            suggest = "allow_override"
        elif key == "isSecret":
            suggest = "is_secret"
        elif key == "secretValue":
            suggest = "secret_value"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in BuildDefinitionVariable. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        BuildDefinitionVariable.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        BuildDefinitionVariable.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 name: str,
                 allow_override: Optional[bool] = None,
                 is_secret: Optional[bool] = None,
                 secret_value: Optional[str] = None,
                 value: Optional[str] = None):
        """
        :param str name: The name of the variable.
        :param bool allow_override: True if the variable can be overridden. Defaults to `true`.
        :param bool is_secret: True if the variable is a secret. Defaults to `false`.
        :param str secret_value: The secret value of the variable. Used when `is_secret` set to `true`.
        :param str value: The value of the variable.
        """
        pulumi.set(__self__, "name", name)
        if allow_override is not None:
            pulumi.set(__self__, "allow_override", allow_override)
        if is_secret is not None:
            pulumi.set(__self__, "is_secret", is_secret)
        if secret_value is not None:
            pulumi.set(__self__, "secret_value", secret_value)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The name of the variable.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="allowOverride")
    def allow_override(self) -> Optional[bool]:
        """
        True if the variable can be overridden. Defaults to `true`.
        """
        return pulumi.get(self, "allow_override")

    @property
    @pulumi.getter(name="isSecret")
    def is_secret(self) -> Optional[bool]:
        """
        True if the variable is a secret. Defaults to `false`.
        """
        return pulumi.get(self, "is_secret")

    @property
    @pulumi.getter(name="secretValue")
    def secret_value(self) -> Optional[str]:
        """
        The secret value of the variable. Used when `is_secret` set to `true`.
        """
        return pulumi.get(self, "secret_value")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        """
        The value of the variable.
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class GitInitialization(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "initType":
            suggest = "init_type"
        elif key == "sourceType":
            suggest = "source_type"
        elif key == "sourceUrl":
            suggest = "source_url"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in GitInitialization. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        GitInitialization.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        GitInitialization.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 init_type: str,
                 source_type: Optional[str] = None,
                 source_url: Optional[str] = None):
        """
        :param str init_type: The type of repository to create. Valid values: `Uninitialized`, `Clean` or `Import`. Defaults to `Uninitialized`.
        :param str source_type: Type of the source repository. Used if the `init_type` is `Import`. Valid values: `Git`.
        :param str source_url: The URL of the source repository. Used if the `init_type` is `Import`.
        """
        pulumi.set(__self__, "init_type", init_type)
        if source_type is not None:
            pulumi.set(__self__, "source_type", source_type)
        if source_url is not None:
            pulumi.set(__self__, "source_url", source_url)

    @property
    @pulumi.getter(name="initType")
    def init_type(self) -> str:
        """
        The type of repository to create. Valid values: `Uninitialized`, `Clean` or `Import`. Defaults to `Uninitialized`.
        """
        return pulumi.get(self, "init_type")

    @property
    @pulumi.getter(name="sourceType")
    def source_type(self) -> Optional[str]:
        """
        Type of the source repository. Used if the `init_type` is `Import`. Valid values: `Git`.
        """
        return pulumi.get(self, "source_type")

    @property
    @pulumi.getter(name="sourceUrl")
    def source_url(self) -> Optional[str]:
        """
        The URL of the source repository. Used if the `init_type` is `Import`.
        """
        return pulumi.get(self, "source_url")


@pulumi.output_type
class ServiceEndpointArtifactoryAuthenticationBasic(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "passwordHash":
            suggest = "password_hash"
        elif key == "usernameHash":
            suggest = "username_hash"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ServiceEndpointArtifactoryAuthenticationBasic. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ServiceEndpointArtifactoryAuthenticationBasic.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ServiceEndpointArtifactoryAuthenticationBasic.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 password: str,
                 username: str,
                 password_hash: Optional[str] = None,
                 username_hash: Optional[str] = None):
        """
        :param str password: Artifactory Password.
        :param str username: Artifactory Username.
        """
        pulumi.set(__self__, "password", password)
        pulumi.set(__self__, "username", username)
        if password_hash is not None:
            pulumi.set(__self__, "password_hash", password_hash)
        if username_hash is not None:
            pulumi.set(__self__, "username_hash", username_hash)

    @property
    @pulumi.getter
    def password(self) -> str:
        """
        Artifactory Password.
        """
        return pulumi.get(self, "password")

    @property
    @pulumi.getter
    def username(self) -> str:
        """
        Artifactory Username.
        """
        return pulumi.get(self, "username")

    @property
    @pulumi.getter(name="passwordHash")
    def password_hash(self) -> Optional[str]:
        return pulumi.get(self, "password_hash")

    @property
    @pulumi.getter(name="usernameHash")
    def username_hash(self) -> Optional[str]:
        return pulumi.get(self, "username_hash")


@pulumi.output_type
class ServiceEndpointArtifactoryAuthenticationToken(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "tokenHash":
            suggest = "token_hash"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ServiceEndpointArtifactoryAuthenticationToken. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ServiceEndpointArtifactoryAuthenticationToken.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ServiceEndpointArtifactoryAuthenticationToken.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 token: str,
                 token_hash: Optional[str] = None):
        """
        :param str token: Authentication Token generated through Artifactory.
               * `authentication_basic`
        """
        pulumi.set(__self__, "token", token)
        if token_hash is not None:
            pulumi.set(__self__, "token_hash", token_hash)

    @property
    @pulumi.getter
    def token(self) -> str:
        """
        Authentication Token generated through Artifactory.
        * `authentication_basic`
        """
        return pulumi.get(self, "token")

    @property
    @pulumi.getter(name="tokenHash")
    def token_hash(self) -> Optional[str]:
        return pulumi.get(self, "token_hash")


@pulumi.output_type
class ServiceEndpointAzureRMCredentials(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "serviceprincipalkeyHash":
            suggest = "serviceprincipalkey_hash"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ServiceEndpointAzureRMCredentials. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ServiceEndpointAzureRMCredentials.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ServiceEndpointAzureRMCredentials.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 serviceprincipalid: str,
                 serviceprincipalkey: str,
                 serviceprincipalkey_hash: Optional[str] = None):
        """
        :param str serviceprincipalid: The service principal application Id
        :param str serviceprincipalkey: The service principal secret.
        """
        pulumi.set(__self__, "serviceprincipalid", serviceprincipalid)
        pulumi.set(__self__, "serviceprincipalkey", serviceprincipalkey)
        if serviceprincipalkey_hash is not None:
            pulumi.set(__self__, "serviceprincipalkey_hash", serviceprincipalkey_hash)

    @property
    @pulumi.getter
    def serviceprincipalid(self) -> str:
        """
        The service principal application Id
        """
        return pulumi.get(self, "serviceprincipalid")

    @property
    @pulumi.getter
    def serviceprincipalkey(self) -> str:
        """
        The service principal secret.
        """
        return pulumi.get(self, "serviceprincipalkey")

    @property
    @pulumi.getter(name="serviceprincipalkeyHash")
    def serviceprincipalkey_hash(self) -> Optional[str]:
        return pulumi.get(self, "serviceprincipalkey_hash")


@pulumi.output_type
class ServiceEndpointGitHubAuthOauth(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "oauthConfigurationId":
            suggest = "oauth_configuration_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ServiceEndpointGitHubAuthOauth. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ServiceEndpointGitHubAuthOauth.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ServiceEndpointGitHubAuthOauth.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 oauth_configuration_id: str):
        pulumi.set(__self__, "oauth_configuration_id", oauth_configuration_id)

    @property
    @pulumi.getter(name="oauthConfigurationId")
    def oauth_configuration_id(self) -> str:
        return pulumi.get(self, "oauth_configuration_id")


@pulumi.output_type
class ServiceEndpointGitHubAuthPersonal(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "personalAccessToken":
            suggest = "personal_access_token"
        elif key == "personalAccessTokenHash":
            suggest = "personal_access_token_hash"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ServiceEndpointGitHubAuthPersonal. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ServiceEndpointGitHubAuthPersonal.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ServiceEndpointGitHubAuthPersonal.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 personal_access_token: str,
                 personal_access_token_hash: Optional[str] = None):
        """
        :param str personal_access_token: The Personal Access Token for Github.
        """
        pulumi.set(__self__, "personal_access_token", personal_access_token)
        if personal_access_token_hash is not None:
            pulumi.set(__self__, "personal_access_token_hash", personal_access_token_hash)

    @property
    @pulumi.getter(name="personalAccessToken")
    def personal_access_token(self) -> str:
        """
        The Personal Access Token for Github.
        """
        return pulumi.get(self, "personal_access_token")

    @property
    @pulumi.getter(name="personalAccessTokenHash")
    def personal_access_token_hash(self) -> Optional[str]:
        return pulumi.get(self, "personal_access_token_hash")


@pulumi.output_type
class ServiceEndpointGitHubEnterpriseAuthPersonal(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "personalAccessToken":
            suggest = "personal_access_token"
        elif key == "personalAccessTokenHash":
            suggest = "personal_access_token_hash"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ServiceEndpointGitHubEnterpriseAuthPersonal. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ServiceEndpointGitHubEnterpriseAuthPersonal.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ServiceEndpointGitHubEnterpriseAuthPersonal.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 personal_access_token: str,
                 personal_access_token_hash: Optional[str] = None):
        """
        :param str personal_access_token: The Personal Access Token for Github.
        """
        pulumi.set(__self__, "personal_access_token", personal_access_token)
        if personal_access_token_hash is not None:
            pulumi.set(__self__, "personal_access_token_hash", personal_access_token_hash)

    @property
    @pulumi.getter(name="personalAccessToken")
    def personal_access_token(self) -> str:
        """
        The Personal Access Token for Github.
        """
        return pulumi.get(self, "personal_access_token")

    @property
    @pulumi.getter(name="personalAccessTokenHash")
    def personal_access_token_hash(self) -> Optional[str]:
        return pulumi.get(self, "personal_access_token_hash")


@pulumi.output_type
class ServiceEndpointKubernetesAzureSubscription(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "clusterName":
            suggest = "cluster_name"
        elif key == "resourcegroupId":
            suggest = "resourcegroup_id"
        elif key == "subscriptionId":
            suggest = "subscription_id"
        elif key == "subscriptionName":
            suggest = "subscription_name"
        elif key == "tenantId":
            suggest = "tenant_id"
        elif key == "azureEnvironment":
            suggest = "azure_environment"
        elif key == "clusterAdmin":
            suggest = "cluster_admin"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ServiceEndpointKubernetesAzureSubscription. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ServiceEndpointKubernetesAzureSubscription.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ServiceEndpointKubernetesAzureSubscription.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 cluster_name: str,
                 resourcegroup_id: str,
                 subscription_id: str,
                 subscription_name: str,
                 tenant_id: str,
                 azure_environment: Optional[str] = None,
                 cluster_admin: Optional[bool] = None,
                 namespace: Optional[str] = None):
        """
        :param str cluster_name: The name of the Kubernetes cluster.
        :param str resourcegroup_id: The resource group name, to which the Kubernetes cluster is deployed.
        :param str subscription_id: The id of the Azure subscription.
        :param str subscription_name: The name of the Azure subscription.
        :param str tenant_id: The id of the tenant used by the subscription.
        :param str azure_environment: Azure environment refers to whether the public cloud offering or domestic (government) clouds are being used. Currently, only the public cloud is supported. The value must be AzureCloud. This is also the default-value.
        :param bool cluster_admin: Set this option to allow use cluster admin credentials.
        :param str namespace: The Kubernetes namespace. Default value is "default".
        """
        pulumi.set(__self__, "cluster_name", cluster_name)
        pulumi.set(__self__, "resourcegroup_id", resourcegroup_id)
        pulumi.set(__self__, "subscription_id", subscription_id)
        pulumi.set(__self__, "subscription_name", subscription_name)
        pulumi.set(__self__, "tenant_id", tenant_id)
        if azure_environment is not None:
            pulumi.set(__self__, "azure_environment", azure_environment)
        if cluster_admin is not None:
            pulumi.set(__self__, "cluster_admin", cluster_admin)
        if namespace is not None:
            pulumi.set(__self__, "namespace", namespace)

    @property
    @pulumi.getter(name="clusterName")
    def cluster_name(self) -> str:
        """
        The name of the Kubernetes cluster.
        """
        return pulumi.get(self, "cluster_name")

    @property
    @pulumi.getter(name="resourcegroupId")
    def resourcegroup_id(self) -> str:
        """
        The resource group name, to which the Kubernetes cluster is deployed.
        """
        return pulumi.get(self, "resourcegroup_id")

    @property
    @pulumi.getter(name="subscriptionId")
    def subscription_id(self) -> str:
        """
        The id of the Azure subscription.
        """
        return pulumi.get(self, "subscription_id")

    @property
    @pulumi.getter(name="subscriptionName")
    def subscription_name(self) -> str:
        """
        The name of the Azure subscription.
        """
        return pulumi.get(self, "subscription_name")

    @property
    @pulumi.getter(name="tenantId")
    def tenant_id(self) -> str:
        """
        The id of the tenant used by the subscription.
        """
        return pulumi.get(self, "tenant_id")

    @property
    @pulumi.getter(name="azureEnvironment")
    def azure_environment(self) -> Optional[str]:
        """
        Azure environment refers to whether the public cloud offering or domestic (government) clouds are being used. Currently, only the public cloud is supported. The value must be AzureCloud. This is also the default-value.
        """
        return pulumi.get(self, "azure_environment")

    @property
    @pulumi.getter(name="clusterAdmin")
    def cluster_admin(self) -> Optional[bool]:
        """
        Set this option to allow use cluster admin credentials.
        """
        return pulumi.get(self, "cluster_admin")

    @property
    @pulumi.getter
    def namespace(self) -> Optional[str]:
        """
        The Kubernetes namespace. Default value is "default".
        """
        return pulumi.get(self, "namespace")


@pulumi.output_type
class ServiceEndpointKubernetesKubeconfig(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "kubeConfig":
            suggest = "kube_config"
        elif key == "acceptUntrustedCerts":
            suggest = "accept_untrusted_certs"
        elif key == "clusterContext":
            suggest = "cluster_context"
        elif key == "kubeConfigHash":
            suggest = "kube_config_hash"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ServiceEndpointKubernetesKubeconfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ServiceEndpointKubernetesKubeconfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ServiceEndpointKubernetesKubeconfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 kube_config: str,
                 accept_untrusted_certs: Optional[bool] = None,
                 cluster_context: Optional[str] = None,
                 kube_config_hash: Optional[str] = None):
        """
        :param str kube_config: The content of the kubeconfig in yaml notation to be used to communicate with the API-Server of Kubernetes.
        :param bool accept_untrusted_certs: Set this option to allow clients to accept a self-signed certificate.
        :param str cluster_context: Context within the kubeconfig file that is to be used for identifying the cluster. Default value is the current-context set in kubeconfig.
        """
        pulumi.set(__self__, "kube_config", kube_config)
        if accept_untrusted_certs is not None:
            pulumi.set(__self__, "accept_untrusted_certs", accept_untrusted_certs)
        if cluster_context is not None:
            pulumi.set(__self__, "cluster_context", cluster_context)
        if kube_config_hash is not None:
            pulumi.set(__self__, "kube_config_hash", kube_config_hash)

    @property
    @pulumi.getter(name="kubeConfig")
    def kube_config(self) -> str:
        """
        The content of the kubeconfig in yaml notation to be used to communicate with the API-Server of Kubernetes.
        """
        return pulumi.get(self, "kube_config")

    @property
    @pulumi.getter(name="acceptUntrustedCerts")
    def accept_untrusted_certs(self) -> Optional[bool]:
        """
        Set this option to allow clients to accept a self-signed certificate.
        """
        return pulumi.get(self, "accept_untrusted_certs")

    @property
    @pulumi.getter(name="clusterContext")
    def cluster_context(self) -> Optional[str]:
        """
        Context within the kubeconfig file that is to be used for identifying the cluster. Default value is the current-context set in kubeconfig.
        """
        return pulumi.get(self, "cluster_context")

    @property
    @pulumi.getter(name="kubeConfigHash")
    def kube_config_hash(self) -> Optional[str]:
        return pulumi.get(self, "kube_config_hash")


@pulumi.output_type
class ServiceEndpointKubernetesServiceAccount(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "caCert":
            suggest = "ca_cert"
        elif key == "caCertHash":
            suggest = "ca_cert_hash"
        elif key == "tokenHash":
            suggest = "token_hash"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ServiceEndpointKubernetesServiceAccount. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ServiceEndpointKubernetesServiceAccount.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ServiceEndpointKubernetesServiceAccount.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 ca_cert: str,
                 token: str,
                 ca_cert_hash: Optional[str] = None,
                 token_hash: Optional[str] = None):
        """
        :param str ca_cert: The certificate from a Kubernetes secret object.
        :param str token: The token from a Kubernetes secret object.
        """
        pulumi.set(__self__, "ca_cert", ca_cert)
        pulumi.set(__self__, "token", token)
        if ca_cert_hash is not None:
            pulumi.set(__self__, "ca_cert_hash", ca_cert_hash)
        if token_hash is not None:
            pulumi.set(__self__, "token_hash", token_hash)

    @property
    @pulumi.getter(name="caCert")
    def ca_cert(self) -> str:
        """
        The certificate from a Kubernetes secret object.
        """
        return pulumi.get(self, "ca_cert")

    @property
    @pulumi.getter
    def token(self) -> str:
        """
        The token from a Kubernetes secret object.
        """
        return pulumi.get(self, "token")

    @property
    @pulumi.getter(name="caCertHash")
    def ca_cert_hash(self) -> Optional[str]:
        return pulumi.get(self, "ca_cert_hash")

    @property
    @pulumi.getter(name="tokenHash")
    def token_hash(self) -> Optional[str]:
        return pulumi.get(self, "token_hash")


@pulumi.output_type
class ServiceEndpointPipelineAuthPersonal(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "personalAccessToken":
            suggest = "personal_access_token"
        elif key == "personalAccessTokenHash":
            suggest = "personal_access_token_hash"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ServiceEndpointPipelineAuthPersonal. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ServiceEndpointPipelineAuthPersonal.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ServiceEndpointPipelineAuthPersonal.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 personal_access_token: str,
                 personal_access_token_hash: Optional[str] = None):
        """
        :param str personal_access_token: The Personal Access Token for Azure DevOps Pipeline. It also can be set with AZDO_PERSONAL_ACCESS_TOKEN environment variable.
        """
        pulumi.set(__self__, "personal_access_token", personal_access_token)
        if personal_access_token_hash is not None:
            pulumi.set(__self__, "personal_access_token_hash", personal_access_token_hash)

    @property
    @pulumi.getter(name="personalAccessToken")
    def personal_access_token(self) -> str:
        """
        The Personal Access Token for Azure DevOps Pipeline. It also can be set with AZDO_PERSONAL_ACCESS_TOKEN environment variable.
        """
        return pulumi.get(self, "personal_access_token")

    @property
    @pulumi.getter(name="personalAccessTokenHash")
    def personal_access_token_hash(self) -> Optional[str]:
        return pulumi.get(self, "personal_access_token_hash")


@pulumi.output_type
class VariableGroupKeyVault(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "serviceEndpointId":
            suggest = "service_endpoint_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in VariableGroupKeyVault. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        VariableGroupKeyVault.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        VariableGroupKeyVault.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 name: str,
                 service_endpoint_id: str):
        """
        :param str name: The name of the Variable Group.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "service_endpoint_id", service_endpoint_id)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The name of the Variable Group.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="serviceEndpointId")
    def service_endpoint_id(self) -> str:
        return pulumi.get(self, "service_endpoint_id")


@pulumi.output_type
class VariableGroupVariable(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "contentType":
            suggest = "content_type"
        elif key == "isSecret":
            suggest = "is_secret"
        elif key == "secretValue":
            suggest = "secret_value"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in VariableGroupVariable. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        VariableGroupVariable.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        VariableGroupVariable.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 name: str,
                 content_type: Optional[str] = None,
                 enabled: Optional[bool] = None,
                 expires: Optional[str] = None,
                 is_secret: Optional[bool] = None,
                 secret_value: Optional[str] = None,
                 value: Optional[str] = None):
        """
        :param str name: The key value used for the variable. Must be unique within the Variable Group.
        :param bool is_secret: A boolean flag describing if the variable value is sensitive. Defaults to `false`.
        :param str secret_value: The secret value of the variable. If omitted, it will default to empty string. Used when `is_secret` set to `true`.
        :param str value: The value of the variable. If omitted, it will default to empty string.
        """
        pulumi.set(__self__, "name", name)
        if content_type is not None:
            pulumi.set(__self__, "content_type", content_type)
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if expires is not None:
            pulumi.set(__self__, "expires", expires)
        if is_secret is not None:
            pulumi.set(__self__, "is_secret", is_secret)
        if secret_value is not None:
            pulumi.set(__self__, "secret_value", secret_value)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The key value used for the variable. Must be unique within the Variable Group.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="contentType")
    def content_type(self) -> Optional[str]:
        return pulumi.get(self, "content_type")

    @property
    @pulumi.getter
    def enabled(self) -> Optional[bool]:
        return pulumi.get(self, "enabled")

    @property
    @pulumi.getter
    def expires(self) -> Optional[str]:
        return pulumi.get(self, "expires")

    @property
    @pulumi.getter(name="isSecret")
    def is_secret(self) -> Optional[bool]:
        """
        A boolean flag describing if the variable value is sensitive. Defaults to `false`.
        """
        return pulumi.get(self, "is_secret")

    @property
    @pulumi.getter(name="secretValue")
    def secret_value(self) -> Optional[str]:
        """
        The secret value of the variable. If omitted, it will default to empty string. Used when `is_secret` set to `true`.
        """
        return pulumi.get(self, "secret_value")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        """
        The value of the variable. If omitted, it will default to empty string.
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class GetAreaChildrenResult(dict):
    def __init__(__self__, *,
                 has_children: bool,
                 id: str,
                 name: str,
                 path: str,
                 project_id: str):
        """
        :param bool has_children: Indicator if the child Area node has child nodes
        :param str id: The id of the child Area node
        :param str name: The name of the child Area node
        :param str path: The path to the Area; _Format_: URL relative; if omitted, or value `"/"` is used, the root Area will be returned
        :param str project_id: The project ID.
        """
        pulumi.set(__self__, "has_children", has_children)
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "path", path)
        pulumi.set(__self__, "project_id", project_id)

    @property
    @pulumi.getter(name="hasChildren")
    def has_children(self) -> bool:
        """
        Indicator if the child Area node has child nodes
        """
        return pulumi.get(self, "has_children")

    @property
    @pulumi.getter
    def id(self) -> str:
        """
        The id of the child Area node
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The name of the child Area node
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def path(self) -> str:
        """
        The path to the Area; _Format_: URL relative; if omitted, or value `"/"` is used, the root Area will be returned
        """
        return pulumi.get(self, "path")

    @property
    @pulumi.getter(name="projectId")
    def project_id(self) -> str:
        """
        The project ID.
        """
        return pulumi.get(self, "project_id")


@pulumi.output_type
class GetIterationChildrenResult(dict):
    def __init__(__self__, *,
                 has_children: bool,
                 id: str,
                 name: str,
                 path: str,
                 project_id: str):
        """
        :param bool has_children: Indicator if the child Iteration node has child nodes
        :param str id: The id of the child Iteration node
        :param str name: The name of the child Iteration node
        :param str path: The path to the Iteration, _Format_: URL relative; if omitted, or value `"/"` is used, the root Iteration will be returned
        :param str project_id: The project ID.
        """
        pulumi.set(__self__, "has_children", has_children)
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "path", path)
        pulumi.set(__self__, "project_id", project_id)

    @property
    @pulumi.getter(name="hasChildren")
    def has_children(self) -> bool:
        """
        Indicator if the child Iteration node has child nodes
        """
        return pulumi.get(self, "has_children")

    @property
    @pulumi.getter
    def id(self) -> str:
        """
        The id of the child Iteration node
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The name of the child Iteration node
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def path(self) -> str:
        """
        The path to the Iteration, _Format_: URL relative; if omitted, or value `"/"` is used, the root Iteration will be returned
        """
        return pulumi.get(self, "path")

    @property
    @pulumi.getter(name="projectId")
    def project_id(self) -> str:
        """
        The project ID.
        """
        return pulumi.get(self, "project_id")


@pulumi.output_type
class GetPoolsAgentPoolResult(dict):
    def __init__(__self__, *,
                 auto_provision: bool,
                 id: int,
                 name: str,
                 pool_type: str):
        """
        :param bool auto_provision: Specifies whether or not a queue should be automatically provisioned for each project collection.
        :param str name: The name of the agent pool
        :param str pool_type: Specifies whether the agent pool type is Automation or Deployment.
        """
        pulumi.set(__self__, "auto_provision", auto_provision)
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "pool_type", pool_type)

    @property
    @pulumi.getter(name="autoProvision")
    def auto_provision(self) -> bool:
        """
        Specifies whether or not a queue should be automatically provisioned for each project collection.
        """
        return pulumi.get(self, "auto_provision")

    @property
    @pulumi.getter
    def id(self) -> int:
        return pulumi.get(self, "id")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The name of the agent pool
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="poolType")
    def pool_type(self) -> str:
        """
        Specifies whether the agent pool type is Automation or Deployment.
        """
        return pulumi.get(self, "pool_type")


@pulumi.output_type
class GetProjectsProjectResult(dict):
    def __init__(__self__, *,
                 name: str,
                 project_id: str,
                 project_url: str,
                 state: str):
        """
        :param str name: Name of the Project, if not specified all projects will be returned.
        :param str project_id: Project identifier.
        :param str project_url: Url to the full version of the object.
        :param str state: State of the Project, if not specified all projects will be returned. Valid values are `all`, `deleting`, `new`, `wellFormed`, `createPending`, `unchanged`,`deleted`.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "project_id", project_id)
        pulumi.set(__self__, "project_url", project_url)
        pulumi.set(__self__, "state", state)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Name of the Project, if not specified all projects will be returned.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="projectId")
    def project_id(self) -> str:
        """
        Project identifier.
        """
        return pulumi.get(self, "project_id")

    @property
    @pulumi.getter(name="projectUrl")
    def project_url(self) -> str:
        """
        Url to the full version of the object.
        """
        return pulumi.get(self, "project_url")

    @property
    @pulumi.getter
    def state(self) -> str:
        """
        State of the Project, if not specified all projects will be returned. Valid values are `all`, `deleting`, `new`, `wellFormed`, `createPending`, `unchanged`,`deleted`.
        """
        return pulumi.get(self, "state")


@pulumi.output_type
class GetRepositoriesRepositoryResult(dict):
    def __init__(__self__, *,
                 default_branch: str,
                 id: str,
                 name: str,
                 project_id: str,
                 remote_url: str,
                 size: int,
                 ssh_url: str,
                 url: str,
                 web_url: str):
        """
        :param str default_branch: The ref of the default branch.
        :param str id: Git repository identifier.
        :param str name: Name of the Git repository to retrieve; requires `project_id` to be specified as well
        :param str project_id: ID of project to list Git repositories
        :param str remote_url: HTTPS Url to clone the Git repository
        :param int size: Compressed size (bytes) of the repository.
        :param str ssh_url: SSH Url to clone the Git repository
        :param str url: Details REST API endpoint for the Git Repository.
        :param str web_url: Url of the Git repository web view
        """
        pulumi.set(__self__, "default_branch", default_branch)
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "project_id", project_id)
        pulumi.set(__self__, "remote_url", remote_url)
        pulumi.set(__self__, "size", size)
        pulumi.set(__self__, "ssh_url", ssh_url)
        pulumi.set(__self__, "url", url)
        pulumi.set(__self__, "web_url", web_url)

    @property
    @pulumi.getter(name="defaultBranch")
    def default_branch(self) -> str:
        """
        The ref of the default branch.
        """
        return pulumi.get(self, "default_branch")

    @property
    @pulumi.getter
    def id(self) -> str:
        """
        Git repository identifier.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Name of the Git repository to retrieve; requires `project_id` to be specified as well
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="projectId")
    def project_id(self) -> str:
        """
        ID of project to list Git repositories
        """
        return pulumi.get(self, "project_id")

    @property
    @pulumi.getter(name="remoteUrl")
    def remote_url(self) -> str:
        """
        HTTPS Url to clone the Git repository
        """
        return pulumi.get(self, "remote_url")

    @property
    @pulumi.getter
    def size(self) -> int:
        """
        Compressed size (bytes) of the repository.
        """
        return pulumi.get(self, "size")

    @property
    @pulumi.getter(name="sshUrl")
    def ssh_url(self) -> str:
        """
        SSH Url to clone the Git repository
        """
        return pulumi.get(self, "ssh_url")

    @property
    @pulumi.getter
    def url(self) -> str:
        """
        Details REST API endpoint for the Git Repository.
        """
        return pulumi.get(self, "url")

    @property
    @pulumi.getter(name="webUrl")
    def web_url(self) -> str:
        """
        Url of the Git repository web view
        """
        return pulumi.get(self, "web_url")


@pulumi.output_type
class GetUsersUserResult(dict):
    def __init__(__self__, *,
                 descriptor: str,
                 display_name: str,
                 mail_address: str,
                 origin: str,
                 principal_name: str,
                 origin_id: Optional[str] = None):
        """
        :param str descriptor: The descriptor is the primary way to reference the graph subject while the system is running. This field will uniquely identify the same graph subject across both Accounts and Organizations.
        :param str display_name: This is the non-unique display name of the graph subject. To change this field, you must alter its value in the source provider.
        :param str mail_address: The email address of record for a given graph member. This may be different than the principal name.
        :param str origin: The type of source provider for the `origin_id` parameter (ex:AD, AAD, MSA) The supported origins are listed below.
        :param str principal_name: The PrincipalName of this graph member from the source provider.
        :param str origin_id: The unique identifier from the system of origin.
        """
        pulumi.set(__self__, "descriptor", descriptor)
        pulumi.set(__self__, "display_name", display_name)
        pulumi.set(__self__, "mail_address", mail_address)
        pulumi.set(__self__, "origin", origin)
        pulumi.set(__self__, "principal_name", principal_name)
        if origin_id is not None:
            pulumi.set(__self__, "origin_id", origin_id)

    @property
    @pulumi.getter
    def descriptor(self) -> str:
        """
        The descriptor is the primary way to reference the graph subject while the system is running. This field will uniquely identify the same graph subject across both Accounts and Organizations.
        """
        return pulumi.get(self, "descriptor")

    @property
    @pulumi.getter(name="displayName")
    def display_name(self) -> str:
        """
        This is the non-unique display name of the graph subject. To change this field, you must alter its value in the source provider.
        """
        return pulumi.get(self, "display_name")

    @property
    @pulumi.getter(name="mailAddress")
    def mail_address(self) -> str:
        """
        The email address of record for a given graph member. This may be different than the principal name.
        """
        return pulumi.get(self, "mail_address")

    @property
    @pulumi.getter
    def origin(self) -> str:
        """
        The type of source provider for the `origin_id` parameter (ex:AD, AAD, MSA) The supported origins are listed below.
        """
        return pulumi.get(self, "origin")

    @property
    @pulumi.getter(name="principalName")
    def principal_name(self) -> str:
        """
        The PrincipalName of this graph member from the source provider.
        """
        return pulumi.get(self, "principal_name")

    @property
    @pulumi.getter(name="originId")
    def origin_id(self) -> Optional[str]:
        """
        The unique identifier from the system of origin.
        """
        return pulumi.get(self, "origin_id")


