# coding=utf-8
# *** WARNING: this file was generated by pulumi-language-python. ***
# *** Do not edit by hand unless you're certain you know what you are doing! ***

import builtins as _builtins
import warnings
import sys
import pulumi
import pulumi.runtime
from typing import Any, Mapping, Optional, Sequence, Union, overload
if sys.version_info >= (3, 11):
    from typing import NotRequired, TypedDict, TypeAlias
else:
    from typing_extensions import NotRequired, TypedDict, TypeAlias
from . import _utilities
from . import outputs

__all__ = [
    'BranchPolicyAutoReviewersSettings',
    'BranchPolicyAutoReviewersSettingsScope',
    'BranchPolicyBuildValidationSettings',
    'BranchPolicyBuildValidationSettingsScope',
    'BranchPolicyCommentResolutionSettings',
    'BranchPolicyCommentResolutionSettingsScope',
    'BranchPolicyMergeTypesSettings',
    'BranchPolicyMergeTypesSettingsScope',
    'BranchPolicyMinReviewersSettings',
    'BranchPolicyMinReviewersSettingsScope',
    'BranchPolicyStatusCheckSettings',
    'BranchPolicyStatusCheckSettingsScope',
    'BranchPolicyWorkItemLinkingSettings',
    'BranchPolicyWorkItemLinkingSettingsScope',
    'BuildDefinitionBuildCompletionTrigger',
    'BuildDefinitionBuildCompletionTriggerBranchFilter',
    'BuildDefinitionCiTrigger',
    'BuildDefinitionCiTriggerOverride',
    'BuildDefinitionCiTriggerOverrideBranchFilter',
    'BuildDefinitionCiTriggerOverridePathFilter',
    'BuildDefinitionFeature',
    'BuildDefinitionJob',
    'BuildDefinitionJobDependency',
    'BuildDefinitionJobTarget',
    'BuildDefinitionJobTargetExecutionOptions',
    'BuildDefinitionPullRequestTrigger',
    'BuildDefinitionPullRequestTriggerForks',
    'BuildDefinitionPullRequestTriggerOverride',
    'BuildDefinitionPullRequestTriggerOverrideBranchFilter',
    'BuildDefinitionPullRequestTriggerOverridePathFilter',
    'BuildDefinitionRepository',
    'BuildDefinitionSchedule',
    'BuildDefinitionScheduleBranchFilter',
    'BuildDefinitionVariable',
    'CheckRequiredTemplateRequiredTemplate',
    'FeedFeature',
    'GitInitialization',
    'ServiceEndpointArtifactoryAuthenticationBasic',
    'ServiceEndpointArtifactoryAuthenticationToken',
    'ServiceEndpointAzureEcrCredentials',
    'ServiceEndpointAzureRMCredentials',
    'ServiceEndpointAzureRMFeatures',
    'ServiceEndpointGitHubAuthOauth',
    'ServiceEndpointGitHubAuthPersonal',
    'ServiceEndpointGitHubEnterpriseAuthOauth',
    'ServiceEndpointGitHubEnterpriseAuthPersonal',
    'ServiceEndpointKubernetesAzureSubscription',
    'ServiceEndpointKubernetesKubeconfig',
    'ServiceEndpointKubernetesServiceAccount',
    'ServiceEndpointPipelineAuthPersonal',
    'ServiceEndpointServiceFabricAzureActiveDirectory',
    'ServiceEndpointServiceFabricCertificate',
    'ServiceEndpointServiceFabricNone',
    'ServiceendpointArgocdAuthenticationBasic',
    'ServiceendpointArgocdAuthenticationToken',
    'ServiceendpointExternaltfsAuthPersonal',
    'ServiceendpointJfrogArtifactoryV2AuthenticationBasic',
    'ServiceendpointJfrogArtifactoryV2AuthenticationToken',
    'ServiceendpointJfrogDistributionV2AuthenticationBasic',
    'ServiceendpointJfrogDistributionV2AuthenticationToken',
    'ServiceendpointJfrogPlatformV2AuthenticationBasic',
    'ServiceendpointJfrogPlatformV2AuthenticationToken',
    'ServiceendpointJfrogXrayV2AuthenticationBasic',
    'ServiceendpointJfrogXrayV2AuthenticationToken',
    'ServiceendpointMavenAuthenticationBasic',
    'ServiceendpointMavenAuthenticationToken',
    'ServiceendpointOpenshiftAuthBasic',
    'ServiceendpointOpenshiftAuthNone',
    'ServiceendpointOpenshiftAuthToken',
    'ServiceendpointVisualstudiomarketplaceAuthenticationBasic',
    'ServiceendpointVisualstudiomarketplaceAuthenticationToken',
    'ServicehookStorageQueuePipelinesRunStateChangedEvent',
    'ServicehookStorageQueuePipelinesStageStateChangedEvent',
    'ServicehookWebhookTfsBuildCompleted',
    'ServicehookWebhookTfsGitPullRequestCommented',
    'ServicehookWebhookTfsGitPullRequestCreated',
    'ServicehookWebhookTfsGitPullRequestMergeAttempted',
    'ServicehookWebhookTfsGitPullRequestUpdated',
    'ServicehookWebhookTfsGitPush',
    'ServicehookWebhookTfsRepositoryCreated',
    'ServicehookWebhookTfsRepositoryDeleted',
    'ServicehookWebhookTfsRepositoryForked',
    'ServicehookWebhookTfsRepositoryRenamed',
    'ServicehookWebhookTfsRepositoryStatusChanged',
    'ServicehookWebhookTfsServiceConnectionCreated',
    'ServicehookWebhookTfsServiceConnectionUpdated',
    'ServicehookWebhookTfsTfvcCheckin',
    'ServicehookWebhookTfsWorkItemCommented',
    'ServicehookWebhookTfsWorkItemCreated',
    'ServicehookWebhookTfsWorkItemDeleted',
    'ServicehookWebhookTfsWorkItemRestored',
    'ServicehookWebhookTfsWorkItemUpdated',
    'VariableGroupKeyVault',
    'VariableGroupVariable',
    'WorkitemRelation',
    'GetAreaChildrenResult',
    'GetBuildDefinitionCiTriggerResult',
    'GetBuildDefinitionCiTriggerOverrideResult',
    'GetBuildDefinitionCiTriggerOverrideBranchFilterResult',
    'GetBuildDefinitionCiTriggerOverridePathFilterResult',
    'GetBuildDefinitionJobResult',
    'GetBuildDefinitionJobDependencyResult',
    'GetBuildDefinitionJobTargetResult',
    'GetBuildDefinitionJobTargetExecutionOptionResult',
    'GetBuildDefinitionPullRequestTriggerResult',
    'GetBuildDefinitionPullRequestTriggerForkResult',
    'GetBuildDefinitionPullRequestTriggerOverrideResult',
    'GetBuildDefinitionPullRequestTriggerOverrideBranchFilterResult',
    'GetBuildDefinitionPullRequestTriggerOverridePathFilterResult',
    'GetBuildDefinitionRepositoryResult',
    'GetBuildDefinitionScheduleResult',
    'GetBuildDefinitionScheduleBranchFilterResult',
    'GetBuildDefinitionVariableResult',
    'GetGroupsGroupResult',
    'GetIdentityGroupsGroupResult',
    'GetIterationChildrenResult',
    'GetPoolsAgentPoolResult',
    'GetProjectsProjectResult',
    'GetRepositoriesRepositoryResult',
    'GetSecurityroleDefinitionsDefinitionResult',
    'GetTeamsTeamResult',
    'GetUsersFeaturesResult',
    'GetUsersUserResult',
    'GetVariableGroupKeyVaultResult',
    'GetVariableGroupVariableResult',
    'GetWorkitemtrackingprocessProcessProjectResult',
    'GetWorkitemtrackingprocessProcessesProcessResult',
    'GetWorkitemtrackingprocessProcessesProcessProjectResult',
]

@pulumi.output_type
class BranchPolicyAutoReviewersSettings(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "autoReviewerIds":
            suggest = "auto_reviewer_ids"
        elif key == "minimumNumberOfReviewers":
            suggest = "minimum_number_of_reviewers"
        elif key == "pathFilters":
            suggest = "path_filters"
        elif key == "submitterCanVote":
            suggest = "submitter_can_vote"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in BranchPolicyAutoReviewersSettings. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        BranchPolicyAutoReviewersSettings.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        BranchPolicyAutoReviewersSettings.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 auto_reviewer_ids: Sequence[_builtins.str],
                 scopes: Sequence['outputs.BranchPolicyAutoReviewersSettingsScope'],
                 message: Optional[_builtins.str] = None,
                 minimum_number_of_reviewers: Optional[_builtins.int] = None,
                 path_filters: Optional[Sequence[_builtins.str]] = None,
                 submitter_can_vote: Optional[_builtins.bool] = None):
        """
        :param Sequence[_builtins.str] auto_reviewer_ids: Required reviewers ids. Supports multiples user Ids.
        :param Sequence['BranchPolicyAutoReviewersSettingsScopeArgs'] scopes: A `scope` block as defined below. Controls which repositories and branches the policy will be enabled for. This block must be defined at least once.
        :param _builtins.str message: Activity feed message, Message will appear in the activity feed of pull requests with automatically added reviewers.
        :param _builtins.int minimum_number_of_reviewers: Minimum number of required reviewers. Defaults to `1`.
               
               > **Note** Has to be greater than `0`. Can only be greater than `1` when attribute `auto_reviewer_ids` contains exactly one group! Only has an effect when attribute `blocking` is set to `true`.
        :param Sequence[_builtins.str] path_filters: Filter path(s) on which the policy is applied. Supports absolute paths, wildcards and multiple paths. Example: /WebApp/Models/Data.cs, /WebApp/* or *.cs,/WebApp/Models/Data.cs;ClientApp/Models/Data.cs.
        :param _builtins.bool submitter_can_vote: Controls whether or not the submitter's vote counts. Defaults to `false`.
        """
        pulumi.set(__self__, "auto_reviewer_ids", auto_reviewer_ids)
        pulumi.set(__self__, "scopes", scopes)
        if message is not None:
            pulumi.set(__self__, "message", message)
        if minimum_number_of_reviewers is not None:
            pulumi.set(__self__, "minimum_number_of_reviewers", minimum_number_of_reviewers)
        if path_filters is not None:
            pulumi.set(__self__, "path_filters", path_filters)
        if submitter_can_vote is not None:
            pulumi.set(__self__, "submitter_can_vote", submitter_can_vote)

    @_builtins.property
    @pulumi.getter(name="autoReviewerIds")
    def auto_reviewer_ids(self) -> Sequence[_builtins.str]:
        """
        Required reviewers ids. Supports multiples user Ids.
        """
        return pulumi.get(self, "auto_reviewer_ids")

    @_builtins.property
    @pulumi.getter
    def scopes(self) -> Sequence['outputs.BranchPolicyAutoReviewersSettingsScope']:
        """
        A `scope` block as defined below. Controls which repositories and branches the policy will be enabled for. This block must be defined at least once.
        """
        return pulumi.get(self, "scopes")

    @_builtins.property
    @pulumi.getter
    def message(self) -> Optional[_builtins.str]:
        """
        Activity feed message, Message will appear in the activity feed of pull requests with automatically added reviewers.
        """
        return pulumi.get(self, "message")

    @_builtins.property
    @pulumi.getter(name="minimumNumberOfReviewers")
    def minimum_number_of_reviewers(self) -> Optional[_builtins.int]:
        """
        Minimum number of required reviewers. Defaults to `1`.

        > **Note** Has to be greater than `0`. Can only be greater than `1` when attribute `auto_reviewer_ids` contains exactly one group! Only has an effect when attribute `blocking` is set to `true`.
        """
        return pulumi.get(self, "minimum_number_of_reviewers")

    @_builtins.property
    @pulumi.getter(name="pathFilters")
    def path_filters(self) -> Optional[Sequence[_builtins.str]]:
        """
        Filter path(s) on which the policy is applied. Supports absolute paths, wildcards and multiple paths. Example: /WebApp/Models/Data.cs, /WebApp/* or *.cs,/WebApp/Models/Data.cs;ClientApp/Models/Data.cs.
        """
        return pulumi.get(self, "path_filters")

    @_builtins.property
    @pulumi.getter(name="submitterCanVote")
    def submitter_can_vote(self) -> Optional[_builtins.bool]:
        """
        Controls whether or not the submitter's vote counts. Defaults to `false`.
        """
        return pulumi.get(self, "submitter_can_vote")


@pulumi.output_type
class BranchPolicyAutoReviewersSettingsScope(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "matchType":
            suggest = "match_type"
        elif key == "repositoryId":
            suggest = "repository_id"
        elif key == "repositoryRef":
            suggest = "repository_ref"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in BranchPolicyAutoReviewersSettingsScope. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        BranchPolicyAutoReviewersSettingsScope.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        BranchPolicyAutoReviewersSettingsScope.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 match_type: Optional[_builtins.str] = None,
                 repository_id: Optional[_builtins.str] = None,
                 repository_ref: Optional[_builtins.str] = None):
        """
        :param _builtins.str match_type: The match type to use when applying the policy. Supported values are `Exact` (default), `Prefix` or `DefaultBranch`.
        :param _builtins.str repository_id: The repository ID. Needed only if the scope of the policy will be limited to a single repository. If `match_type` is `DefaultBranch`, this should not be defined.
        :param _builtins.str repository_ref: The ref pattern to use for the match when `match_type` other than `DefaultBranch`. If `match_type` is `Exact`, this should be a qualified ref such as `refs/heads/master`. If `match_type` is `Prefix`, this should be a ref path such as `refs/heads/releases`.
        """
        if match_type is not None:
            pulumi.set(__self__, "match_type", match_type)
        if repository_id is not None:
            pulumi.set(__self__, "repository_id", repository_id)
        if repository_ref is not None:
            pulumi.set(__self__, "repository_ref", repository_ref)

    @_builtins.property
    @pulumi.getter(name="matchType")
    def match_type(self) -> Optional[_builtins.str]:
        """
        The match type to use when applying the policy. Supported values are `Exact` (default), `Prefix` or `DefaultBranch`.
        """
        return pulumi.get(self, "match_type")

    @_builtins.property
    @pulumi.getter(name="repositoryId")
    def repository_id(self) -> Optional[_builtins.str]:
        """
        The repository ID. Needed only if the scope of the policy will be limited to a single repository. If `match_type` is `DefaultBranch`, this should not be defined.
        """
        return pulumi.get(self, "repository_id")

    @_builtins.property
    @pulumi.getter(name="repositoryRef")
    def repository_ref(self) -> Optional[_builtins.str]:
        """
        The ref pattern to use for the match when `match_type` other than `DefaultBranch`. If `match_type` is `Exact`, this should be a qualified ref such as `refs/heads/master`. If `match_type` is `Prefix`, this should be a ref path such as `refs/heads/releases`.
        """
        return pulumi.get(self, "repository_ref")


@pulumi.output_type
class BranchPolicyBuildValidationSettings(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "buildDefinitionId":
            suggest = "build_definition_id"
        elif key == "displayName":
            suggest = "display_name"
        elif key == "filenamePatterns":
            suggest = "filename_patterns"
        elif key == "manualQueueOnly":
            suggest = "manual_queue_only"
        elif key == "queueOnSourceUpdateOnly":
            suggest = "queue_on_source_update_only"
        elif key == "validDuration":
            suggest = "valid_duration"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in BranchPolicyBuildValidationSettings. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        BranchPolicyBuildValidationSettings.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        BranchPolicyBuildValidationSettings.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 build_definition_id: _builtins.int,
                 display_name: _builtins.str,
                 scopes: Sequence['outputs.BranchPolicyBuildValidationSettingsScope'],
                 filename_patterns: Optional[Sequence[_builtins.str]] = None,
                 manual_queue_only: Optional[_builtins.bool] = None,
                 queue_on_source_update_only: Optional[_builtins.bool] = None,
                 valid_duration: Optional[_builtins.int] = None):
        """
        :param _builtins.int build_definition_id: The ID of the build to monitor for the policy.
        :param _builtins.str display_name: The display name for the policy.
        :param Sequence['BranchPolicyBuildValidationSettingsScopeArgs'] scopes: A `scope` block as defined below. Controls which repositories and branches the policy will be enabled for. This block must be defined at least once.
        :param Sequence[_builtins.str] filename_patterns: If a path filter is set, the policy will only apply when files which match the filter are changes. Not setting this field means that the policy will always apply. You can specify absolute paths and wildcards. Example: `["/WebApp/Models/Data.cs", "/WebApp/*", "*.cs"]`. Paths prefixed with "!" are excluded. Example: `["/WebApp/*", "!/WebApp/Tests/*"]`. Order is significant.
        :param _builtins.bool manual_queue_only: If set to true, the build will need to be manually queued. Defaults to `false`
        :param _builtins.bool queue_on_source_update_only: True if the build should queue on source updates only. Defaults to `true`.
        :param _builtins.int valid_duration: The number of minutes for which the build is valid. If `0`, the build will not expire. Defaults to `720` (12 hours).
               
               > **Note** Combine `valid_duration` and `queue_on_source_update_only` to set the build expiration.
               1.  Expire immediately when branch is updated: `valid_duration=0` and `queue_on_source_update_only=false`
               2.  Expire after a period of time : `valid_duration=360` and `queue_on_source_update_only=true`
               3.  Never expire: `valid_duration=0` and `queue_on_source_update_only=true`
        """
        pulumi.set(__self__, "build_definition_id", build_definition_id)
        pulumi.set(__self__, "display_name", display_name)
        pulumi.set(__self__, "scopes", scopes)
        if filename_patterns is not None:
            pulumi.set(__self__, "filename_patterns", filename_patterns)
        if manual_queue_only is not None:
            pulumi.set(__self__, "manual_queue_only", manual_queue_only)
        if queue_on_source_update_only is not None:
            pulumi.set(__self__, "queue_on_source_update_only", queue_on_source_update_only)
        if valid_duration is not None:
            pulumi.set(__self__, "valid_duration", valid_duration)

    @_builtins.property
    @pulumi.getter(name="buildDefinitionId")
    def build_definition_id(self) -> _builtins.int:
        """
        The ID of the build to monitor for the policy.
        """
        return pulumi.get(self, "build_definition_id")

    @_builtins.property
    @pulumi.getter(name="displayName")
    def display_name(self) -> _builtins.str:
        """
        The display name for the policy.
        """
        return pulumi.get(self, "display_name")

    @_builtins.property
    @pulumi.getter
    def scopes(self) -> Sequence['outputs.BranchPolicyBuildValidationSettingsScope']:
        """
        A `scope` block as defined below. Controls which repositories and branches the policy will be enabled for. This block must be defined at least once.
        """
        return pulumi.get(self, "scopes")

    @_builtins.property
    @pulumi.getter(name="filenamePatterns")
    def filename_patterns(self) -> Optional[Sequence[_builtins.str]]:
        """
        If a path filter is set, the policy will only apply when files which match the filter are changes. Not setting this field means that the policy will always apply. You can specify absolute paths and wildcards. Example: `["/WebApp/Models/Data.cs", "/WebApp/*", "*.cs"]`. Paths prefixed with "!" are excluded. Example: `["/WebApp/*", "!/WebApp/Tests/*"]`. Order is significant.
        """
        return pulumi.get(self, "filename_patterns")

    @_builtins.property
    @pulumi.getter(name="manualQueueOnly")
    def manual_queue_only(self) -> Optional[_builtins.bool]:
        """
        If set to true, the build will need to be manually queued. Defaults to `false`
        """
        return pulumi.get(self, "manual_queue_only")

    @_builtins.property
    @pulumi.getter(name="queueOnSourceUpdateOnly")
    def queue_on_source_update_only(self) -> Optional[_builtins.bool]:
        """
        True if the build should queue on source updates only. Defaults to `true`.
        """
        return pulumi.get(self, "queue_on_source_update_only")

    @_builtins.property
    @pulumi.getter(name="validDuration")
    def valid_duration(self) -> Optional[_builtins.int]:
        """
        The number of minutes for which the build is valid. If `0`, the build will not expire. Defaults to `720` (12 hours).

        > **Note** Combine `valid_duration` and `queue_on_source_update_only` to set the build expiration.
        1.  Expire immediately when branch is updated: `valid_duration=0` and `queue_on_source_update_only=false`
        2.  Expire after a period of time : `valid_duration=360` and `queue_on_source_update_only=true`
        3.  Never expire: `valid_duration=0` and `queue_on_source_update_only=true`
        """
        return pulumi.get(self, "valid_duration")


@pulumi.output_type
class BranchPolicyBuildValidationSettingsScope(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "matchType":
            suggest = "match_type"
        elif key == "repositoryId":
            suggest = "repository_id"
        elif key == "repositoryRef":
            suggest = "repository_ref"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in BranchPolicyBuildValidationSettingsScope. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        BranchPolicyBuildValidationSettingsScope.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        BranchPolicyBuildValidationSettingsScope.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 match_type: Optional[_builtins.str] = None,
                 repository_id: Optional[_builtins.str] = None,
                 repository_ref: Optional[_builtins.str] = None):
        """
        :param _builtins.str match_type: The match type to use when applying the policy. Supported values are `Exact` (default), `Prefix` or `DefaultBranch`.
        :param _builtins.str repository_id: The repository ID. Needed only if the scope of the policy will be limited to a single repository. If `match_type` is `DefaultBranch`, this should not be defined.
        :param _builtins.str repository_ref: The ref pattern to use for the match when `match_type` other than `DefaultBranch`. If `match_type` is `Exact`, this should be a qualified ref such as `refs/heads/master`. If `match_type` is `Prefix`, this should be a ref path such as `refs/heads/releases`.
        """
        if match_type is not None:
            pulumi.set(__self__, "match_type", match_type)
        if repository_id is not None:
            pulumi.set(__self__, "repository_id", repository_id)
        if repository_ref is not None:
            pulumi.set(__self__, "repository_ref", repository_ref)

    @_builtins.property
    @pulumi.getter(name="matchType")
    def match_type(self) -> Optional[_builtins.str]:
        """
        The match type to use when applying the policy. Supported values are `Exact` (default), `Prefix` or `DefaultBranch`.
        """
        return pulumi.get(self, "match_type")

    @_builtins.property
    @pulumi.getter(name="repositoryId")
    def repository_id(self) -> Optional[_builtins.str]:
        """
        The repository ID. Needed only if the scope of the policy will be limited to a single repository. If `match_type` is `DefaultBranch`, this should not be defined.
        """
        return pulumi.get(self, "repository_id")

    @_builtins.property
    @pulumi.getter(name="repositoryRef")
    def repository_ref(self) -> Optional[_builtins.str]:
        """
        The ref pattern to use for the match when `match_type` other than `DefaultBranch`. If `match_type` is `Exact`, this should be a qualified ref such as `refs/heads/master`. If `match_type` is `Prefix`, this should be a ref path such as `refs/heads/releases`.
        """
        return pulumi.get(self, "repository_ref")


@pulumi.output_type
class BranchPolicyCommentResolutionSettings(dict):
    def __init__(__self__, *,
                 scopes: Sequence['outputs.BranchPolicyCommentResolutionSettingsScope']):
        """
        :param Sequence['BranchPolicyCommentResolutionSettingsScopeArgs'] scopes: A `scope` block as defined below. Controls which repositories and branches the policy will be enabled for. This block must be defined at least once.
        """
        pulumi.set(__self__, "scopes", scopes)

    @_builtins.property
    @pulumi.getter
    def scopes(self) -> Sequence['outputs.BranchPolicyCommentResolutionSettingsScope']:
        """
        A `scope` block as defined below. Controls which repositories and branches the policy will be enabled for. This block must be defined at least once.
        """
        return pulumi.get(self, "scopes")


@pulumi.output_type
class BranchPolicyCommentResolutionSettingsScope(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "matchType":
            suggest = "match_type"
        elif key == "repositoryId":
            suggest = "repository_id"
        elif key == "repositoryRef":
            suggest = "repository_ref"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in BranchPolicyCommentResolutionSettingsScope. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        BranchPolicyCommentResolutionSettingsScope.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        BranchPolicyCommentResolutionSettingsScope.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 match_type: Optional[_builtins.str] = None,
                 repository_id: Optional[_builtins.str] = None,
                 repository_ref: Optional[_builtins.str] = None):
        """
        :param _builtins.str match_type: The match type to use when applying the policy. Supported values are `Exact` (default), `Prefix` or `DefaultBranch`.
        :param _builtins.str repository_id: The repository ID. Needed only if the scope of the policy will be limited to a single repository. If `match_type` is `DefaultBranch`, this should not be defined.
        :param _builtins.str repository_ref: The ref pattern to use for the match when `match_type` other than `DefaultBranch`. If `match_type` is `Exact`, this should be a qualified ref such as `refs/heads/master`. If `match_type` is `Prefix`, this should be a ref path such as `refs/heads/releases`.
        """
        if match_type is not None:
            pulumi.set(__self__, "match_type", match_type)
        if repository_id is not None:
            pulumi.set(__self__, "repository_id", repository_id)
        if repository_ref is not None:
            pulumi.set(__self__, "repository_ref", repository_ref)

    @_builtins.property
    @pulumi.getter(name="matchType")
    def match_type(self) -> Optional[_builtins.str]:
        """
        The match type to use when applying the policy. Supported values are `Exact` (default), `Prefix` or `DefaultBranch`.
        """
        return pulumi.get(self, "match_type")

    @_builtins.property
    @pulumi.getter(name="repositoryId")
    def repository_id(self) -> Optional[_builtins.str]:
        """
        The repository ID. Needed only if the scope of the policy will be limited to a single repository. If `match_type` is `DefaultBranch`, this should not be defined.
        """
        return pulumi.get(self, "repository_id")

    @_builtins.property
    @pulumi.getter(name="repositoryRef")
    def repository_ref(self) -> Optional[_builtins.str]:
        """
        The ref pattern to use for the match when `match_type` other than `DefaultBranch`. If `match_type` is `Exact`, this should be a qualified ref such as `refs/heads/master`. If `match_type` is `Prefix`, this should be a ref path such as `refs/heads/releases`.
        """
        return pulumi.get(self, "repository_ref")


@pulumi.output_type
class BranchPolicyMergeTypesSettings(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "allowBasicNoFastForward":
            suggest = "allow_basic_no_fast_forward"
        elif key == "allowRebaseAndFastForward":
            suggest = "allow_rebase_and_fast_forward"
        elif key == "allowRebaseWithMerge":
            suggest = "allow_rebase_with_merge"
        elif key == "allowSquash":
            suggest = "allow_squash"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in BranchPolicyMergeTypesSettings. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        BranchPolicyMergeTypesSettings.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        BranchPolicyMergeTypesSettings.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 scopes: Sequence['outputs.BranchPolicyMergeTypesSettingsScope'],
                 allow_basic_no_fast_forward: Optional[_builtins.bool] = None,
                 allow_rebase_and_fast_forward: Optional[_builtins.bool] = None,
                 allow_rebase_with_merge: Optional[_builtins.bool] = None,
                 allow_squash: Optional[_builtins.bool] = None):
        """
        :param Sequence['BranchPolicyMergeTypesSettingsScopeArgs'] scopes: A `scope` block as defined below. Controls which repositories and branches the policy will be enabled for. This block must be defined at least once.
        :param _builtins.bool allow_basic_no_fast_forward: Allow basic merge with no fast forward. Defaults to `false`.
        :param _builtins.bool allow_rebase_and_fast_forward: Allow rebase with fast forward. Defaults to `false`.
        :param _builtins.bool allow_rebase_with_merge: Allow rebase with merge commit. Defaults to `false`.
        :param _builtins.bool allow_squash: Allow squash merge. Defaults to `false`
        """
        pulumi.set(__self__, "scopes", scopes)
        if allow_basic_no_fast_forward is not None:
            pulumi.set(__self__, "allow_basic_no_fast_forward", allow_basic_no_fast_forward)
        if allow_rebase_and_fast_forward is not None:
            pulumi.set(__self__, "allow_rebase_and_fast_forward", allow_rebase_and_fast_forward)
        if allow_rebase_with_merge is not None:
            pulumi.set(__self__, "allow_rebase_with_merge", allow_rebase_with_merge)
        if allow_squash is not None:
            pulumi.set(__self__, "allow_squash", allow_squash)

    @_builtins.property
    @pulumi.getter
    def scopes(self) -> Sequence['outputs.BranchPolicyMergeTypesSettingsScope']:
        """
        A `scope` block as defined below. Controls which repositories and branches the policy will be enabled for. This block must be defined at least once.
        """
        return pulumi.get(self, "scopes")

    @_builtins.property
    @pulumi.getter(name="allowBasicNoFastForward")
    def allow_basic_no_fast_forward(self) -> Optional[_builtins.bool]:
        """
        Allow basic merge with no fast forward. Defaults to `false`.
        """
        return pulumi.get(self, "allow_basic_no_fast_forward")

    @_builtins.property
    @pulumi.getter(name="allowRebaseAndFastForward")
    def allow_rebase_and_fast_forward(self) -> Optional[_builtins.bool]:
        """
        Allow rebase with fast forward. Defaults to `false`.
        """
        return pulumi.get(self, "allow_rebase_and_fast_forward")

    @_builtins.property
    @pulumi.getter(name="allowRebaseWithMerge")
    def allow_rebase_with_merge(self) -> Optional[_builtins.bool]:
        """
        Allow rebase with merge commit. Defaults to `false`.
        """
        return pulumi.get(self, "allow_rebase_with_merge")

    @_builtins.property
    @pulumi.getter(name="allowSquash")
    def allow_squash(self) -> Optional[_builtins.bool]:
        """
        Allow squash merge. Defaults to `false`
        """
        return pulumi.get(self, "allow_squash")


@pulumi.output_type
class BranchPolicyMergeTypesSettingsScope(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "matchType":
            suggest = "match_type"
        elif key == "repositoryId":
            suggest = "repository_id"
        elif key == "repositoryRef":
            suggest = "repository_ref"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in BranchPolicyMergeTypesSettingsScope. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        BranchPolicyMergeTypesSettingsScope.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        BranchPolicyMergeTypesSettingsScope.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 match_type: Optional[_builtins.str] = None,
                 repository_id: Optional[_builtins.str] = None,
                 repository_ref: Optional[_builtins.str] = None):
        """
        :param _builtins.str match_type: The match type to use when applying the policy. Supported values are `Exact` (default), `Prefix` or `DefaultBranch`.
        :param _builtins.str repository_id: The repository ID. Needed only if the scope of the policy will be limited to a single repository. If `match_type` is `DefaultBranch`, this should not be defined.
        :param _builtins.str repository_ref: The ref pattern to use for the match when `match_type` other than `DefaultBranch`. If `match_type` is `Exact`, this should be a qualified ref such as `refs/heads/master`. If `match_type` is `Prefix`, this should be a ref path such as `refs/heads/releases`.
        """
        if match_type is not None:
            pulumi.set(__self__, "match_type", match_type)
        if repository_id is not None:
            pulumi.set(__self__, "repository_id", repository_id)
        if repository_ref is not None:
            pulumi.set(__self__, "repository_ref", repository_ref)

    @_builtins.property
    @pulumi.getter(name="matchType")
    def match_type(self) -> Optional[_builtins.str]:
        """
        The match type to use when applying the policy. Supported values are `Exact` (default), `Prefix` or `DefaultBranch`.
        """
        return pulumi.get(self, "match_type")

    @_builtins.property
    @pulumi.getter(name="repositoryId")
    def repository_id(self) -> Optional[_builtins.str]:
        """
        The repository ID. Needed only if the scope of the policy will be limited to a single repository. If `match_type` is `DefaultBranch`, this should not be defined.
        """
        return pulumi.get(self, "repository_id")

    @_builtins.property
    @pulumi.getter(name="repositoryRef")
    def repository_ref(self) -> Optional[_builtins.str]:
        """
        The ref pattern to use for the match when `match_type` other than `DefaultBranch`. If `match_type` is `Exact`, this should be a qualified ref such as `refs/heads/master`. If `match_type` is `Prefix`, this should be a ref path such as `refs/heads/releases`.
        """
        return pulumi.get(self, "repository_ref")


@pulumi.output_type
class BranchPolicyMinReviewersSettings(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "allowCompletionWithRejectsOrWaits":
            suggest = "allow_completion_with_rejects_or_waits"
        elif key == "lastPusherCannotApprove":
            suggest = "last_pusher_cannot_approve"
        elif key == "onLastIterationRequireVote":
            suggest = "on_last_iteration_require_vote"
        elif key == "onPushResetAllVotes":
            suggest = "on_push_reset_all_votes"
        elif key == "onPushResetApprovedVotes":
            suggest = "on_push_reset_approved_votes"
        elif key == "reviewerCount":
            suggest = "reviewer_count"
        elif key == "submitterCanVote":
            suggest = "submitter_can_vote"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in BranchPolicyMinReviewersSettings. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        BranchPolicyMinReviewersSettings.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        BranchPolicyMinReviewersSettings.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 scopes: Sequence['outputs.BranchPolicyMinReviewersSettingsScope'],
                 allow_completion_with_rejects_or_waits: Optional[_builtins.bool] = None,
                 last_pusher_cannot_approve: Optional[_builtins.bool] = None,
                 on_last_iteration_require_vote: Optional[_builtins.bool] = None,
                 on_push_reset_all_votes: Optional[_builtins.bool] = None,
                 on_push_reset_approved_votes: Optional[_builtins.bool] = None,
                 reviewer_count: Optional[_builtins.int] = None,
                 submitter_can_vote: Optional[_builtins.bool] = None):
        """
        :param Sequence['BranchPolicyMinReviewersSettingsScopeArgs'] scopes: A `scope` block as defined below. Controls which repositories and branches the policy will be enabled for. This block must be defined at least once.
        :param _builtins.bool allow_completion_with_rejects_or_waits: Allow completion even if some reviewers vote to wait or reject. Defaults to `false`.
        :param _builtins.bool last_pusher_cannot_approve: Prohibit the most recent pusher from approving their own changes. Defaults to `false`.
        :param _builtins.bool on_last_iteration_require_vote: On last iteration require vote. Defaults to `false`.
        :param _builtins.bool on_push_reset_all_votes: When new changes are pushed reset all code reviewer votes. Defaults to `false`.
               
               > **Note:** If `on_push_reset_all_votes` is `true` then `on_push_reset_approved_votes` will be set to `true`. To enable `on_push_reset_approved_votes`, you need explicitly set `on_push_reset_all_votes` `false` or not configure.
        :param _builtins.bool on_push_reset_approved_votes: When new changes are pushed reset all approval votes (does not reset votes to reject or wait). Defaults to `false`.
        :param _builtins.int reviewer_count: The number of reviewers needed to approve.
        :param _builtins.bool submitter_can_vote: Allow requesters to approve their own changes. Defaults to `false`.
        """
        pulumi.set(__self__, "scopes", scopes)
        if allow_completion_with_rejects_or_waits is not None:
            pulumi.set(__self__, "allow_completion_with_rejects_or_waits", allow_completion_with_rejects_or_waits)
        if last_pusher_cannot_approve is not None:
            pulumi.set(__self__, "last_pusher_cannot_approve", last_pusher_cannot_approve)
        if on_last_iteration_require_vote is not None:
            pulumi.set(__self__, "on_last_iteration_require_vote", on_last_iteration_require_vote)
        if on_push_reset_all_votes is not None:
            pulumi.set(__self__, "on_push_reset_all_votes", on_push_reset_all_votes)
        if on_push_reset_approved_votes is not None:
            pulumi.set(__self__, "on_push_reset_approved_votes", on_push_reset_approved_votes)
        if reviewer_count is not None:
            pulumi.set(__self__, "reviewer_count", reviewer_count)
        if submitter_can_vote is not None:
            pulumi.set(__self__, "submitter_can_vote", submitter_can_vote)

    @_builtins.property
    @pulumi.getter
    def scopes(self) -> Sequence['outputs.BranchPolicyMinReviewersSettingsScope']:
        """
        A `scope` block as defined below. Controls which repositories and branches the policy will be enabled for. This block must be defined at least once.
        """
        return pulumi.get(self, "scopes")

    @_builtins.property
    @pulumi.getter(name="allowCompletionWithRejectsOrWaits")
    def allow_completion_with_rejects_or_waits(self) -> Optional[_builtins.bool]:
        """
        Allow completion even if some reviewers vote to wait or reject. Defaults to `false`.
        """
        return pulumi.get(self, "allow_completion_with_rejects_or_waits")

    @_builtins.property
    @pulumi.getter(name="lastPusherCannotApprove")
    def last_pusher_cannot_approve(self) -> Optional[_builtins.bool]:
        """
        Prohibit the most recent pusher from approving their own changes. Defaults to `false`.
        """
        return pulumi.get(self, "last_pusher_cannot_approve")

    @_builtins.property
    @pulumi.getter(name="onLastIterationRequireVote")
    def on_last_iteration_require_vote(self) -> Optional[_builtins.bool]:
        """
        On last iteration require vote. Defaults to `false`.
        """
        return pulumi.get(self, "on_last_iteration_require_vote")

    @_builtins.property
    @pulumi.getter(name="onPushResetAllVotes")
    def on_push_reset_all_votes(self) -> Optional[_builtins.bool]:
        """
        When new changes are pushed reset all code reviewer votes. Defaults to `false`.

        > **Note:** If `on_push_reset_all_votes` is `true` then `on_push_reset_approved_votes` will be set to `true`. To enable `on_push_reset_approved_votes`, you need explicitly set `on_push_reset_all_votes` `false` or not configure.
        """
        return pulumi.get(self, "on_push_reset_all_votes")

    @_builtins.property
    @pulumi.getter(name="onPushResetApprovedVotes")
    def on_push_reset_approved_votes(self) -> Optional[_builtins.bool]:
        """
        When new changes are pushed reset all approval votes (does not reset votes to reject or wait). Defaults to `false`.
        """
        return pulumi.get(self, "on_push_reset_approved_votes")

    @_builtins.property
    @pulumi.getter(name="reviewerCount")
    def reviewer_count(self) -> Optional[_builtins.int]:
        """
        The number of reviewers needed to approve.
        """
        return pulumi.get(self, "reviewer_count")

    @_builtins.property
    @pulumi.getter(name="submitterCanVote")
    def submitter_can_vote(self) -> Optional[_builtins.bool]:
        """
        Allow requesters to approve their own changes. Defaults to `false`.
        """
        return pulumi.get(self, "submitter_can_vote")


@pulumi.output_type
class BranchPolicyMinReviewersSettingsScope(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "matchType":
            suggest = "match_type"
        elif key == "repositoryId":
            suggest = "repository_id"
        elif key == "repositoryRef":
            suggest = "repository_ref"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in BranchPolicyMinReviewersSettingsScope. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        BranchPolicyMinReviewersSettingsScope.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        BranchPolicyMinReviewersSettingsScope.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 match_type: Optional[_builtins.str] = None,
                 repository_id: Optional[_builtins.str] = None,
                 repository_ref: Optional[_builtins.str] = None):
        """
        :param _builtins.str match_type: The match type to use when applying the policy. Supported values are `Exact` (default), `Prefix` or `DefaultBranch`.
        :param _builtins.str repository_id: The repository ID. Needed only if the scope of the policy will be limited to a single repository. If `match_type` is `DefaultBranch`, this should not be defined.
        :param _builtins.str repository_ref: The ref pattern to use for the match when `match_type` other than `DefaultBranch`. If `match_type` is `Exact`, this should be a qualified ref such as `refs/heads/master`. If `match_type` is `Prefix`, this should be a ref path such as `refs/heads/releases`.
        """
        if match_type is not None:
            pulumi.set(__self__, "match_type", match_type)
        if repository_id is not None:
            pulumi.set(__self__, "repository_id", repository_id)
        if repository_ref is not None:
            pulumi.set(__self__, "repository_ref", repository_ref)

    @_builtins.property
    @pulumi.getter(name="matchType")
    def match_type(self) -> Optional[_builtins.str]:
        """
        The match type to use when applying the policy. Supported values are `Exact` (default), `Prefix` or `DefaultBranch`.
        """
        return pulumi.get(self, "match_type")

    @_builtins.property
    @pulumi.getter(name="repositoryId")
    def repository_id(self) -> Optional[_builtins.str]:
        """
        The repository ID. Needed only if the scope of the policy will be limited to a single repository. If `match_type` is `DefaultBranch`, this should not be defined.
        """
        return pulumi.get(self, "repository_id")

    @_builtins.property
    @pulumi.getter(name="repositoryRef")
    def repository_ref(self) -> Optional[_builtins.str]:
        """
        The ref pattern to use for the match when `match_type` other than `DefaultBranch`. If `match_type` is `Exact`, this should be a qualified ref such as `refs/heads/master`. If `match_type` is `Prefix`, this should be a ref path such as `refs/heads/releases`.
        """
        return pulumi.get(self, "repository_ref")


@pulumi.output_type
class BranchPolicyStatusCheckSettings(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "authorId":
            suggest = "author_id"
        elif key == "displayName":
            suggest = "display_name"
        elif key == "filenamePatterns":
            suggest = "filename_patterns"
        elif key == "invalidateOnUpdate":
            suggest = "invalidate_on_update"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in BranchPolicyStatusCheckSettings. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        BranchPolicyStatusCheckSettings.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        BranchPolicyStatusCheckSettings.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 name: _builtins.str,
                 scopes: Sequence['outputs.BranchPolicyStatusCheckSettingsScope'],
                 applicability: Optional[_builtins.str] = None,
                 author_id: Optional[_builtins.str] = None,
                 display_name: Optional[_builtins.str] = None,
                 filename_patterns: Optional[Sequence[_builtins.str]] = None,
                 genre: Optional[_builtins.str] = None,
                 invalidate_on_update: Optional[_builtins.bool] = None):
        """
        :param _builtins.str name: The status name to check.
        :param Sequence['BranchPolicyStatusCheckSettingsScopeArgs'] scopes: A `scope` block as defined below.
        :param _builtins.str applicability: Policy applicability. If policy `applicability=default`, apply unless "Not Applicable"
               status is posted to the pull request. If policy `applicability=conditional`, policy is applied only after a status
               is posted to the pull request. Possible values `default`, `conditional`. Defaults to `default`.
        :param _builtins.str author_id: The authorized user can post the status.
        :param _builtins.str display_name: The display name.
        :param Sequence[_builtins.str] filename_patterns: If a path filter is set, the policy will only apply when files which match the filter are changed. Not setting this field means that the policy is always applied.
               
               ~>**NOTE** 1. Specify absolute paths and wildcards. Example: `["/WebApp/Models/Data.cs", "/WebApp/*", "*.cs"]`.
               <br> 2. Paths prefixed with "!" are excluded. Example: `["/WebApp/*", "!/WebApp/Tests/*"]`. Order is significant.
        :param _builtins.str genre: The genre of the status to check (see [Microsoft Documentation](https://docs.microsoft.com/en-us/azure/devops/repos/git/pull-request-status?view=azure-devops#status-policy))
        :param _builtins.bool invalidate_on_update: Reset status whenever there are new changes.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "scopes", scopes)
        if applicability is not None:
            pulumi.set(__self__, "applicability", applicability)
        if author_id is not None:
            pulumi.set(__self__, "author_id", author_id)
        if display_name is not None:
            pulumi.set(__self__, "display_name", display_name)
        if filename_patterns is not None:
            pulumi.set(__self__, "filename_patterns", filename_patterns)
        if genre is not None:
            pulumi.set(__self__, "genre", genre)
        if invalidate_on_update is not None:
            pulumi.set(__self__, "invalidate_on_update", invalidate_on_update)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        The status name to check.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def scopes(self) -> Sequence['outputs.BranchPolicyStatusCheckSettingsScope']:
        """
        A `scope` block as defined below.
        """
        return pulumi.get(self, "scopes")

    @_builtins.property
    @pulumi.getter
    def applicability(self) -> Optional[_builtins.str]:
        """
        Policy applicability. If policy `applicability=default`, apply unless "Not Applicable"
        status is posted to the pull request. If policy `applicability=conditional`, policy is applied only after a status
        is posted to the pull request. Possible values `default`, `conditional`. Defaults to `default`.
        """
        return pulumi.get(self, "applicability")

    @_builtins.property
    @pulumi.getter(name="authorId")
    def author_id(self) -> Optional[_builtins.str]:
        """
        The authorized user can post the status.
        """
        return pulumi.get(self, "author_id")

    @_builtins.property
    @pulumi.getter(name="displayName")
    def display_name(self) -> Optional[_builtins.str]:
        """
        The display name.
        """
        return pulumi.get(self, "display_name")

    @_builtins.property
    @pulumi.getter(name="filenamePatterns")
    def filename_patterns(self) -> Optional[Sequence[_builtins.str]]:
        """
        If a path filter is set, the policy will only apply when files which match the filter are changed. Not setting this field means that the policy is always applied.

        ~>**NOTE** 1. Specify absolute paths and wildcards. Example: `["/WebApp/Models/Data.cs", "/WebApp/*", "*.cs"]`.
        <br> 2. Paths prefixed with "!" are excluded. Example: `["/WebApp/*", "!/WebApp/Tests/*"]`. Order is significant.
        """
        return pulumi.get(self, "filename_patterns")

    @_builtins.property
    @pulumi.getter
    def genre(self) -> Optional[_builtins.str]:
        """
        The genre of the status to check (see [Microsoft Documentation](https://docs.microsoft.com/en-us/azure/devops/repos/git/pull-request-status?view=azure-devops#status-policy))
        """
        return pulumi.get(self, "genre")

    @_builtins.property
    @pulumi.getter(name="invalidateOnUpdate")
    def invalidate_on_update(self) -> Optional[_builtins.bool]:
        """
        Reset status whenever there are new changes.
        """
        return pulumi.get(self, "invalidate_on_update")


@pulumi.output_type
class BranchPolicyStatusCheckSettingsScope(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "matchType":
            suggest = "match_type"
        elif key == "repositoryId":
            suggest = "repository_id"
        elif key == "repositoryRef":
            suggest = "repository_ref"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in BranchPolicyStatusCheckSettingsScope. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        BranchPolicyStatusCheckSettingsScope.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        BranchPolicyStatusCheckSettingsScope.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 match_type: Optional[_builtins.str] = None,
                 repository_id: Optional[_builtins.str] = None,
                 repository_ref: Optional[_builtins.str] = None):
        """
        :param _builtins.str match_type: The match type to use when applying the policy. Supported values are `Exact` (default), `Prefix` or `DefaultBranch`.
        :param _builtins.str repository_id: The repository ID. Needed only if the scope of the policy will be limited to a single repository. If `match_type=DefaultBranch`, this should not be defined.
        :param _builtins.str repository_ref: The ref pattern to use for the match when `match_type` other than `DefaultBranch`. If `match_type=Exact`, this should be a qualified ref such as `refs/heads/master`. If `match_type=Prefix`, this should be a ref path such as `refs/heads/releases`.
        """
        if match_type is not None:
            pulumi.set(__self__, "match_type", match_type)
        if repository_id is not None:
            pulumi.set(__self__, "repository_id", repository_id)
        if repository_ref is not None:
            pulumi.set(__self__, "repository_ref", repository_ref)

    @_builtins.property
    @pulumi.getter(name="matchType")
    def match_type(self) -> Optional[_builtins.str]:
        """
        The match type to use when applying the policy. Supported values are `Exact` (default), `Prefix` or `DefaultBranch`.
        """
        return pulumi.get(self, "match_type")

    @_builtins.property
    @pulumi.getter(name="repositoryId")
    def repository_id(self) -> Optional[_builtins.str]:
        """
        The repository ID. Needed only if the scope of the policy will be limited to a single repository. If `match_type=DefaultBranch`, this should not be defined.
        """
        return pulumi.get(self, "repository_id")

    @_builtins.property
    @pulumi.getter(name="repositoryRef")
    def repository_ref(self) -> Optional[_builtins.str]:
        """
        The ref pattern to use for the match when `match_type` other than `DefaultBranch`. If `match_type=Exact`, this should be a qualified ref such as `refs/heads/master`. If `match_type=Prefix`, this should be a ref path such as `refs/heads/releases`.
        """
        return pulumi.get(self, "repository_ref")


@pulumi.output_type
class BranchPolicyWorkItemLinkingSettings(dict):
    def __init__(__self__, *,
                 scopes: Sequence['outputs.BranchPolicyWorkItemLinkingSettingsScope']):
        """
        :param Sequence['BranchPolicyWorkItemLinkingSettingsScopeArgs'] scopes: A `scope` block as defined below. Controls which repositories and branches the policy will be enabled for. This block must be defined at least once.
        """
        pulumi.set(__self__, "scopes", scopes)

    @_builtins.property
    @pulumi.getter
    def scopes(self) -> Sequence['outputs.BranchPolicyWorkItemLinkingSettingsScope']:
        """
        A `scope` block as defined below. Controls which repositories and branches the policy will be enabled for. This block must be defined at least once.
        """
        return pulumi.get(self, "scopes")


@pulumi.output_type
class BranchPolicyWorkItemLinkingSettingsScope(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "matchType":
            suggest = "match_type"
        elif key == "repositoryId":
            suggest = "repository_id"
        elif key == "repositoryRef":
            suggest = "repository_ref"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in BranchPolicyWorkItemLinkingSettingsScope. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        BranchPolicyWorkItemLinkingSettingsScope.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        BranchPolicyWorkItemLinkingSettingsScope.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 match_type: Optional[_builtins.str] = None,
                 repository_id: Optional[_builtins.str] = None,
                 repository_ref: Optional[_builtins.str] = None):
        """
        :param _builtins.str match_type: The match type to use when applying the policy. Supported values are `Exact` (default), `Prefix` or `DefaultBranch`.
        :param _builtins.str repository_id: The repository ID. Needed only if the scope of the policy will be limited to a single repository. If `match_type` is `DefaultBranch`, this should not be defined.
        :param _builtins.str repository_ref: The ref pattern to use for the match when `match_type` other than `DefaultBranch`. If `match_type` is `Exact`, this should be a qualified ref such as `refs/heads/master`. If `match_type` is `Prefix`, this should be a ref path such as `refs/heads/releases`.
        """
        if match_type is not None:
            pulumi.set(__self__, "match_type", match_type)
        if repository_id is not None:
            pulumi.set(__self__, "repository_id", repository_id)
        if repository_ref is not None:
            pulumi.set(__self__, "repository_ref", repository_ref)

    @_builtins.property
    @pulumi.getter(name="matchType")
    def match_type(self) -> Optional[_builtins.str]:
        """
        The match type to use when applying the policy. Supported values are `Exact` (default), `Prefix` or `DefaultBranch`.
        """
        return pulumi.get(self, "match_type")

    @_builtins.property
    @pulumi.getter(name="repositoryId")
    def repository_id(self) -> Optional[_builtins.str]:
        """
        The repository ID. Needed only if the scope of the policy will be limited to a single repository. If `match_type` is `DefaultBranch`, this should not be defined.
        """
        return pulumi.get(self, "repository_id")

    @_builtins.property
    @pulumi.getter(name="repositoryRef")
    def repository_ref(self) -> Optional[_builtins.str]:
        """
        The ref pattern to use for the match when `match_type` other than `DefaultBranch`. If `match_type` is `Exact`, this should be a qualified ref such as `refs/heads/master`. If `match_type` is `Prefix`, this should be a ref path such as `refs/heads/releases`.
        """
        return pulumi.get(self, "repository_ref")


@pulumi.output_type
class BuildDefinitionBuildCompletionTrigger(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "branchFilters":
            suggest = "branch_filters"
        elif key == "buildDefinitionId":
            suggest = "build_definition_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in BuildDefinitionBuildCompletionTrigger. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        BuildDefinitionBuildCompletionTrigger.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        BuildDefinitionBuildCompletionTrigger.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 branch_filters: Sequence['outputs.BuildDefinitionBuildCompletionTriggerBranchFilter'],
                 build_definition_id: _builtins.int):
        """
        :param Sequence['BuildDefinitionBuildCompletionTriggerBranchFilterArgs'] branch_filters: The branches to include and exclude from the trigger. A `branch_filter` block as documented below.
        :param _builtins.int build_definition_id: The ID of the build pipeline will be triggered.
        """
        pulumi.set(__self__, "branch_filters", branch_filters)
        pulumi.set(__self__, "build_definition_id", build_definition_id)

    @_builtins.property
    @pulumi.getter(name="branchFilters")
    def branch_filters(self) -> Sequence['outputs.BuildDefinitionBuildCompletionTriggerBranchFilter']:
        """
        The branches to include and exclude from the trigger. A `branch_filter` block as documented below.
        """
        return pulumi.get(self, "branch_filters")

    @_builtins.property
    @pulumi.getter(name="buildDefinitionId")
    def build_definition_id(self) -> _builtins.int:
        """
        The ID of the build pipeline will be triggered.
        """
        return pulumi.get(self, "build_definition_id")


@pulumi.output_type
class BuildDefinitionBuildCompletionTriggerBranchFilter(dict):
    def __init__(__self__, *,
                 excludes: Optional[Sequence[_builtins.str]] = None,
                 includes: Optional[Sequence[_builtins.str]] = None):
        """
        :param Sequence[_builtins.str] excludes: List of branch patterns to exclude.
        :param Sequence[_builtins.str] includes: List of branch patterns to include.
        """
        if excludes is not None:
            pulumi.set(__self__, "excludes", excludes)
        if includes is not None:
            pulumi.set(__self__, "includes", includes)

    @_builtins.property
    @pulumi.getter
    def excludes(self) -> Optional[Sequence[_builtins.str]]:
        """
        List of branch patterns to exclude.
        """
        return pulumi.get(self, "excludes")

    @_builtins.property
    @pulumi.getter
    def includes(self) -> Optional[Sequence[_builtins.str]]:
        """
        List of branch patterns to include.
        """
        return pulumi.get(self, "includes")


@pulumi.output_type
class BuildDefinitionCiTrigger(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "useYaml":
            suggest = "use_yaml"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in BuildDefinitionCiTrigger. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        BuildDefinitionCiTrigger.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        BuildDefinitionCiTrigger.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 override: Optional['outputs.BuildDefinitionCiTriggerOverride'] = None,
                 use_yaml: Optional[_builtins.bool] = None):
        """
        :param 'BuildDefinitionCiTriggerOverrideArgs' override: Override the azure-pipeline file and use a this configuration for all builds.
        :param _builtins.bool use_yaml: Use the azure-pipeline file for the build configuration. Defaults to `false`.
        """
        if override is not None:
            pulumi.set(__self__, "override", override)
        if use_yaml is not None:
            pulumi.set(__self__, "use_yaml", use_yaml)

    @_builtins.property
    @pulumi.getter
    def override(self) -> Optional['outputs.BuildDefinitionCiTriggerOverride']:
        """
        Override the azure-pipeline file and use a this configuration for all builds.
        """
        return pulumi.get(self, "override")

    @_builtins.property
    @pulumi.getter(name="useYaml")
    def use_yaml(self) -> Optional[_builtins.bool]:
        """
        Use the azure-pipeline file for the build configuration. Defaults to `false`.
        """
        return pulumi.get(self, "use_yaml")


@pulumi.output_type
class BuildDefinitionCiTriggerOverride(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "branchFilters":
            suggest = "branch_filters"
        elif key == "maxConcurrentBuildsPerBranch":
            suggest = "max_concurrent_builds_per_branch"
        elif key == "pathFilters":
            suggest = "path_filters"
        elif key == "pollingInterval":
            suggest = "polling_interval"
        elif key == "pollingJobId":
            suggest = "polling_job_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in BuildDefinitionCiTriggerOverride. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        BuildDefinitionCiTriggerOverride.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        BuildDefinitionCiTriggerOverride.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 branch_filters: Sequence['outputs.BuildDefinitionCiTriggerOverrideBranchFilter'],
                 batch: Optional[_builtins.bool] = None,
                 max_concurrent_builds_per_branch: Optional[_builtins.int] = None,
                 path_filters: Optional[Sequence['outputs.BuildDefinitionCiTriggerOverridePathFilter']] = None,
                 polling_interval: Optional[_builtins.int] = None,
                 polling_job_id: Optional[_builtins.str] = None):
        """
        :param Sequence['BuildDefinitionCiTriggerOverrideBranchFilterArgs'] branch_filters: The branches to include and exclude from the trigger. A `branch_filter` block as documented below.
        :param _builtins.bool batch: If you set batch to true, when a pipeline is running, the system waits until the run is completed, then starts another run with all changes that have not yet been built. Defaults to `true`.
        :param _builtins.int max_concurrent_builds_per_branch: The number of max builds per branch. Defaults to `1`.
        :param Sequence['BuildDefinitionCiTriggerOverridePathFilterArgs'] path_filters: Specify file paths to include or exclude. Note that the wildcard syntax is different between branches/tags and file paths.
        :param _builtins.int polling_interval: How often the external repository is polled. Defaults to `0`.
        :param _builtins.str polling_job_id: This is the ID of the polling job that polls the external repository. Once the build definition is saved/updated, this value is set.
        """
        pulumi.set(__self__, "branch_filters", branch_filters)
        if batch is not None:
            pulumi.set(__self__, "batch", batch)
        if max_concurrent_builds_per_branch is not None:
            pulumi.set(__self__, "max_concurrent_builds_per_branch", max_concurrent_builds_per_branch)
        if path_filters is not None:
            pulumi.set(__self__, "path_filters", path_filters)
        if polling_interval is not None:
            pulumi.set(__self__, "polling_interval", polling_interval)
        if polling_job_id is not None:
            pulumi.set(__self__, "polling_job_id", polling_job_id)

    @_builtins.property
    @pulumi.getter(name="branchFilters")
    def branch_filters(self) -> Sequence['outputs.BuildDefinitionCiTriggerOverrideBranchFilter']:
        """
        The branches to include and exclude from the trigger. A `branch_filter` block as documented below.
        """
        return pulumi.get(self, "branch_filters")

    @_builtins.property
    @pulumi.getter
    def batch(self) -> Optional[_builtins.bool]:
        """
        If you set batch to true, when a pipeline is running, the system waits until the run is completed, then starts another run with all changes that have not yet been built. Defaults to `true`.
        """
        return pulumi.get(self, "batch")

    @_builtins.property
    @pulumi.getter(name="maxConcurrentBuildsPerBranch")
    def max_concurrent_builds_per_branch(self) -> Optional[_builtins.int]:
        """
        The number of max builds per branch. Defaults to `1`.
        """
        return pulumi.get(self, "max_concurrent_builds_per_branch")

    @_builtins.property
    @pulumi.getter(name="pathFilters")
    def path_filters(self) -> Optional[Sequence['outputs.BuildDefinitionCiTriggerOverridePathFilter']]:
        """
        Specify file paths to include or exclude. Note that the wildcard syntax is different between branches/tags and file paths.
        """
        return pulumi.get(self, "path_filters")

    @_builtins.property
    @pulumi.getter(name="pollingInterval")
    def polling_interval(self) -> Optional[_builtins.int]:
        """
        How often the external repository is polled. Defaults to `0`.
        """
        return pulumi.get(self, "polling_interval")

    @_builtins.property
    @pulumi.getter(name="pollingJobId")
    def polling_job_id(self) -> Optional[_builtins.str]:
        """
        This is the ID of the polling job that polls the external repository. Once the build definition is saved/updated, this value is set.
        """
        return pulumi.get(self, "polling_job_id")


@pulumi.output_type
class BuildDefinitionCiTriggerOverrideBranchFilter(dict):
    def __init__(__self__, *,
                 excludes: Optional[Sequence[_builtins.str]] = None,
                 includes: Optional[Sequence[_builtins.str]] = None):
        """
        :param Sequence[_builtins.str] excludes: List of branch patterns to exclude.
        :param Sequence[_builtins.str] includes: List of branch patterns to include.
        """
        if excludes is not None:
            pulumi.set(__self__, "excludes", excludes)
        if includes is not None:
            pulumi.set(__self__, "includes", includes)

    @_builtins.property
    @pulumi.getter
    def excludes(self) -> Optional[Sequence[_builtins.str]]:
        """
        List of branch patterns to exclude.
        """
        return pulumi.get(self, "excludes")

    @_builtins.property
    @pulumi.getter
    def includes(self) -> Optional[Sequence[_builtins.str]]:
        """
        List of branch patterns to include.
        """
        return pulumi.get(self, "includes")


@pulumi.output_type
class BuildDefinitionCiTriggerOverridePathFilter(dict):
    def __init__(__self__, *,
                 excludes: Optional[Sequence[_builtins.str]] = None,
                 includes: Optional[Sequence[_builtins.str]] = None):
        """
        :param Sequence[_builtins.str] excludes: List of path patterns to exclude.
        :param Sequence[_builtins.str] includes: List of path patterns to include.
        """
        if excludes is not None:
            pulumi.set(__self__, "excludes", excludes)
        if includes is not None:
            pulumi.set(__self__, "includes", includes)

    @_builtins.property
    @pulumi.getter
    def excludes(self) -> Optional[Sequence[_builtins.str]]:
        """
        List of path patterns to exclude.
        """
        return pulumi.get(self, "excludes")

    @_builtins.property
    @pulumi.getter
    def includes(self) -> Optional[Sequence[_builtins.str]]:
        """
        List of path patterns to include.
        """
        return pulumi.get(self, "includes")


@pulumi.output_type
class BuildDefinitionFeature(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "skipFirstRun":
            suggest = "skip_first_run"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in BuildDefinitionFeature. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        BuildDefinitionFeature.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        BuildDefinitionFeature.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 skip_first_run: Optional[_builtins.bool] = None):
        """
        :param _builtins.bool skip_first_run: Trigger the pipeline to run after the creation. Defaults to `true`.
               
               > **Note** The first run(`skip_first_run = false`) will only be triggered on create. If the first run fails, the build definition will still be marked as successfully created. A warning message indicating the inability to run pipeline will be displayed.
        """
        if skip_first_run is not None:
            pulumi.set(__self__, "skip_first_run", skip_first_run)

    @_builtins.property
    @pulumi.getter(name="skipFirstRun")
    def skip_first_run(self) -> Optional[_builtins.bool]:
        """
        Trigger the pipeline to run after the creation. Defaults to `true`.

        > **Note** The first run(`skip_first_run = false`) will only be triggered on create. If the first run fails, the build definition will still be marked as successfully created. A warning message indicating the inability to run pipeline will be displayed.
        """
        return pulumi.get(self, "skip_first_run")


@pulumi.output_type
class BuildDefinitionJob(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "refName":
            suggest = "ref_name"
        elif key == "allowScriptsAuthAccessOption":
            suggest = "allow_scripts_auth_access_option"
        elif key == "jobAuthorizationScope":
            suggest = "job_authorization_scope"
        elif key == "jobCancelTimeoutInMinutes":
            suggest = "job_cancel_timeout_in_minutes"
        elif key == "jobTimeoutInMinutes":
            suggest = "job_timeout_in_minutes"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in BuildDefinitionJob. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        BuildDefinitionJob.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        BuildDefinitionJob.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 condition: _builtins.str,
                 name: _builtins.str,
                 ref_name: _builtins.str,
                 target: 'outputs.BuildDefinitionJobTarget',
                 allow_scripts_auth_access_option: Optional[_builtins.bool] = None,
                 dependencies: Optional[Sequence['outputs.BuildDefinitionJobDependency']] = None,
                 job_authorization_scope: Optional[_builtins.str] = None,
                 job_cancel_timeout_in_minutes: Optional[_builtins.int] = None,
                 job_timeout_in_minutes: Optional[_builtins.int] = None):
        """
        :param _builtins.str condition: Specifies when this job should run. Can **Custom conditions** to specify more complex conditions. Possible values: `succeeded()`, `succeededOrFailed()`, `always()`, `failed()` etc. More details: [Pipeline conditions](https://learn.microsoft.com/en-us/azure/devops/pipelines/process/conditions?view=azure-devops)
        :param _builtins.str name: The name of the job.
        :param _builtins.str ref_name: The reference name of the job, can be used to define the job dependencies.
        :param 'BuildDefinitionJobTargetArgs' target: A `target` blocks as documented below.
        :param _builtins.bool allow_scripts_auth_access_option: Enables scripts and other processes launched by tasks to access the OAuth token through the `System.AccessToken` variable. Possible values: `true`, `false`. Defaults to `false`. Available when Job type is `AgentJob`
        :param Sequence['BuildDefinitionJobDependencyArgs'] dependencies: A `dependencies` blocks as documented below. Define the job dependencies.
        :param _builtins.str job_authorization_scope: The job authorization scope for builds queued against this definition. Possible values are: `project`, `projectCollection`. Defaults to `projectCollection`.
        :param _builtins.int job_cancel_timeout_in_minutes: The job cancel timeout (in minutes) for builds cancelled by user for this definition. Possible values are between `0` and `60`. Defaults to `0`.
        :param _builtins.int job_timeout_in_minutes: The job execution timeout (in minutes) for builds queued against this definition. Possible values are between `0` and `1000000000`. Defaults to `0`.
        """
        pulumi.set(__self__, "condition", condition)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "ref_name", ref_name)
        pulumi.set(__self__, "target", target)
        if allow_scripts_auth_access_option is not None:
            pulumi.set(__self__, "allow_scripts_auth_access_option", allow_scripts_auth_access_option)
        if dependencies is not None:
            pulumi.set(__self__, "dependencies", dependencies)
        if job_authorization_scope is not None:
            pulumi.set(__self__, "job_authorization_scope", job_authorization_scope)
        if job_cancel_timeout_in_minutes is not None:
            pulumi.set(__self__, "job_cancel_timeout_in_minutes", job_cancel_timeout_in_minutes)
        if job_timeout_in_minutes is not None:
            pulumi.set(__self__, "job_timeout_in_minutes", job_timeout_in_minutes)

    @_builtins.property
    @pulumi.getter
    def condition(self) -> _builtins.str:
        """
        Specifies when this job should run. Can **Custom conditions** to specify more complex conditions. Possible values: `succeeded()`, `succeededOrFailed()`, `always()`, `failed()` etc. More details: [Pipeline conditions](https://learn.microsoft.com/en-us/azure/devops/pipelines/process/conditions?view=azure-devops)
        """
        return pulumi.get(self, "condition")

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        The name of the job.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter(name="refName")
    def ref_name(self) -> _builtins.str:
        """
        The reference name of the job, can be used to define the job dependencies.
        """
        return pulumi.get(self, "ref_name")

    @_builtins.property
    @pulumi.getter
    def target(self) -> 'outputs.BuildDefinitionJobTarget':
        """
        A `target` blocks as documented below.
        """
        return pulumi.get(self, "target")

    @_builtins.property
    @pulumi.getter(name="allowScriptsAuthAccessOption")
    def allow_scripts_auth_access_option(self) -> Optional[_builtins.bool]:
        """
        Enables scripts and other processes launched by tasks to access the OAuth token through the `System.AccessToken` variable. Possible values: `true`, `false`. Defaults to `false`. Available when Job type is `AgentJob`
        """
        return pulumi.get(self, "allow_scripts_auth_access_option")

    @_builtins.property
    @pulumi.getter
    def dependencies(self) -> Optional[Sequence['outputs.BuildDefinitionJobDependency']]:
        """
        A `dependencies` blocks as documented below. Define the job dependencies.
        """
        return pulumi.get(self, "dependencies")

    @_builtins.property
    @pulumi.getter(name="jobAuthorizationScope")
    def job_authorization_scope(self) -> Optional[_builtins.str]:
        """
        The job authorization scope for builds queued against this definition. Possible values are: `project`, `projectCollection`. Defaults to `projectCollection`.
        """
        return pulumi.get(self, "job_authorization_scope")

    @_builtins.property
    @pulumi.getter(name="jobCancelTimeoutInMinutes")
    def job_cancel_timeout_in_minutes(self) -> Optional[_builtins.int]:
        """
        The job cancel timeout (in minutes) for builds cancelled by user for this definition. Possible values are between `0` and `60`. Defaults to `0`.
        """
        return pulumi.get(self, "job_cancel_timeout_in_minutes")

    @_builtins.property
    @pulumi.getter(name="jobTimeoutInMinutes")
    def job_timeout_in_minutes(self) -> Optional[_builtins.int]:
        """
        The job execution timeout (in minutes) for builds queued against this definition. Possible values are between `0` and `1000000000`. Defaults to `0`.
        """
        return pulumi.get(self, "job_timeout_in_minutes")


@pulumi.output_type
class BuildDefinitionJobDependency(dict):
    def __init__(__self__, *,
                 scope: _builtins.str):
        """
        :param _builtins.str scope: The job reference name that depends on. Reference to `jobs.ref_name`
        """
        pulumi.set(__self__, "scope", scope)

    @_builtins.property
    @pulumi.getter
    def scope(self) -> _builtins.str:
        """
        The job reference name that depends on. Reference to `jobs.ref_name`
        """
        return pulumi.get(self, "scope")


@pulumi.output_type
class BuildDefinitionJobTarget(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "executionOptions":
            suggest = "execution_options"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in BuildDefinitionJobTarget. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        BuildDefinitionJobTarget.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        BuildDefinitionJobTarget.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 execution_options: 'outputs.BuildDefinitionJobTargetExecutionOptions',
                 type: _builtins.str,
                 demands: Optional[Sequence[_builtins.str]] = None):
        """
        :param 'BuildDefinitionJobTargetExecutionOptionsArgs' execution_options: A `execution_options` blocks as documented below.
        :param _builtins.str type: The job type. Possible values: `AgentJob`, `AgentlessJob`
        :param Sequence[_builtins.str] demands: A list of demands that represents the agent capabilities required by this build. Example: `git`
        """
        pulumi.set(__self__, "execution_options", execution_options)
        pulumi.set(__self__, "type", type)
        if demands is not None:
            pulumi.set(__self__, "demands", demands)

    @_builtins.property
    @pulumi.getter(name="executionOptions")
    def execution_options(self) -> 'outputs.BuildDefinitionJobTargetExecutionOptions':
        """
        A `execution_options` blocks as documented below.
        """
        return pulumi.get(self, "execution_options")

    @_builtins.property
    @pulumi.getter
    def type(self) -> _builtins.str:
        """
        The job type. Possible values: `AgentJob`, `AgentlessJob`
        """
        return pulumi.get(self, "type")

    @_builtins.property
    @pulumi.getter
    def demands(self) -> Optional[Sequence[_builtins.str]]:
        """
        A list of demands that represents the agent capabilities required by this build. Example: `git`
        """
        return pulumi.get(self, "demands")


@pulumi.output_type
class BuildDefinitionJobTargetExecutionOptions(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "continueOnError":
            suggest = "continue_on_error"
        elif key == "maxConcurrency":
            suggest = "max_concurrency"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in BuildDefinitionJobTargetExecutionOptions. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        BuildDefinitionJobTargetExecutionOptions.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        BuildDefinitionJobTargetExecutionOptions.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 type: _builtins.str,
                 continue_on_error: Optional[_builtins.bool] = None,
                 max_concurrency: Optional[_builtins.int] = None,
                 multipliers: Optional[_builtins.str] = None):
        """
        :param _builtins.str type: The execution type of the Job. Possible values are: `None`, `Multi-Configuration`, `Multi-Agent`.
        :param _builtins.bool continue_on_error: Whether to continue the job when an error occurs. Possible values are: `true`, `false`.
        :param _builtins.int max_concurrency: Limit the number of agents to be used. If job type is `AgentlessJob`, the concurrency is not configurable and is fixed to 50.
        :param _builtins.str multipliers: A list of comma separated configuration variables to use. These are defined on the Variables tab. For example, OperatingSystem, Browser will run the tasks for both variables. Available when `execution_options.type` is `Multi-Configuration`.
        """
        pulumi.set(__self__, "type", type)
        if continue_on_error is not None:
            pulumi.set(__self__, "continue_on_error", continue_on_error)
        if max_concurrency is not None:
            pulumi.set(__self__, "max_concurrency", max_concurrency)
        if multipliers is not None:
            pulumi.set(__self__, "multipliers", multipliers)

    @_builtins.property
    @pulumi.getter
    def type(self) -> _builtins.str:
        """
        The execution type of the Job. Possible values are: `None`, `Multi-Configuration`, `Multi-Agent`.
        """
        return pulumi.get(self, "type")

    @_builtins.property
    @pulumi.getter(name="continueOnError")
    def continue_on_error(self) -> Optional[_builtins.bool]:
        """
        Whether to continue the job when an error occurs. Possible values are: `true`, `false`.
        """
        return pulumi.get(self, "continue_on_error")

    @_builtins.property
    @pulumi.getter(name="maxConcurrency")
    def max_concurrency(self) -> Optional[_builtins.int]:
        """
        Limit the number of agents to be used. If job type is `AgentlessJob`, the concurrency is not configurable and is fixed to 50.
        """
        return pulumi.get(self, "max_concurrency")

    @_builtins.property
    @pulumi.getter
    def multipliers(self) -> Optional[_builtins.str]:
        """
        A list of comma separated configuration variables to use. These are defined on the Variables tab. For example, OperatingSystem, Browser will run the tasks for both variables. Available when `execution_options.type` is `Multi-Configuration`.
        """
        return pulumi.get(self, "multipliers")


@pulumi.output_type
class BuildDefinitionPullRequestTrigger(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "commentRequired":
            suggest = "comment_required"
        elif key == "initialBranch":
            suggest = "initial_branch"
        elif key == "useYaml":
            suggest = "use_yaml"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in BuildDefinitionPullRequestTrigger. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        BuildDefinitionPullRequestTrigger.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        BuildDefinitionPullRequestTrigger.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 forks: 'outputs.BuildDefinitionPullRequestTriggerForks',
                 comment_required: Optional[_builtins.str] = None,
                 initial_branch: Optional[_builtins.str] = None,
                 override: Optional['outputs.BuildDefinitionPullRequestTriggerOverride'] = None,
                 use_yaml: Optional[_builtins.bool] = None):
        """
        :param 'BuildDefinitionPullRequestTriggerForksArgs' forks: Set permissions for Forked repositories.
        :param 'BuildDefinitionPullRequestTriggerOverrideArgs' override: Override the azure-pipeline file and use this configuration for all builds.
        :param _builtins.bool use_yaml: Use the azure-pipeline file for the build configuration. Defaults to `false`.
        """
        pulumi.set(__self__, "forks", forks)
        if comment_required is not None:
            pulumi.set(__self__, "comment_required", comment_required)
        if initial_branch is not None:
            pulumi.set(__self__, "initial_branch", initial_branch)
        if override is not None:
            pulumi.set(__self__, "override", override)
        if use_yaml is not None:
            pulumi.set(__self__, "use_yaml", use_yaml)

    @_builtins.property
    @pulumi.getter
    def forks(self) -> 'outputs.BuildDefinitionPullRequestTriggerForks':
        """
        Set permissions for Forked repositories.
        """
        return pulumi.get(self, "forks")

    @_builtins.property
    @pulumi.getter(name="commentRequired")
    def comment_required(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "comment_required")

    @_builtins.property
    @pulumi.getter(name="initialBranch")
    def initial_branch(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "initial_branch")

    @_builtins.property
    @pulumi.getter
    def override(self) -> Optional['outputs.BuildDefinitionPullRequestTriggerOverride']:
        """
        Override the azure-pipeline file and use this configuration for all builds.
        """
        return pulumi.get(self, "override")

    @_builtins.property
    @pulumi.getter(name="useYaml")
    def use_yaml(self) -> Optional[_builtins.bool]:
        """
        Use the azure-pipeline file for the build configuration. Defaults to `false`.
        """
        return pulumi.get(self, "use_yaml")


@pulumi.output_type
class BuildDefinitionPullRequestTriggerForks(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "shareSecrets":
            suggest = "share_secrets"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in BuildDefinitionPullRequestTriggerForks. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        BuildDefinitionPullRequestTriggerForks.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        BuildDefinitionPullRequestTriggerForks.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 enabled: _builtins.bool,
                 share_secrets: _builtins.bool):
        """
        :param _builtins.bool enabled: Build pull requests from forks of this repository.
        :param _builtins.bool share_secrets: Make secrets available to builds of forks.
        """
        pulumi.set(__self__, "enabled", enabled)
        pulumi.set(__self__, "share_secrets", share_secrets)

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> _builtins.bool:
        """
        Build pull requests from forks of this repository.
        """
        return pulumi.get(self, "enabled")

    @_builtins.property
    @pulumi.getter(name="shareSecrets")
    def share_secrets(self) -> _builtins.bool:
        """
        Make secrets available to builds of forks.
        """
        return pulumi.get(self, "share_secrets")


@pulumi.output_type
class BuildDefinitionPullRequestTriggerOverride(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "branchFilters":
            suggest = "branch_filters"
        elif key == "autoCancel":
            suggest = "auto_cancel"
        elif key == "pathFilters":
            suggest = "path_filters"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in BuildDefinitionPullRequestTriggerOverride. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        BuildDefinitionPullRequestTriggerOverride.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        BuildDefinitionPullRequestTriggerOverride.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 branch_filters: Sequence['outputs.BuildDefinitionPullRequestTriggerOverrideBranchFilter'],
                 auto_cancel: Optional[_builtins.bool] = None,
                 path_filters: Optional[Sequence['outputs.BuildDefinitionPullRequestTriggerOverridePathFilter']] = None):
        """
        :param Sequence['BuildDefinitionPullRequestTriggerOverrideBranchFilterArgs'] branch_filters: The branches to include and exclude from the trigger. A `branch_filter` block as documented below.
        :param _builtins.bool auto_cancel: . Defaults to `true`.
        :param Sequence['BuildDefinitionPullRequestTriggerOverridePathFilterArgs'] path_filters: Specify file paths to include or exclude. Note that the wildcard syntax is different between branches/tags and file paths.
        """
        pulumi.set(__self__, "branch_filters", branch_filters)
        if auto_cancel is not None:
            pulumi.set(__self__, "auto_cancel", auto_cancel)
        if path_filters is not None:
            pulumi.set(__self__, "path_filters", path_filters)

    @_builtins.property
    @pulumi.getter(name="branchFilters")
    def branch_filters(self) -> Sequence['outputs.BuildDefinitionPullRequestTriggerOverrideBranchFilter']:
        """
        The branches to include and exclude from the trigger. A `branch_filter` block as documented below.
        """
        return pulumi.get(self, "branch_filters")

    @_builtins.property
    @pulumi.getter(name="autoCancel")
    def auto_cancel(self) -> Optional[_builtins.bool]:
        """
        . Defaults to `true`.
        """
        return pulumi.get(self, "auto_cancel")

    @_builtins.property
    @pulumi.getter(name="pathFilters")
    def path_filters(self) -> Optional[Sequence['outputs.BuildDefinitionPullRequestTriggerOverridePathFilter']]:
        """
        Specify file paths to include or exclude. Note that the wildcard syntax is different between branches/tags and file paths.
        """
        return pulumi.get(self, "path_filters")


@pulumi.output_type
class BuildDefinitionPullRequestTriggerOverrideBranchFilter(dict):
    def __init__(__self__, *,
                 excludes: Optional[Sequence[_builtins.str]] = None,
                 includes: Optional[Sequence[_builtins.str]] = None):
        """
        :param Sequence[_builtins.str] excludes: List of branch patterns to exclude.
        :param Sequence[_builtins.str] includes: List of branch patterns to include.
        """
        if excludes is not None:
            pulumi.set(__self__, "excludes", excludes)
        if includes is not None:
            pulumi.set(__self__, "includes", includes)

    @_builtins.property
    @pulumi.getter
    def excludes(self) -> Optional[Sequence[_builtins.str]]:
        """
        List of branch patterns to exclude.
        """
        return pulumi.get(self, "excludes")

    @_builtins.property
    @pulumi.getter
    def includes(self) -> Optional[Sequence[_builtins.str]]:
        """
        List of branch patterns to include.
        """
        return pulumi.get(self, "includes")


@pulumi.output_type
class BuildDefinitionPullRequestTriggerOverridePathFilter(dict):
    def __init__(__self__, *,
                 excludes: Optional[Sequence[_builtins.str]] = None,
                 includes: Optional[Sequence[_builtins.str]] = None):
        """
        :param Sequence[_builtins.str] excludes: List of path patterns to exclude.
        :param Sequence[_builtins.str] includes: List of path patterns to include.
        """
        if excludes is not None:
            pulumi.set(__self__, "excludes", excludes)
        if includes is not None:
            pulumi.set(__self__, "includes", includes)

    @_builtins.property
    @pulumi.getter
    def excludes(self) -> Optional[Sequence[_builtins.str]]:
        """
        List of path patterns to exclude.
        """
        return pulumi.get(self, "excludes")

    @_builtins.property
    @pulumi.getter
    def includes(self) -> Optional[Sequence[_builtins.str]]:
        """
        List of path patterns to include.
        """
        return pulumi.get(self, "includes")


@pulumi.output_type
class BuildDefinitionRepository(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "repoId":
            suggest = "repo_id"
        elif key == "repoType":
            suggest = "repo_type"
        elif key == "branchName":
            suggest = "branch_name"
        elif key == "githubEnterpriseUrl":
            suggest = "github_enterprise_url"
        elif key == "reportBuildStatus":
            suggest = "report_build_status"
        elif key == "serviceConnectionId":
            suggest = "service_connection_id"
        elif key == "ymlPath":
            suggest = "yml_path"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in BuildDefinitionRepository. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        BuildDefinitionRepository.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        BuildDefinitionRepository.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 repo_id: _builtins.str,
                 repo_type: _builtins.str,
                 branch_name: Optional[_builtins.str] = None,
                 github_enterprise_url: Optional[_builtins.str] = None,
                 report_build_status: Optional[_builtins.bool] = None,
                 service_connection_id: Optional[_builtins.str] = None,
                 url: Optional[_builtins.str] = None,
                 yml_path: Optional[_builtins.str] = None):
        """
        :param _builtins.str repo_id: The id of the repository. For `TfsGit` repos, this is simply the ID of the repository. For `Github` repos, this will take the form of `<GitHub Org>/<Repo Name>`. For `Bitbucket` repos, this will take the form of `<Workspace ID>/<Repo Name>`.
        :param _builtins.str repo_type: The repository type. Possible values are: `GitHub` or `TfsGit` or `Bitbucket` or `GitHub Enterprise` or `Git`. Defaults to `GitHub`. If `repo_type` is `GitHubEnterprise`, must use existing project and GitHub Enterprise service connection.
        :param _builtins.str branch_name: The branch name for which builds are triggered. Defaults to `master`.
        :param _builtins.str github_enterprise_url: The Github Enterprise URL. Used if `repo_type` is `GithubEnterprise`. Conflict with `url`
        :param _builtins.bool report_build_status: Report build status. Default is true.
        :param _builtins.str service_connection_id: The service connection ID. Used if the `repo_type` is `GitHub` or `GitHubEnterprise`.
        :param _builtins.str url: The URL of the Git repository. Used if `repo_type` is `Git`. Conflict with `github_enterprise_url`
        :param _builtins.str yml_path: The path of the Yaml file describing the build definition.
        """
        pulumi.set(__self__, "repo_id", repo_id)
        pulumi.set(__self__, "repo_type", repo_type)
        if branch_name is not None:
            pulumi.set(__self__, "branch_name", branch_name)
        if github_enterprise_url is not None:
            pulumi.set(__self__, "github_enterprise_url", github_enterprise_url)
        if report_build_status is not None:
            pulumi.set(__self__, "report_build_status", report_build_status)
        if service_connection_id is not None:
            pulumi.set(__self__, "service_connection_id", service_connection_id)
        if url is not None:
            pulumi.set(__self__, "url", url)
        if yml_path is not None:
            pulumi.set(__self__, "yml_path", yml_path)

    @_builtins.property
    @pulumi.getter(name="repoId")
    def repo_id(self) -> _builtins.str:
        """
        The id of the repository. For `TfsGit` repos, this is simply the ID of the repository. For `Github` repos, this will take the form of `<GitHub Org>/<Repo Name>`. For `Bitbucket` repos, this will take the form of `<Workspace ID>/<Repo Name>`.
        """
        return pulumi.get(self, "repo_id")

    @_builtins.property
    @pulumi.getter(name="repoType")
    def repo_type(self) -> _builtins.str:
        """
        The repository type. Possible values are: `GitHub` or `TfsGit` or `Bitbucket` or `GitHub Enterprise` or `Git`. Defaults to `GitHub`. If `repo_type` is `GitHubEnterprise`, must use existing project and GitHub Enterprise service connection.
        """
        return pulumi.get(self, "repo_type")

    @_builtins.property
    @pulumi.getter(name="branchName")
    def branch_name(self) -> Optional[_builtins.str]:
        """
        The branch name for which builds are triggered. Defaults to `master`.
        """
        return pulumi.get(self, "branch_name")

    @_builtins.property
    @pulumi.getter(name="githubEnterpriseUrl")
    def github_enterprise_url(self) -> Optional[_builtins.str]:
        """
        The Github Enterprise URL. Used if `repo_type` is `GithubEnterprise`. Conflict with `url`
        """
        return pulumi.get(self, "github_enterprise_url")

    @_builtins.property
    @pulumi.getter(name="reportBuildStatus")
    def report_build_status(self) -> Optional[_builtins.bool]:
        """
        Report build status. Default is true.
        """
        return pulumi.get(self, "report_build_status")

    @_builtins.property
    @pulumi.getter(name="serviceConnectionId")
    def service_connection_id(self) -> Optional[_builtins.str]:
        """
        The service connection ID. Used if the `repo_type` is `GitHub` or `GitHubEnterprise`.
        """
        return pulumi.get(self, "service_connection_id")

    @_builtins.property
    @pulumi.getter
    def url(self) -> Optional[_builtins.str]:
        """
        The URL of the Git repository. Used if `repo_type` is `Git`. Conflict with `github_enterprise_url`
        """
        return pulumi.get(self, "url")

    @_builtins.property
    @pulumi.getter(name="ymlPath")
    def yml_path(self) -> Optional[_builtins.str]:
        """
        The path of the Yaml file describing the build definition.
        """
        return pulumi.get(self, "yml_path")


@pulumi.output_type
class BuildDefinitionSchedule(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "branchFilters":
            suggest = "branch_filters"
        elif key == "daysToBuilds":
            suggest = "days_to_builds"
        elif key == "scheduleJobId":
            suggest = "schedule_job_id"
        elif key == "scheduleOnlyWithChanges":
            suggest = "schedule_only_with_changes"
        elif key == "startHours":
            suggest = "start_hours"
        elif key == "startMinutes":
            suggest = "start_minutes"
        elif key == "timeZone":
            suggest = "time_zone"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in BuildDefinitionSchedule. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        BuildDefinitionSchedule.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        BuildDefinitionSchedule.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 branch_filters: Sequence['outputs.BuildDefinitionScheduleBranchFilter'],
                 days_to_builds: Sequence[_builtins.str],
                 schedule_job_id: Optional[_builtins.str] = None,
                 schedule_only_with_changes: Optional[_builtins.bool] = None,
                 start_hours: Optional[_builtins.int] = None,
                 start_minutes: Optional[_builtins.int] = None,
                 time_zone: Optional[_builtins.str] = None):
        """
        :param Sequence['BuildDefinitionScheduleBranchFilterArgs'] branch_filters: A `branch_filter` block as defined below.
        :param Sequence[_builtins.str] days_to_builds: When to build. Possible values are: `Mon`, `Tue`, `Wed`, `Thu`, `Fri`, `Sat`, `Sun`.
        :param _builtins.str schedule_job_id: The ID of the schedule job
        :param _builtins.bool schedule_only_with_changes: Schedule builds if the source or pipeline has changed. Defaults to `true`.
        :param _builtins.int start_hours: Build start hour. Possible values are: `0 ~ 23`. Defaults to `0`.
        :param _builtins.int start_minutes: Build start minute. Possible values are: `0 ~ 59`. Defaults to `0`.
        :param _builtins.str time_zone: Build time zone. Defaults to `(UTC) Coordinated Universal Time`. Possible values are:
               `(UTC-12:00) International Date Line West`,
               `(UTC-11:00) Coordinated Universal Time-11`,
               `(UTC-10:00) Aleutian Islands`,
               `(UTC-10:00) Hawaii`,
               `(UTC-09:30) Marquesas Islands`,
               `(UTC-09:00) Alaska`,
               `(UTC-09:00) Coordinated Universal Time-09`,
               `(UTC-08:00) Baja California`,
               `(UTC-08:00) Coordinated Universal Time-08`,
               `(UTC-08:00) Pacific Time (US &Canada)`,
               `(UTC-07:00) Arizona`,
               `(UTC-07:00) Chihuahua, La Paz, Mazatlan`,
               `(UTC-07:00) Mountain Time (US &Canada)`,
               `(UTC-07:00) Yukon`,
               `(UTC-06:00) Central America`,
               `(UTC-06:00) Central Time (US &Canada)`,
               `(UTC-06:00) Easter Island`,
               `(UTC-06:00) Guadalajara, Mexico City, Monterrey`,
               `(UTC-06:00) Saskatchewan`,
               `(UTC-05:00) Bogota, Lima, Quito, Rio Branco`,
               `(UTC-05:00) Chetumal`,
               `(UTC-05:00) Eastern Time (US &Canada)`,
               `(UTC-05:00) Haiti`,
               `(UTC-05:00) Havana`,
               `(UTC-05:00) Indiana (East)`,
               `(UTC-05:00) Turks and Caicos`,
               `(UTC-04:00) Asuncion`,
               `(UTC-04:00) Atlantic Time (Canada)`,
               `(UTC-04:00) Caracas`,
               `(UTC-04:00) Cuiaba`,
               `(UTC-04:00) Georgetown, La Paz, Manaus, San Juan`,
               `(UTC-04:00) Santiago`,
               `(UTC-03:30) Newfoundland`,
               `(UTC-03:00) Araguaina`,
               `(UTC-03:00) Brasilia`,
               `(UTC-03:00) Cayenne, Fortaleza`,
               `(UTC-03:00) City of Buenos Aires`,
               `(UTC-03:00) Greenland`,
               `(UTC-03:00) Montevideo`,
               `(UTC-03:00) Punta Arenas`,
               `(UTC-03:00) Saint Pierre and Miquelon`,
               `(UTC-03:00) Salvador`,
               `(UTC-02:00) Coordinated Universal Time-02`,
               `(UTC-02:00) Mid-Atlantic - Old`,
               `(UTC-01:00) Azores`,
               `(UTC-01:00) Cabo Verde Is.`,
               `(UTC) Coordinated Universal Time`,
               `(UTC+00:00) Dublin, Edinburgh, Lisbon, London`,
               `(UTC+00:00) Monrovia, Reykjavik`,
               `(UTC+00:00) Sao Tome`,
               `(UTC+01:00) Casablanca`,
               `(UTC+01:00) Amsterdam, Berlin, Bern, Rome, Stockholm, Vienna`,
               `(UTC+01:00) Belgrade, Bratislava, Budapest, Ljubljana, Prague`,
               `(UTC+01:00) Brussels, Copenhagen, Madrid, Paris`,
               `(UTC+01:00) Sarajevo, Skopje, Warsaw, Zagreb`,
               `(UTC+01:00) West Central Africa`,
               `(UTC+02:00) Amman`,
               `(UTC+02:00) Athens, Bucharest`,
               `(UTC+02:00) Beirut`,
               `(UTC+02:00) Cairo`,
               `(UTC+02:00) Chisinau`,
               `(UTC+02:00) Damascus`,
               `(UTC+02:00) Gaza, Hebron`,
               `(UTC+02:00) Harare, Pretoria`,
               `(UTC+02:00) Helsinki, Kyiv, Riga, Sofia, Tallinn, Vilnius`,
               `(UTC+02:00) Jerusalem`,
               `(UTC+02:00) Juba`,
               `(UTC+02:00) Kaliningrad`,
               `(UTC+02:00) Khartoum`,
               `(UTC+02:00) Tripoli`,
               `(UTC+02:00) Windhoek`,
               `(UTC+03:00) Baghdad`,
               `(UTC+03:00) Istanbul`,
               `(UTC+03:00) Kuwait, Riyadh`,
               `(UTC+03:00) Minsk`,
               `(UTC+03:00) Moscow, St. Petersburg`,
               `(UTC+03:00) Nairobi`,
               `(UTC+03:00) Volgograd`,
               `(UTC+03:30) Tehran`,
               `(UTC+04:00) Abu Dhabi, Muscat`,
               `(UTC+04:00) Astrakhan, Ulyanovsk`,
               `(UTC+04:00) Baku`,
               `(UTC+04:00) Izhevsk, Samara`,
               `(UTC+04:00) Port Louis`,
               `(UTC+04:00) Saratov`,
               `(UTC+04:00) Tbilisi`,
               `(UTC+04:00) Yerevan`,
               `(UTC+04:30) Kabul`,
               `(UTC+05:00) Ashgabat, Tashkent`,
               `(UTC+05:00) Ekaterinburg`,
               `(UTC+05:00) Islamabad, Karachi`,
               `(UTC+05:00) Qyzylorda`,
               `(UTC+05:30) Chennai, Kolkata, Mumbai, New Delhi`,
               `(UTC+05:30) Sri Jayawardenepura`,
               `(UTC+05:45) Kathmandu`,
               `(UTC+06:00) Astana`,
               `(UTC+06:00) Dhaka`,
               `(UTC+06:00) Omsk`,
               `(UTC+06:30) Yangon (Rangoon)`,
               `(UTC+07:00) Bangkok, Hanoi, Jakarta`,
               `(UTC+07:00) Barnaul, Gorno-Altaysk`,
               `(UTC+07:00) Hovd`,
               `(UTC+07:00) Krasnoyarsk`,
               `(UTC+07:00) Novosibirsk`,
               `(UTC+07:00) Tomsk`,
               `(UTC+08:00) Beijing, Chongqing, Hong Kong, Urumqi`,
               `(UTC+08:00) Irkutsk`,
               `(UTC+08:00) Kuala Lumpur, Singapore`,
               `(UTC+08:00) Perth`,
               `(UTC+08:00) Taipei`,
               `(UTC+08:00) Ulaanbaatar`,
               `(UTC+08:45) Eucla`,
               `(UTC+09:00) Chita`,
               `(UTC+09:00) Osaka, Sapporo, Tokyo`,
               `(UTC+09:00) Pyongyang`,
               `(UTC+09:00) Seoul`,
               `(UTC+09:00) Yakutsk`,
               `(UTC+09:30) Adelaide`,
               `(UTC+09:30) Darwin`,
               `(UTC+10:00) Brisbane`,
               `(UTC+10:00) Canberra, Melbourne, Sydney`,
               `(UTC+10:00) Guam, Port Moresby`,
               `(UTC+10:00) Hobart`,
               `(UTC+10:00) Vladivostok`,
               `(UTC+10:30) Lord Howe Island`,
               `(UTC+11:00) Bougainville Island`,
               `(UTC+11:00) Chokurdakh`,
               `(UTC+11:00) Magadan`,
               `(UTC+11:00) Norfolk Island`,
               `(UTC+11:00) Sakhalin`,
               `(UTC+11:00) Solomon Is., New Caledonia`,
               `(UTC+12:00) Anadyr, Petropavlovsk-Kamchatsky`,
               `(UTC+12:00) Auckland, Wellington`,
               `(UTC+12:00) Coordinated Universal Time+12`,
               `(UTC+12:00) Fiji`,
               `(UTC+12:00) Petropavlovsk-Kamchatsky - Old`,
               `(UTC+12:45) Chatham Islands`,
               `(UTC+13:00) Coordinated Universal Time+13`,
               `(UTC+13:00) Nuku'alofa`,
               `(UTC+13:00) Samoa`,
               `(UTC+14:00) Kiritimati Island`.
        """
        pulumi.set(__self__, "branch_filters", branch_filters)
        pulumi.set(__self__, "days_to_builds", days_to_builds)
        if schedule_job_id is not None:
            pulumi.set(__self__, "schedule_job_id", schedule_job_id)
        if schedule_only_with_changes is not None:
            pulumi.set(__self__, "schedule_only_with_changes", schedule_only_with_changes)
        if start_hours is not None:
            pulumi.set(__self__, "start_hours", start_hours)
        if start_minutes is not None:
            pulumi.set(__self__, "start_minutes", start_minutes)
        if time_zone is not None:
            pulumi.set(__self__, "time_zone", time_zone)

    @_builtins.property
    @pulumi.getter(name="branchFilters")
    def branch_filters(self) -> Sequence['outputs.BuildDefinitionScheduleBranchFilter']:
        """
        A `branch_filter` block as defined below.
        """
        return pulumi.get(self, "branch_filters")

    @_builtins.property
    @pulumi.getter(name="daysToBuilds")
    def days_to_builds(self) -> Sequence[_builtins.str]:
        """
        When to build. Possible values are: `Mon`, `Tue`, `Wed`, `Thu`, `Fri`, `Sat`, `Sun`.
        """
        return pulumi.get(self, "days_to_builds")

    @_builtins.property
    @pulumi.getter(name="scheduleJobId")
    def schedule_job_id(self) -> Optional[_builtins.str]:
        """
        The ID of the schedule job
        """
        return pulumi.get(self, "schedule_job_id")

    @_builtins.property
    @pulumi.getter(name="scheduleOnlyWithChanges")
    def schedule_only_with_changes(self) -> Optional[_builtins.bool]:
        """
        Schedule builds if the source or pipeline has changed. Defaults to `true`.
        """
        return pulumi.get(self, "schedule_only_with_changes")

    @_builtins.property
    @pulumi.getter(name="startHours")
    def start_hours(self) -> Optional[_builtins.int]:
        """
        Build start hour. Possible values are: `0 ~ 23`. Defaults to `0`.
        """
        return pulumi.get(self, "start_hours")

    @_builtins.property
    @pulumi.getter(name="startMinutes")
    def start_minutes(self) -> Optional[_builtins.int]:
        """
        Build start minute. Possible values are: `0 ~ 59`. Defaults to `0`.
        """
        return pulumi.get(self, "start_minutes")

    @_builtins.property
    @pulumi.getter(name="timeZone")
    def time_zone(self) -> Optional[_builtins.str]:
        """
        Build time zone. Defaults to `(UTC) Coordinated Universal Time`. Possible values are:
        `(UTC-12:00) International Date Line West`,
        `(UTC-11:00) Coordinated Universal Time-11`,
        `(UTC-10:00) Aleutian Islands`,
        `(UTC-10:00) Hawaii`,
        `(UTC-09:30) Marquesas Islands`,
        `(UTC-09:00) Alaska`,
        `(UTC-09:00) Coordinated Universal Time-09`,
        `(UTC-08:00) Baja California`,
        `(UTC-08:00) Coordinated Universal Time-08`,
        `(UTC-08:00) Pacific Time (US &Canada)`,
        `(UTC-07:00) Arizona`,
        `(UTC-07:00) Chihuahua, La Paz, Mazatlan`,
        `(UTC-07:00) Mountain Time (US &Canada)`,
        `(UTC-07:00) Yukon`,
        `(UTC-06:00) Central America`,
        `(UTC-06:00) Central Time (US &Canada)`,
        `(UTC-06:00) Easter Island`,
        `(UTC-06:00) Guadalajara, Mexico City, Monterrey`,
        `(UTC-06:00) Saskatchewan`,
        `(UTC-05:00) Bogota, Lima, Quito, Rio Branco`,
        `(UTC-05:00) Chetumal`,
        `(UTC-05:00) Eastern Time (US &Canada)`,
        `(UTC-05:00) Haiti`,
        `(UTC-05:00) Havana`,
        `(UTC-05:00) Indiana (East)`,
        `(UTC-05:00) Turks and Caicos`,
        `(UTC-04:00) Asuncion`,
        `(UTC-04:00) Atlantic Time (Canada)`,
        `(UTC-04:00) Caracas`,
        `(UTC-04:00) Cuiaba`,
        `(UTC-04:00) Georgetown, La Paz, Manaus, San Juan`,
        `(UTC-04:00) Santiago`,
        `(UTC-03:30) Newfoundland`,
        `(UTC-03:00) Araguaina`,
        `(UTC-03:00) Brasilia`,
        `(UTC-03:00) Cayenne, Fortaleza`,
        `(UTC-03:00) City of Buenos Aires`,
        `(UTC-03:00) Greenland`,
        `(UTC-03:00) Montevideo`,
        `(UTC-03:00) Punta Arenas`,
        `(UTC-03:00) Saint Pierre and Miquelon`,
        `(UTC-03:00) Salvador`,
        `(UTC-02:00) Coordinated Universal Time-02`,
        `(UTC-02:00) Mid-Atlantic - Old`,
        `(UTC-01:00) Azores`,
        `(UTC-01:00) Cabo Verde Is.`,
        `(UTC) Coordinated Universal Time`,
        `(UTC+00:00) Dublin, Edinburgh, Lisbon, London`,
        `(UTC+00:00) Monrovia, Reykjavik`,
        `(UTC+00:00) Sao Tome`,
        `(UTC+01:00) Casablanca`,
        `(UTC+01:00) Amsterdam, Berlin, Bern, Rome, Stockholm, Vienna`,
        `(UTC+01:00) Belgrade, Bratislava, Budapest, Ljubljana, Prague`,
        `(UTC+01:00) Brussels, Copenhagen, Madrid, Paris`,
        `(UTC+01:00) Sarajevo, Skopje, Warsaw, Zagreb`,
        `(UTC+01:00) West Central Africa`,
        `(UTC+02:00) Amman`,
        `(UTC+02:00) Athens, Bucharest`,
        `(UTC+02:00) Beirut`,
        `(UTC+02:00) Cairo`,
        `(UTC+02:00) Chisinau`,
        `(UTC+02:00) Damascus`,
        `(UTC+02:00) Gaza, Hebron`,
        `(UTC+02:00) Harare, Pretoria`,
        `(UTC+02:00) Helsinki, Kyiv, Riga, Sofia, Tallinn, Vilnius`,
        `(UTC+02:00) Jerusalem`,
        `(UTC+02:00) Juba`,
        `(UTC+02:00) Kaliningrad`,
        `(UTC+02:00) Khartoum`,
        `(UTC+02:00) Tripoli`,
        `(UTC+02:00) Windhoek`,
        `(UTC+03:00) Baghdad`,
        `(UTC+03:00) Istanbul`,
        `(UTC+03:00) Kuwait, Riyadh`,
        `(UTC+03:00) Minsk`,
        `(UTC+03:00) Moscow, St. Petersburg`,
        `(UTC+03:00) Nairobi`,
        `(UTC+03:00) Volgograd`,
        `(UTC+03:30) Tehran`,
        `(UTC+04:00) Abu Dhabi, Muscat`,
        `(UTC+04:00) Astrakhan, Ulyanovsk`,
        `(UTC+04:00) Baku`,
        `(UTC+04:00) Izhevsk, Samara`,
        `(UTC+04:00) Port Louis`,
        `(UTC+04:00) Saratov`,
        `(UTC+04:00) Tbilisi`,
        `(UTC+04:00) Yerevan`,
        `(UTC+04:30) Kabul`,
        `(UTC+05:00) Ashgabat, Tashkent`,
        `(UTC+05:00) Ekaterinburg`,
        `(UTC+05:00) Islamabad, Karachi`,
        `(UTC+05:00) Qyzylorda`,
        `(UTC+05:30) Chennai, Kolkata, Mumbai, New Delhi`,
        `(UTC+05:30) Sri Jayawardenepura`,
        `(UTC+05:45) Kathmandu`,
        `(UTC+06:00) Astana`,
        `(UTC+06:00) Dhaka`,
        `(UTC+06:00) Omsk`,
        `(UTC+06:30) Yangon (Rangoon)`,
        `(UTC+07:00) Bangkok, Hanoi, Jakarta`,
        `(UTC+07:00) Barnaul, Gorno-Altaysk`,
        `(UTC+07:00) Hovd`,
        `(UTC+07:00) Krasnoyarsk`,
        `(UTC+07:00) Novosibirsk`,
        `(UTC+07:00) Tomsk`,
        `(UTC+08:00) Beijing, Chongqing, Hong Kong, Urumqi`,
        `(UTC+08:00) Irkutsk`,
        `(UTC+08:00) Kuala Lumpur, Singapore`,
        `(UTC+08:00) Perth`,
        `(UTC+08:00) Taipei`,
        `(UTC+08:00) Ulaanbaatar`,
        `(UTC+08:45) Eucla`,
        `(UTC+09:00) Chita`,
        `(UTC+09:00) Osaka, Sapporo, Tokyo`,
        `(UTC+09:00) Pyongyang`,
        `(UTC+09:00) Seoul`,
        `(UTC+09:00) Yakutsk`,
        `(UTC+09:30) Adelaide`,
        `(UTC+09:30) Darwin`,
        `(UTC+10:00) Brisbane`,
        `(UTC+10:00) Canberra, Melbourne, Sydney`,
        `(UTC+10:00) Guam, Port Moresby`,
        `(UTC+10:00) Hobart`,
        `(UTC+10:00) Vladivostok`,
        `(UTC+10:30) Lord Howe Island`,
        `(UTC+11:00) Bougainville Island`,
        `(UTC+11:00) Chokurdakh`,
        `(UTC+11:00) Magadan`,
        `(UTC+11:00) Norfolk Island`,
        `(UTC+11:00) Sakhalin`,
        `(UTC+11:00) Solomon Is., New Caledonia`,
        `(UTC+12:00) Anadyr, Petropavlovsk-Kamchatsky`,
        `(UTC+12:00) Auckland, Wellington`,
        `(UTC+12:00) Coordinated Universal Time+12`,
        `(UTC+12:00) Fiji`,
        `(UTC+12:00) Petropavlovsk-Kamchatsky - Old`,
        `(UTC+12:45) Chatham Islands`,
        `(UTC+13:00) Coordinated Universal Time+13`,
        `(UTC+13:00) Nuku'alofa`,
        `(UTC+13:00) Samoa`,
        `(UTC+14:00) Kiritimati Island`.
        """
        return pulumi.get(self, "time_zone")


@pulumi.output_type
class BuildDefinitionScheduleBranchFilter(dict):
    def __init__(__self__, *,
                 excludes: Optional[Sequence[_builtins.str]] = None,
                 includes: Optional[Sequence[_builtins.str]] = None):
        """
        :param Sequence[_builtins.str] excludes: List of branch patterns to exclude.
        :param Sequence[_builtins.str] includes: List of branch patterns to include.
        """
        if excludes is not None:
            pulumi.set(__self__, "excludes", excludes)
        if includes is not None:
            pulumi.set(__self__, "includes", includes)

    @_builtins.property
    @pulumi.getter
    def excludes(self) -> Optional[Sequence[_builtins.str]]:
        """
        List of branch patterns to exclude.
        """
        return pulumi.get(self, "excludes")

    @_builtins.property
    @pulumi.getter
    def includes(self) -> Optional[Sequence[_builtins.str]]:
        """
        List of branch patterns to include.
        """
        return pulumi.get(self, "includes")


@pulumi.output_type
class BuildDefinitionVariable(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "allowOverride":
            suggest = "allow_override"
        elif key == "isSecret":
            suggest = "is_secret"
        elif key == "secretValue":
            suggest = "secret_value"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in BuildDefinitionVariable. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        BuildDefinitionVariable.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        BuildDefinitionVariable.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 name: _builtins.str,
                 allow_override: Optional[_builtins.bool] = None,
                 is_secret: Optional[_builtins.bool] = None,
                 secret_value: Optional[_builtins.str] = None,
                 value: Optional[_builtins.str] = None):
        """
        :param _builtins.str name: The name of the variable.
        :param _builtins.bool allow_override: True if the variable can be overridden. Defaults to `true`.
        :param _builtins.bool is_secret: True if the variable is a secret. Defaults to `false`.
        :param _builtins.str secret_value: The secret value of the variable. Used when `is_secret` set to `true`.
        :param _builtins.str value: The value of the variable.
        """
        pulumi.set(__self__, "name", name)
        if allow_override is not None:
            pulumi.set(__self__, "allow_override", allow_override)
        if is_secret is not None:
            pulumi.set(__self__, "is_secret", is_secret)
        if secret_value is not None:
            pulumi.set(__self__, "secret_value", secret_value)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        The name of the variable.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter(name="allowOverride")
    def allow_override(self) -> Optional[_builtins.bool]:
        """
        True if the variable can be overridden. Defaults to `true`.
        """
        return pulumi.get(self, "allow_override")

    @_builtins.property
    @pulumi.getter(name="isSecret")
    def is_secret(self) -> Optional[_builtins.bool]:
        """
        True if the variable is a secret. Defaults to `false`.
        """
        return pulumi.get(self, "is_secret")

    @_builtins.property
    @pulumi.getter(name="secretValue")
    def secret_value(self) -> Optional[_builtins.str]:
        """
        The secret value of the variable. Used when `is_secret` set to `true`.
        """
        return pulumi.get(self, "secret_value")

    @_builtins.property
    @pulumi.getter
    def value(self) -> Optional[_builtins.str]:
        """
        The value of the variable.
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class CheckRequiredTemplateRequiredTemplate(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "repositoryName":
            suggest = "repository_name"
        elif key == "repositoryRef":
            suggest = "repository_ref"
        elif key == "templatePath":
            suggest = "template_path"
        elif key == "repositoryType":
            suggest = "repository_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in CheckRequiredTemplateRequiredTemplate. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        CheckRequiredTemplateRequiredTemplate.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        CheckRequiredTemplateRequiredTemplate.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 repository_name: _builtins.str,
                 repository_ref: _builtins.str,
                 template_path: _builtins.str,
                 repository_type: Optional[_builtins.str] = None):
        """
        :param _builtins.str repository_name: The name of the repository storing the template.
        :param _builtins.str repository_ref: The branch in which the template will be referenced.
        :param _builtins.str template_path: The path to the template yaml.
        :param _builtins.str repository_type: The type of the repository storing the template. Possible values are: `azuregit`, `github`, `githubenterprise`, `bitbucket`. Defaults to `azuregit`.
        """
        pulumi.set(__self__, "repository_name", repository_name)
        pulumi.set(__self__, "repository_ref", repository_ref)
        pulumi.set(__self__, "template_path", template_path)
        if repository_type is not None:
            pulumi.set(__self__, "repository_type", repository_type)

    @_builtins.property
    @pulumi.getter(name="repositoryName")
    def repository_name(self) -> _builtins.str:
        """
        The name of the repository storing the template.
        """
        return pulumi.get(self, "repository_name")

    @_builtins.property
    @pulumi.getter(name="repositoryRef")
    def repository_ref(self) -> _builtins.str:
        """
        The branch in which the template will be referenced.
        """
        return pulumi.get(self, "repository_ref")

    @_builtins.property
    @pulumi.getter(name="templatePath")
    def template_path(self) -> _builtins.str:
        """
        The path to the template yaml.
        """
        return pulumi.get(self, "template_path")

    @_builtins.property
    @pulumi.getter(name="repositoryType")
    def repository_type(self) -> Optional[_builtins.str]:
        """
        The type of the repository storing the template. Possible values are: `azuregit`, `github`, `githubenterprise`, `bitbucket`. Defaults to `azuregit`.
        """
        return pulumi.get(self, "repository_type")


@pulumi.output_type
class FeedFeature(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "permanentDelete":
            suggest = "permanent_delete"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in FeedFeature. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        FeedFeature.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        FeedFeature.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 permanent_delete: Optional[_builtins.bool] = None,
                 restore: Optional[_builtins.bool] = None):
        """
        :param _builtins.bool permanent_delete: Determines if Feed should be Permanently removed, Defaults to `false`
        :param _builtins.bool restore: Determines if Feed should be Restored during creation (if possible), Defaults to `false`
        """
        if permanent_delete is not None:
            pulumi.set(__self__, "permanent_delete", permanent_delete)
        if restore is not None:
            pulumi.set(__self__, "restore", restore)

    @_builtins.property
    @pulumi.getter(name="permanentDelete")
    def permanent_delete(self) -> Optional[_builtins.bool]:
        """
        Determines if Feed should be Permanently removed, Defaults to `false`
        """
        return pulumi.get(self, "permanent_delete")

    @_builtins.property
    @pulumi.getter
    def restore(self) -> Optional[_builtins.bool]:
        """
        Determines if Feed should be Restored during creation (if possible), Defaults to `false`
        """
        return pulumi.get(self, "restore")


@pulumi.output_type
class GitInitialization(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "initType":
            suggest = "init_type"
        elif key == "serviceConnectionId":
            suggest = "service_connection_id"
        elif key == "sourceType":
            suggest = "source_type"
        elif key == "sourceUrl":
            suggest = "source_url"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in GitInitialization. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        GitInitialization.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        GitInitialization.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 init_type: _builtins.str,
                 password: Optional[_builtins.str] = None,
                 service_connection_id: Optional[_builtins.str] = None,
                 source_type: Optional[_builtins.str] = None,
                 source_url: Optional[_builtins.str] = None,
                 username: Optional[_builtins.str] = None):
        """
        :param _builtins.str init_type: The type of repository to create. Valid values: `Uninitialized`, `Clean` or `Import`.
        :param _builtins.str password: **NOTE:** This field is write-only and its value will not be updated in state as part of read operations.
               The password used to authenticate to a private repository for import initialization. Conflicts with `service_connection_id`. Note: This is a write-only attribute, which allows ephemeral resources to be used.
               
               ~>**Note** At least `service_connection_id` or `username/password` needs to be set to import private repository.
        :param _builtins.str service_connection_id: The ID of service connection used to authenticate to a private repository for import initialization. Conflicts with `username` and `password`.
        :param _builtins.str source_type: Type of the source repository. Used if the `init_type` is `Import`. Valid values: `Git`.
        :param _builtins.str source_url: The URL of the source repository. Used if the `init_type` is `Import`.
        :param _builtins.str username: The username used to authenticate to a private repository for import initialization. Conflicts with `service_connection_id`.
        """
        pulumi.set(__self__, "init_type", init_type)
        if password is not None:
            pulumi.set(__self__, "password", password)
        if service_connection_id is not None:
            pulumi.set(__self__, "service_connection_id", service_connection_id)
        if source_type is not None:
            pulumi.set(__self__, "source_type", source_type)
        if source_url is not None:
            pulumi.set(__self__, "source_url", source_url)
        if username is not None:
            pulumi.set(__self__, "username", username)

    @_builtins.property
    @pulumi.getter(name="initType")
    def init_type(self) -> _builtins.str:
        """
        The type of repository to create. Valid values: `Uninitialized`, `Clean` or `Import`.
        """
        return pulumi.get(self, "init_type")

    @_builtins.property
    @pulumi.getter
    def password(self) -> Optional[_builtins.str]:
        """
        **NOTE:** This field is write-only and its value will not be updated in state as part of read operations.
        The password used to authenticate to a private repository for import initialization. Conflicts with `service_connection_id`. Note: This is a write-only attribute, which allows ephemeral resources to be used.

        ~>**Note** At least `service_connection_id` or `username/password` needs to be set to import private repository.
        """
        return pulumi.get(self, "password")

    @_builtins.property
    @pulumi.getter(name="serviceConnectionId")
    def service_connection_id(self) -> Optional[_builtins.str]:
        """
        The ID of service connection used to authenticate to a private repository for import initialization. Conflicts with `username` and `password`.
        """
        return pulumi.get(self, "service_connection_id")

    @_builtins.property
    @pulumi.getter(name="sourceType")
    def source_type(self) -> Optional[_builtins.str]:
        """
        Type of the source repository. Used if the `init_type` is `Import`. Valid values: `Git`.
        """
        return pulumi.get(self, "source_type")

    @_builtins.property
    @pulumi.getter(name="sourceUrl")
    def source_url(self) -> Optional[_builtins.str]:
        """
        The URL of the source repository. Used if the `init_type` is `Import`.
        """
        return pulumi.get(self, "source_url")

    @_builtins.property
    @pulumi.getter
    def username(self) -> Optional[_builtins.str]:
        """
        The username used to authenticate to a private repository for import initialization. Conflicts with `service_connection_id`.
        """
        return pulumi.get(self, "username")


@pulumi.output_type
class ServiceEndpointArtifactoryAuthenticationBasic(dict):
    def __init__(__self__, *,
                 password: _builtins.str,
                 username: _builtins.str):
        """
        :param _builtins.str password: The Password of the Artifactory.
        :param _builtins.str username: The Username of the Artifactory.
        """
        pulumi.set(__self__, "password", password)
        pulumi.set(__self__, "username", username)

    @_builtins.property
    @pulumi.getter
    def password(self) -> _builtins.str:
        """
        The Password of the Artifactory.
        """
        return pulumi.get(self, "password")

    @_builtins.property
    @pulumi.getter
    def username(self) -> _builtins.str:
        """
        The Username of the Artifactory.
        """
        return pulumi.get(self, "username")


@pulumi.output_type
class ServiceEndpointArtifactoryAuthenticationToken(dict):
    def __init__(__self__, *,
                 token: _builtins.str):
        """
        :param _builtins.str token: Authentication Token generated through Artifactory.
        """
        pulumi.set(__self__, "token", token)

    @_builtins.property
    @pulumi.getter
    def token(self) -> _builtins.str:
        """
        Authentication Token generated through Artifactory.
        """
        return pulumi.get(self, "token")


@pulumi.output_type
class ServiceEndpointAzureEcrCredentials(dict):
    def __init__(__self__, *,
                 serviceprincipalid: _builtins.str):
        """
        :param _builtins.str serviceprincipalid: The ID of the Service Principal Application.
        """
        pulumi.set(__self__, "serviceprincipalid", serviceprincipalid)

    @_builtins.property
    @pulumi.getter
    def serviceprincipalid(self) -> _builtins.str:
        """
        The ID of the Service Principal Application.
        """
        return pulumi.get(self, "serviceprincipalid")


@pulumi.output_type
class ServiceEndpointAzureRMCredentials(dict):
    def __init__(__self__, *,
                 serviceprincipalid: _builtins.str,
                 serviceprincipalcertificate: Optional[_builtins.str] = None,
                 serviceprincipalkey: Optional[_builtins.str] = None):
        """
        :param _builtins.str serviceprincipalid: The service principal application ID
        :param _builtins.str serviceprincipalcertificate: The service principal certificate. This not required if `service_endpoint_authentication_scheme` is set to `WorkloadIdentityFederation`.
        :param _builtins.str serviceprincipalkey: The service principal secret. This not required if `service_endpoint_authentication_scheme` is set to `WorkloadIdentityFederation`.
        """
        pulumi.set(__self__, "serviceprincipalid", serviceprincipalid)
        if serviceprincipalcertificate is not None:
            pulumi.set(__self__, "serviceprincipalcertificate", serviceprincipalcertificate)
        if serviceprincipalkey is not None:
            pulumi.set(__self__, "serviceprincipalkey", serviceprincipalkey)

    @_builtins.property
    @pulumi.getter
    def serviceprincipalid(self) -> _builtins.str:
        """
        The service principal application ID
        """
        return pulumi.get(self, "serviceprincipalid")

    @_builtins.property
    @pulumi.getter
    def serviceprincipalcertificate(self) -> Optional[_builtins.str]:
        """
        The service principal certificate. This not required if `service_endpoint_authentication_scheme` is set to `WorkloadIdentityFederation`.
        """
        return pulumi.get(self, "serviceprincipalcertificate")

    @_builtins.property
    @pulumi.getter
    def serviceprincipalkey(self) -> Optional[_builtins.str]:
        """
        The service principal secret. This not required if `service_endpoint_authentication_scheme` is set to `WorkloadIdentityFederation`.
        """
        return pulumi.get(self, "serviceprincipalkey")


@pulumi.output_type
class ServiceEndpointAzureRMFeatures(dict):
    def __init__(__self__, *,
                 validate: Optional[_builtins.bool] = None):
        """
        :param _builtins.bool validate: Whether or not to validate connection with Azure after create or update operations. Defaults to `false`
        """
        if validate is not None:
            pulumi.set(__self__, "validate", validate)

    @_builtins.property
    @pulumi.getter
    def validate(self) -> Optional[_builtins.bool]:
        """
        Whether or not to validate connection with Azure after create or update operations. Defaults to `false`
        """
        return pulumi.get(self, "validate")


@pulumi.output_type
class ServiceEndpointGitHubAuthOauth(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "oauthConfigurationId":
            suggest = "oauth_configuration_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ServiceEndpointGitHubAuthOauth. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ServiceEndpointGitHubAuthOauth.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ServiceEndpointGitHubAuthOauth.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 oauth_configuration_id: _builtins.str):
        pulumi.set(__self__, "oauth_configuration_id", oauth_configuration_id)

    @_builtins.property
    @pulumi.getter(name="oauthConfigurationId")
    def oauth_configuration_id(self) -> _builtins.str:
        return pulumi.get(self, "oauth_configuration_id")


@pulumi.output_type
class ServiceEndpointGitHubAuthPersonal(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "personalAccessToken":
            suggest = "personal_access_token"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ServiceEndpointGitHubAuthPersonal. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ServiceEndpointGitHubAuthPersonal.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ServiceEndpointGitHubAuthPersonal.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 personal_access_token: _builtins.str):
        """
        :param _builtins.str personal_access_token: The Personal Access Token for GitHub.
        """
        pulumi.set(__self__, "personal_access_token", personal_access_token)

    @_builtins.property
    @pulumi.getter(name="personalAccessToken")
    def personal_access_token(self) -> _builtins.str:
        """
        The Personal Access Token for GitHub.
        """
        return pulumi.get(self, "personal_access_token")


@pulumi.output_type
class ServiceEndpointGitHubEnterpriseAuthOauth(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "oauthConfigurationId":
            suggest = "oauth_configuration_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ServiceEndpointGitHubEnterpriseAuthOauth. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ServiceEndpointGitHubEnterpriseAuthOauth.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ServiceEndpointGitHubEnterpriseAuthOauth.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 oauth_configuration_id: _builtins.str):
        """
        :param _builtins.str oauth_configuration_id: The OAuth Configuration ID.
        """
        pulumi.set(__self__, "oauth_configuration_id", oauth_configuration_id)

    @_builtins.property
    @pulumi.getter(name="oauthConfigurationId")
    def oauth_configuration_id(self) -> _builtins.str:
        """
        The OAuth Configuration ID.
        """
        return pulumi.get(self, "oauth_configuration_id")


@pulumi.output_type
class ServiceEndpointGitHubEnterpriseAuthPersonal(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "personalAccessToken":
            suggest = "personal_access_token"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ServiceEndpointGitHubEnterpriseAuthPersonal. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ServiceEndpointGitHubEnterpriseAuthPersonal.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ServiceEndpointGitHubEnterpriseAuthPersonal.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 personal_access_token: _builtins.str):
        """
        :param _builtins.str personal_access_token: The Personal Access Token for GitHub.
        """
        pulumi.set(__self__, "personal_access_token", personal_access_token)

    @_builtins.property
    @pulumi.getter(name="personalAccessToken")
    def personal_access_token(self) -> _builtins.str:
        """
        The Personal Access Token for GitHub.
        """
        return pulumi.get(self, "personal_access_token")


@pulumi.output_type
class ServiceEndpointKubernetesAzureSubscription(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "clusterName":
            suggest = "cluster_name"
        elif key == "resourcegroupId":
            suggest = "resourcegroup_id"
        elif key == "subscriptionId":
            suggest = "subscription_id"
        elif key == "subscriptionName":
            suggest = "subscription_name"
        elif key == "tenantId":
            suggest = "tenant_id"
        elif key == "azureEnvironment":
            suggest = "azure_environment"
        elif key == "clusterAdmin":
            suggest = "cluster_admin"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ServiceEndpointKubernetesAzureSubscription. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ServiceEndpointKubernetesAzureSubscription.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ServiceEndpointKubernetesAzureSubscription.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 cluster_name: _builtins.str,
                 resourcegroup_id: _builtins.str,
                 subscription_id: _builtins.str,
                 subscription_name: _builtins.str,
                 tenant_id: _builtins.str,
                 azure_environment: Optional[_builtins.str] = None,
                 cluster_admin: Optional[_builtins.bool] = None,
                 namespace: Optional[_builtins.str] = None):
        """
        :param _builtins.str cluster_name: The name of the Kubernetes cluster.
        :param _builtins.str resourcegroup_id: The resource group name, to which the Kubernetes cluster is deployed.
        :param _builtins.str subscription_id: The id of the Azure subscription.
        :param _builtins.str subscription_name: The name of the Azure subscription.
        :param _builtins.str tenant_id: The id of the tenant used by the subscription.
        :param _builtins.str azure_environment: Azure environment refers to whether the public cloud offering or domestic (government) clouds are being used. Currently, only the public cloud is supported. The value must be AzureCloud. This is also the default-value.
        :param _builtins.bool cluster_admin: Set this option to allow use cluster admin credentials.
        :param _builtins.str namespace: The Kubernetes namespace. Default value is "default".
        """
        pulumi.set(__self__, "cluster_name", cluster_name)
        pulumi.set(__self__, "resourcegroup_id", resourcegroup_id)
        pulumi.set(__self__, "subscription_id", subscription_id)
        pulumi.set(__self__, "subscription_name", subscription_name)
        pulumi.set(__self__, "tenant_id", tenant_id)
        if azure_environment is not None:
            pulumi.set(__self__, "azure_environment", azure_environment)
        if cluster_admin is not None:
            pulumi.set(__self__, "cluster_admin", cluster_admin)
        if namespace is not None:
            pulumi.set(__self__, "namespace", namespace)

    @_builtins.property
    @pulumi.getter(name="clusterName")
    def cluster_name(self) -> _builtins.str:
        """
        The name of the Kubernetes cluster.
        """
        return pulumi.get(self, "cluster_name")

    @_builtins.property
    @pulumi.getter(name="resourcegroupId")
    def resourcegroup_id(self) -> _builtins.str:
        """
        The resource group name, to which the Kubernetes cluster is deployed.
        """
        return pulumi.get(self, "resourcegroup_id")

    @_builtins.property
    @pulumi.getter(name="subscriptionId")
    def subscription_id(self) -> _builtins.str:
        """
        The id of the Azure subscription.
        """
        return pulumi.get(self, "subscription_id")

    @_builtins.property
    @pulumi.getter(name="subscriptionName")
    def subscription_name(self) -> _builtins.str:
        """
        The name of the Azure subscription.
        """
        return pulumi.get(self, "subscription_name")

    @_builtins.property
    @pulumi.getter(name="tenantId")
    def tenant_id(self) -> _builtins.str:
        """
        The id of the tenant used by the subscription.
        """
        return pulumi.get(self, "tenant_id")

    @_builtins.property
    @pulumi.getter(name="azureEnvironment")
    def azure_environment(self) -> Optional[_builtins.str]:
        """
        Azure environment refers to whether the public cloud offering or domestic (government) clouds are being used. Currently, only the public cloud is supported. The value must be AzureCloud. This is also the default-value.
        """
        return pulumi.get(self, "azure_environment")

    @_builtins.property
    @pulumi.getter(name="clusterAdmin")
    def cluster_admin(self) -> Optional[_builtins.bool]:
        """
        Set this option to allow use cluster admin credentials.
        """
        return pulumi.get(self, "cluster_admin")

    @_builtins.property
    @pulumi.getter
    def namespace(self) -> Optional[_builtins.str]:
        """
        The Kubernetes namespace. Default value is "default".
        """
        return pulumi.get(self, "namespace")


@pulumi.output_type
class ServiceEndpointKubernetesKubeconfig(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "kubeConfig":
            suggest = "kube_config"
        elif key == "acceptUntrustedCerts":
            suggest = "accept_untrusted_certs"
        elif key == "clusterContext":
            suggest = "cluster_context"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ServiceEndpointKubernetesKubeconfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ServiceEndpointKubernetesKubeconfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ServiceEndpointKubernetesKubeconfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 kube_config: _builtins.str,
                 accept_untrusted_certs: Optional[_builtins.bool] = None,
                 cluster_context: Optional[_builtins.str] = None):
        """
        :param _builtins.str kube_config: The content of the kubeconfig in yaml notation to be used to communicate with the API-Server of Kubernetes.
        :param _builtins.bool accept_untrusted_certs: Set this option to allow clients to accept a self-signed certificate.
        :param _builtins.str cluster_context: Context within the kubeconfig file that is to be used for identifying the cluster. Default value is the current-context set in kubeconfig.
        """
        pulumi.set(__self__, "kube_config", kube_config)
        if accept_untrusted_certs is not None:
            pulumi.set(__self__, "accept_untrusted_certs", accept_untrusted_certs)
        if cluster_context is not None:
            pulumi.set(__self__, "cluster_context", cluster_context)

    @_builtins.property
    @pulumi.getter(name="kubeConfig")
    def kube_config(self) -> _builtins.str:
        """
        The content of the kubeconfig in yaml notation to be used to communicate with the API-Server of Kubernetes.
        """
        return pulumi.get(self, "kube_config")

    @_builtins.property
    @pulumi.getter(name="acceptUntrustedCerts")
    def accept_untrusted_certs(self) -> Optional[_builtins.bool]:
        """
        Set this option to allow clients to accept a self-signed certificate.
        """
        return pulumi.get(self, "accept_untrusted_certs")

    @_builtins.property
    @pulumi.getter(name="clusterContext")
    def cluster_context(self) -> Optional[_builtins.str]:
        """
        Context within the kubeconfig file that is to be used for identifying the cluster. Default value is the current-context set in kubeconfig.
        """
        return pulumi.get(self, "cluster_context")


@pulumi.output_type
class ServiceEndpointKubernetesServiceAccount(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "caCert":
            suggest = "ca_cert"
        elif key == "acceptUntrustedCerts":
            suggest = "accept_untrusted_certs"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ServiceEndpointKubernetesServiceAccount. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ServiceEndpointKubernetesServiceAccount.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ServiceEndpointKubernetesServiceAccount.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 ca_cert: _builtins.str,
                 token: _builtins.str,
                 accept_untrusted_certs: Optional[_builtins.bool] = None):
        """
        :param _builtins.str ca_cert: The certificate from a Kubernetes secret object.
        :param _builtins.str token: The token from a Kubernetes secret object.
        :param _builtins.bool accept_untrusted_certs: Set this option to allow clients to accept a self-signed certificate. Defaults to `false`.
        """
        pulumi.set(__self__, "ca_cert", ca_cert)
        pulumi.set(__self__, "token", token)
        if accept_untrusted_certs is not None:
            pulumi.set(__self__, "accept_untrusted_certs", accept_untrusted_certs)

    @_builtins.property
    @pulumi.getter(name="caCert")
    def ca_cert(self) -> _builtins.str:
        """
        The certificate from a Kubernetes secret object.
        """
        return pulumi.get(self, "ca_cert")

    @_builtins.property
    @pulumi.getter
    def token(self) -> _builtins.str:
        """
        The token from a Kubernetes secret object.
        """
        return pulumi.get(self, "token")

    @_builtins.property
    @pulumi.getter(name="acceptUntrustedCerts")
    def accept_untrusted_certs(self) -> Optional[_builtins.bool]:
        """
        Set this option to allow clients to accept a self-signed certificate. Defaults to `false`.
        """
        return pulumi.get(self, "accept_untrusted_certs")


@pulumi.output_type
class ServiceEndpointPipelineAuthPersonal(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "personalAccessToken":
            suggest = "personal_access_token"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ServiceEndpointPipelineAuthPersonal. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ServiceEndpointPipelineAuthPersonal.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ServiceEndpointPipelineAuthPersonal.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 personal_access_token: _builtins.str):
        """
        :param _builtins.str personal_access_token: The Personal Access Token for Azure DevOps Pipeline. It also can be set with AZDO_PERSONAL_ACCESS_TOKEN environment variable.
        """
        pulumi.set(__self__, "personal_access_token", personal_access_token)

    @_builtins.property
    @pulumi.getter(name="personalAccessToken")
    def personal_access_token(self) -> _builtins.str:
        """
        The Personal Access Token for Azure DevOps Pipeline. It also can be set with AZDO_PERSONAL_ACCESS_TOKEN environment variable.
        """
        return pulumi.get(self, "personal_access_token")


@pulumi.output_type
class ServiceEndpointServiceFabricAzureActiveDirectory(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "serverCertificateLookup":
            suggest = "server_certificate_lookup"
        elif key == "serverCertificateCommonName":
            suggest = "server_certificate_common_name"
        elif key == "serverCertificateThumbprint":
            suggest = "server_certificate_thumbprint"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ServiceEndpointServiceFabricAzureActiveDirectory. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ServiceEndpointServiceFabricAzureActiveDirectory.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ServiceEndpointServiceFabricAzureActiveDirectory.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 password: _builtins.str,
                 server_certificate_lookup: _builtins.str,
                 username: _builtins.str,
                 server_certificate_common_name: Optional[_builtins.str] = None,
                 server_certificate_thumbprint: Optional[_builtins.str] = None):
        """
        :param _builtins.str password: Password for the Azure Active Directory account.
        :param _builtins.str server_certificate_lookup: Verification mode for the cluster. Possible values are: `Thumbprint`, `CommonName`.
        :param _builtins.str username: Specify an Azure Active Directory account.
        :param _builtins.str server_certificate_common_name: The common name(s) of the cluster's certificate(s). This is used to verify the identity of the cluster. This value overrides the publish profile. Separate multiple common names with a comma (',')
        :param _builtins.str server_certificate_thumbprint: The thumbprint(s) of the cluster's certificate(s). This is used to verify the identity of the cluster. This value overrides the publish profile. Separate multiple thumbprints with a comma (',')
        """
        pulumi.set(__self__, "password", password)
        pulumi.set(__self__, "server_certificate_lookup", server_certificate_lookup)
        pulumi.set(__self__, "username", username)
        if server_certificate_common_name is not None:
            pulumi.set(__self__, "server_certificate_common_name", server_certificate_common_name)
        if server_certificate_thumbprint is not None:
            pulumi.set(__self__, "server_certificate_thumbprint", server_certificate_thumbprint)

    @_builtins.property
    @pulumi.getter
    def password(self) -> _builtins.str:
        """
        Password for the Azure Active Directory account.
        """
        return pulumi.get(self, "password")

    @_builtins.property
    @pulumi.getter(name="serverCertificateLookup")
    def server_certificate_lookup(self) -> _builtins.str:
        """
        Verification mode for the cluster. Possible values are: `Thumbprint`, `CommonName`.
        """
        return pulumi.get(self, "server_certificate_lookup")

    @_builtins.property
    @pulumi.getter
    def username(self) -> _builtins.str:
        """
        Specify an Azure Active Directory account.
        """
        return pulumi.get(self, "username")

    @_builtins.property
    @pulumi.getter(name="serverCertificateCommonName")
    def server_certificate_common_name(self) -> Optional[_builtins.str]:
        """
        The common name(s) of the cluster's certificate(s). This is used to verify the identity of the cluster. This value overrides the publish profile. Separate multiple common names with a comma (',')
        """
        return pulumi.get(self, "server_certificate_common_name")

    @_builtins.property
    @pulumi.getter(name="serverCertificateThumbprint")
    def server_certificate_thumbprint(self) -> Optional[_builtins.str]:
        """
        The thumbprint(s) of the cluster's certificate(s). This is used to verify the identity of the cluster. This value overrides the publish profile. Separate multiple thumbprints with a comma (',')
        """
        return pulumi.get(self, "server_certificate_thumbprint")


@pulumi.output_type
class ServiceEndpointServiceFabricCertificate(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "clientCertificate":
            suggest = "client_certificate"
        elif key == "serverCertificateLookup":
            suggest = "server_certificate_lookup"
        elif key == "clientCertificatePassword":
            suggest = "client_certificate_password"
        elif key == "serverCertificateCommonName":
            suggest = "server_certificate_common_name"
        elif key == "serverCertificateThumbprint":
            suggest = "server_certificate_thumbprint"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ServiceEndpointServiceFabricCertificate. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ServiceEndpointServiceFabricCertificate.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ServiceEndpointServiceFabricCertificate.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 client_certificate: _builtins.str,
                 server_certificate_lookup: _builtins.str,
                 client_certificate_password: Optional[_builtins.str] = None,
                 server_certificate_common_name: Optional[_builtins.str] = None,
                 server_certificate_thumbprint: Optional[_builtins.str] = None):
        """
        :param _builtins.str client_certificate: Base64 encoding of the cluster's client certificate file.
        :param _builtins.str server_certificate_lookup: Verification mode for the cluster. Possible values are: `Thumbprint`, `CommonName`.
        :param _builtins.str client_certificate_password: Password for the certificate.
        :param _builtins.str server_certificate_common_name: The common name(s) of the cluster's certificate(s). This is used to verify the identity of the cluster. This value overrides the publish profile. Separate multiple common names with a comma (',')
        :param _builtins.str server_certificate_thumbprint: The thumbprint(s) of the cluster's certificate(s). This is used to verify the identity of the cluster. This value overrides the publish profile. Separate multiple thumbprints with a comma (',')
        """
        pulumi.set(__self__, "client_certificate", client_certificate)
        pulumi.set(__self__, "server_certificate_lookup", server_certificate_lookup)
        if client_certificate_password is not None:
            pulumi.set(__self__, "client_certificate_password", client_certificate_password)
        if server_certificate_common_name is not None:
            pulumi.set(__self__, "server_certificate_common_name", server_certificate_common_name)
        if server_certificate_thumbprint is not None:
            pulumi.set(__self__, "server_certificate_thumbprint", server_certificate_thumbprint)

    @_builtins.property
    @pulumi.getter(name="clientCertificate")
    def client_certificate(self) -> _builtins.str:
        """
        Base64 encoding of the cluster's client certificate file.
        """
        return pulumi.get(self, "client_certificate")

    @_builtins.property
    @pulumi.getter(name="serverCertificateLookup")
    def server_certificate_lookup(self) -> _builtins.str:
        """
        Verification mode for the cluster. Possible values are: `Thumbprint`, `CommonName`.
        """
        return pulumi.get(self, "server_certificate_lookup")

    @_builtins.property
    @pulumi.getter(name="clientCertificatePassword")
    def client_certificate_password(self) -> Optional[_builtins.str]:
        """
        Password for the certificate.
        """
        return pulumi.get(self, "client_certificate_password")

    @_builtins.property
    @pulumi.getter(name="serverCertificateCommonName")
    def server_certificate_common_name(self) -> Optional[_builtins.str]:
        """
        The common name(s) of the cluster's certificate(s). This is used to verify the identity of the cluster. This value overrides the publish profile. Separate multiple common names with a comma (',')
        """
        return pulumi.get(self, "server_certificate_common_name")

    @_builtins.property
    @pulumi.getter(name="serverCertificateThumbprint")
    def server_certificate_thumbprint(self) -> Optional[_builtins.str]:
        """
        The thumbprint(s) of the cluster's certificate(s). This is used to verify the identity of the cluster. This value overrides the publish profile. Separate multiple thumbprints with a comma (',')
        """
        return pulumi.get(self, "server_certificate_thumbprint")


@pulumi.output_type
class ServiceEndpointServiceFabricNone(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "clusterSpn":
            suggest = "cluster_spn"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ServiceEndpointServiceFabricNone. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ServiceEndpointServiceFabricNone.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ServiceEndpointServiceFabricNone.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 cluster_spn: Optional[_builtins.str] = None,
                 unsecured: Optional[_builtins.bool] = None):
        """
        :param _builtins.str cluster_spn: Fully qualified domain SPN for gMSA account. This is applicable only if `unsecured` option is disabled.
        :param _builtins.bool unsecured: Skip using windows security for authentication.
        """
        if cluster_spn is not None:
            pulumi.set(__self__, "cluster_spn", cluster_spn)
        if unsecured is not None:
            pulumi.set(__self__, "unsecured", unsecured)

    @_builtins.property
    @pulumi.getter(name="clusterSpn")
    def cluster_spn(self) -> Optional[_builtins.str]:
        """
        Fully qualified domain SPN for gMSA account. This is applicable only if `unsecured` option is disabled.
        """
        return pulumi.get(self, "cluster_spn")

    @_builtins.property
    @pulumi.getter
    def unsecured(self) -> Optional[_builtins.bool]:
        """
        Skip using windows security for authentication.
        """
        return pulumi.get(self, "unsecured")


@pulumi.output_type
class ServiceendpointArgocdAuthenticationBasic(dict):
    def __init__(__self__, *,
                 password: _builtins.str,
                 username: _builtins.str):
        """
        :param _builtins.str password: The Password of the ArgoCD.
        :param _builtins.str username: The Username of the ArgoCD.
        """
        pulumi.set(__self__, "password", password)
        pulumi.set(__self__, "username", username)

    @_builtins.property
    @pulumi.getter
    def password(self) -> _builtins.str:
        """
        The Password of the ArgoCD.
        """
        return pulumi.get(self, "password")

    @_builtins.property
    @pulumi.getter
    def username(self) -> _builtins.str:
        """
        The Username of the ArgoCD.
        """
        return pulumi.get(self, "username")


@pulumi.output_type
class ServiceendpointArgocdAuthenticationToken(dict):
    def __init__(__self__, *,
                 token: _builtins.str):
        """
        :param _builtins.str token: Authentication Token generated through ArgoCD.
        """
        pulumi.set(__self__, "token", token)

    @_builtins.property
    @pulumi.getter
    def token(self) -> _builtins.str:
        """
        Authentication Token generated through ArgoCD.
        """
        return pulumi.get(self, "token")


@pulumi.output_type
class ServiceendpointExternaltfsAuthPersonal(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "personalAccessToken":
            suggest = "personal_access_token"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ServiceendpointExternaltfsAuthPersonal. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ServiceendpointExternaltfsAuthPersonal.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ServiceendpointExternaltfsAuthPersonal.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 personal_access_token: _builtins.str):
        """
        :param _builtins.str personal_access_token: The Personal Access Token for Azure DevOps Organization.
        """
        pulumi.set(__self__, "personal_access_token", personal_access_token)

    @_builtins.property
    @pulumi.getter(name="personalAccessToken")
    def personal_access_token(self) -> _builtins.str:
        """
        The Personal Access Token for Azure DevOps Organization.
        """
        return pulumi.get(self, "personal_access_token")


@pulumi.output_type
class ServiceendpointJfrogArtifactoryV2AuthenticationBasic(dict):
    def __init__(__self__, *,
                 password: _builtins.str,
                 username: _builtins.str):
        """
        :param _builtins.str password: The Password of the Artifactory.
        :param _builtins.str username: The Username of the Artifactory.
        """
        pulumi.set(__self__, "password", password)
        pulumi.set(__self__, "username", username)

    @_builtins.property
    @pulumi.getter
    def password(self) -> _builtins.str:
        """
        The Password of the Artifactory.
        """
        return pulumi.get(self, "password")

    @_builtins.property
    @pulumi.getter
    def username(self) -> _builtins.str:
        """
        The Username of the Artifactory.
        """
        return pulumi.get(self, "username")


@pulumi.output_type
class ServiceendpointJfrogArtifactoryV2AuthenticationToken(dict):
    def __init__(__self__, *,
                 token: _builtins.str):
        """
        :param _builtins.str token: Authentication Token generated through Artifactory.
        """
        pulumi.set(__self__, "token", token)

    @_builtins.property
    @pulumi.getter
    def token(self) -> _builtins.str:
        """
        Authentication Token generated through Artifactory.
        """
        return pulumi.get(self, "token")


@pulumi.output_type
class ServiceendpointJfrogDistributionV2AuthenticationBasic(dict):
    def __init__(__self__, *,
                 password: _builtins.str,
                 username: _builtins.str):
        """
        :param _builtins.str password: The Password of the Artifactory.
        :param _builtins.str username: The Username of the Artifactory.
        """
        pulumi.set(__self__, "password", password)
        pulumi.set(__self__, "username", username)

    @_builtins.property
    @pulumi.getter
    def password(self) -> _builtins.str:
        """
        The Password of the Artifactory.
        """
        return pulumi.get(self, "password")

    @_builtins.property
    @pulumi.getter
    def username(self) -> _builtins.str:
        """
        The Username of the Artifactory.
        """
        return pulumi.get(self, "username")


@pulumi.output_type
class ServiceendpointJfrogDistributionV2AuthenticationToken(dict):
    def __init__(__self__, *,
                 token: _builtins.str):
        """
        :param _builtins.str token: The Authentication Token generated through Artifactory.
        """
        pulumi.set(__self__, "token", token)

    @_builtins.property
    @pulumi.getter
    def token(self) -> _builtins.str:
        """
        The Authentication Token generated through Artifactory.
        """
        return pulumi.get(self, "token")


@pulumi.output_type
class ServiceendpointJfrogPlatformV2AuthenticationBasic(dict):
    def __init__(__self__, *,
                 password: _builtins.str,
                 username: _builtins.str):
        """
        :param _builtins.str password: The Password of the Artifactory.
        :param _builtins.str username: The Username of the  Artifactory.
        """
        pulumi.set(__self__, "password", password)
        pulumi.set(__self__, "username", username)

    @_builtins.property
    @pulumi.getter
    def password(self) -> _builtins.str:
        """
        The Password of the Artifactory.
        """
        return pulumi.get(self, "password")

    @_builtins.property
    @pulumi.getter
    def username(self) -> _builtins.str:
        """
        The Username of the  Artifactory.
        """
        return pulumi.get(self, "username")


@pulumi.output_type
class ServiceendpointJfrogPlatformV2AuthenticationToken(dict):
    def __init__(__self__, *,
                 token: _builtins.str):
        """
        :param _builtins.str token: Authentication Token generated through Artifactory.
        """
        pulumi.set(__self__, "token", token)

    @_builtins.property
    @pulumi.getter
    def token(self) -> _builtins.str:
        """
        Authentication Token generated through Artifactory.
        """
        return pulumi.get(self, "token")


@pulumi.output_type
class ServiceendpointJfrogXrayV2AuthenticationBasic(dict):
    def __init__(__self__, *,
                 password: _builtins.str,
                 username: _builtins.str):
        """
        :param _builtins.str password: The Password of the Artifactory.
        :param _builtins.str username: The Username of the  Artifactory.
        """
        pulumi.set(__self__, "password", password)
        pulumi.set(__self__, "username", username)

    @_builtins.property
    @pulumi.getter
    def password(self) -> _builtins.str:
        """
        The Password of the Artifactory.
        """
        return pulumi.get(self, "password")

    @_builtins.property
    @pulumi.getter
    def username(self) -> _builtins.str:
        """
        The Username of the  Artifactory.
        """
        return pulumi.get(self, "username")


@pulumi.output_type
class ServiceendpointJfrogXrayV2AuthenticationToken(dict):
    def __init__(__self__, *,
                 token: _builtins.str):
        """
        :param _builtins.str token: Authentication Token generated through Artifactory.
        """
        pulumi.set(__self__, "token", token)

    @_builtins.property
    @pulumi.getter
    def token(self) -> _builtins.str:
        """
        Authentication Token generated through Artifactory.
        """
        return pulumi.get(self, "token")


@pulumi.output_type
class ServiceendpointMavenAuthenticationBasic(dict):
    def __init__(__self__, *,
                 password: _builtins.str,
                 username: _builtins.str):
        """
        :param _builtins.str password: The password Maven Repository.
        :param _builtins.str username: The Username of the Maven Repository.
        """
        pulumi.set(__self__, "password", password)
        pulumi.set(__self__, "username", username)

    @_builtins.property
    @pulumi.getter
    def password(self) -> _builtins.str:
        """
        The password Maven Repository.
        """
        return pulumi.get(self, "password")

    @_builtins.property
    @pulumi.getter
    def username(self) -> _builtins.str:
        """
        The Username of the Maven Repository.
        """
        return pulumi.get(self, "username")


@pulumi.output_type
class ServiceendpointMavenAuthenticationToken(dict):
    def __init__(__self__, *,
                 token: _builtins.str):
        """
        :param _builtins.str token: Authentication Token generated through maven repository.
        """
        pulumi.set(__self__, "token", token)

    @_builtins.property
    @pulumi.getter
    def token(self) -> _builtins.str:
        """
        Authentication Token generated through maven repository.
        """
        return pulumi.get(self, "token")


@pulumi.output_type
class ServiceendpointOpenshiftAuthBasic(dict):
    def __init__(__self__, *,
                 password: _builtins.str,
                 username: _builtins.str):
        """
        :param _builtins.str password: The password of the user.
        :param _builtins.str username: The name of the user.
        """
        pulumi.set(__self__, "password", password)
        pulumi.set(__self__, "username", username)

    @_builtins.property
    @pulumi.getter
    def password(self) -> _builtins.str:
        """
        The password of the user.
        """
        return pulumi.get(self, "password")

    @_builtins.property
    @pulumi.getter
    def username(self) -> _builtins.str:
        """
        The name of the user.
        """
        return pulumi.get(self, "username")


@pulumi.output_type
class ServiceendpointOpenshiftAuthNone(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "kubeConfig":
            suggest = "kube_config"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ServiceendpointOpenshiftAuthNone. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ServiceendpointOpenshiftAuthNone.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ServiceendpointOpenshiftAuthNone.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 kube_config: Optional[_builtins.str] = None):
        """
        :param _builtins.str kube_config: The kubectl config
        """
        if kube_config is not None:
            pulumi.set(__self__, "kube_config", kube_config)

    @_builtins.property
    @pulumi.getter(name="kubeConfig")
    def kube_config(self) -> Optional[_builtins.str]:
        """
        The kubectl config
        """
        return pulumi.get(self, "kube_config")


@pulumi.output_type
class ServiceendpointOpenshiftAuthToken(dict):
    def __init__(__self__, *,
                 token: _builtins.str):
        """
        :param _builtins.str token: The API token.
        """
        pulumi.set(__self__, "token", token)

    @_builtins.property
    @pulumi.getter
    def token(self) -> _builtins.str:
        """
        The API token.
        """
        return pulumi.get(self, "token")


@pulumi.output_type
class ServiceendpointVisualstudiomarketplaceAuthenticationBasic(dict):
    def __init__(__self__, *,
                 password: _builtins.str,
                 username: _builtins.str):
        """
        :param _builtins.str password: The password of the marketplace.
        :param _builtins.str username: The username of the marketplace.
        """
        pulumi.set(__self__, "password", password)
        pulumi.set(__self__, "username", username)

    @_builtins.property
    @pulumi.getter
    def password(self) -> _builtins.str:
        """
        The password of the marketplace.
        """
        return pulumi.get(self, "password")

    @_builtins.property
    @pulumi.getter
    def username(self) -> _builtins.str:
        """
        The username of the marketplace.
        """
        return pulumi.get(self, "username")


@pulumi.output_type
class ServiceendpointVisualstudiomarketplaceAuthenticationToken(dict):
    def __init__(__self__, *,
                 token: _builtins.str):
        """
        :param _builtins.str token: The Personal Access Token.
        """
        pulumi.set(__self__, "token", token)

    @_builtins.property
    @pulumi.getter
    def token(self) -> _builtins.str:
        """
        The Personal Access Token.
        """
        return pulumi.get(self, "token")


@pulumi.output_type
class ServicehookStorageQueuePipelinesRunStateChangedEvent(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "pipelineId":
            suggest = "pipeline_id"
        elif key == "runResultFilter":
            suggest = "run_result_filter"
        elif key == "runStateFilter":
            suggest = "run_state_filter"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ServicehookStorageQueuePipelinesRunStateChangedEvent. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ServicehookStorageQueuePipelinesRunStateChangedEvent.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ServicehookStorageQueuePipelinesRunStateChangedEvent.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 pipeline_id: Optional[_builtins.str] = None,
                 run_result_filter: Optional[_builtins.str] = None,
                 run_state_filter: Optional[_builtins.str] = None):
        """
        :param _builtins.str pipeline_id: The pipeline ID that will generate an event. If not specified, all pipelines in the project will trigger the event.
        :param _builtins.str run_result_filter: Which run result should generate an event. Only valid if published_event is `RunStateChanged`. If not specified, all results will trigger the event.
        :param _builtins.str run_state_filter: Which run state should generate an event. Only valid if published_event is `RunStateChanged`. If not specified, all states will trigger the event.
        """
        if pipeline_id is not None:
            pulumi.set(__self__, "pipeline_id", pipeline_id)
        if run_result_filter is not None:
            pulumi.set(__self__, "run_result_filter", run_result_filter)
        if run_state_filter is not None:
            pulumi.set(__self__, "run_state_filter", run_state_filter)

    @_builtins.property
    @pulumi.getter(name="pipelineId")
    def pipeline_id(self) -> Optional[_builtins.str]:
        """
        The pipeline ID that will generate an event. If not specified, all pipelines in the project will trigger the event.
        """
        return pulumi.get(self, "pipeline_id")

    @_builtins.property
    @pulumi.getter(name="runResultFilter")
    def run_result_filter(self) -> Optional[_builtins.str]:
        """
        Which run result should generate an event. Only valid if published_event is `RunStateChanged`. If not specified, all results will trigger the event.
        """
        return pulumi.get(self, "run_result_filter")

    @_builtins.property
    @pulumi.getter(name="runStateFilter")
    def run_state_filter(self) -> Optional[_builtins.str]:
        """
        Which run state should generate an event. Only valid if published_event is `RunStateChanged`. If not specified, all states will trigger the event.
        """
        return pulumi.get(self, "run_state_filter")


@pulumi.output_type
class ServicehookStorageQueuePipelinesStageStateChangedEvent(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "pipelineId":
            suggest = "pipeline_id"
        elif key == "stageName":
            suggest = "stage_name"
        elif key == "stageResultFilter":
            suggest = "stage_result_filter"
        elif key == "stageStateFilter":
            suggest = "stage_state_filter"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ServicehookStorageQueuePipelinesStageStateChangedEvent. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ServicehookStorageQueuePipelinesStageStateChangedEvent.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ServicehookStorageQueuePipelinesStageStateChangedEvent.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 pipeline_id: Optional[_builtins.str] = None,
                 stage_name: Optional[_builtins.str] = None,
                 stage_result_filter: Optional[_builtins.str] = None,
                 stage_state_filter: Optional[_builtins.str] = None):
        """
        :param _builtins.str pipeline_id: The pipeline ID that will generate an event.
        :param _builtins.str stage_name: Which stage should generate an event. Only valid if published_event is `StageStateChanged`. If not specified, all stages will trigger the event.
        :param _builtins.str stage_result_filter: Which stage result should generate an event. Only valid if published_event is `StageStateChanged`. If not specified, all results will trigger the event.
        :param _builtins.str stage_state_filter: Which stage state should generate an event. Only valid if published_event is `StageStateChanged`. If not specified, all states will trigger the event.
        """
        if pipeline_id is not None:
            pulumi.set(__self__, "pipeline_id", pipeline_id)
        if stage_name is not None:
            pulumi.set(__self__, "stage_name", stage_name)
        if stage_result_filter is not None:
            pulumi.set(__self__, "stage_result_filter", stage_result_filter)
        if stage_state_filter is not None:
            pulumi.set(__self__, "stage_state_filter", stage_state_filter)

    @_builtins.property
    @pulumi.getter(name="pipelineId")
    def pipeline_id(self) -> Optional[_builtins.str]:
        """
        The pipeline ID that will generate an event.
        """
        return pulumi.get(self, "pipeline_id")

    @_builtins.property
    @pulumi.getter(name="stageName")
    def stage_name(self) -> Optional[_builtins.str]:
        """
        Which stage should generate an event. Only valid if published_event is `StageStateChanged`. If not specified, all stages will trigger the event.
        """
        return pulumi.get(self, "stage_name")

    @_builtins.property
    @pulumi.getter(name="stageResultFilter")
    def stage_result_filter(self) -> Optional[_builtins.str]:
        """
        Which stage result should generate an event. Only valid if published_event is `StageStateChanged`. If not specified, all results will trigger the event.
        """
        return pulumi.get(self, "stage_result_filter")

    @_builtins.property
    @pulumi.getter(name="stageStateFilter")
    def stage_state_filter(self) -> Optional[_builtins.str]:
        """
        Which stage state should generate an event. Only valid if published_event is `StageStateChanged`. If not specified, all states will trigger the event.
        """
        return pulumi.get(self, "stage_state_filter")


@pulumi.output_type
class ServicehookWebhookTfsBuildCompleted(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "buildStatus":
            suggest = "build_status"
        elif key == "definitionName":
            suggest = "definition_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ServicehookWebhookTfsBuildCompleted. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ServicehookWebhookTfsBuildCompleted.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ServicehookWebhookTfsBuildCompleted.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 build_status: Optional[_builtins.str] = None,
                 definition_name: Optional[_builtins.str] = None):
        """
        :param _builtins.str build_status: Include only events for completed builds that have a specific completion status. Valid values: `Succeeded`, `PartiallySucceeded`, `Failed`, `Stopped`.
        :param _builtins.str definition_name: Include only events for completed builds for a specific pipeline.
        """
        if build_status is not None:
            pulumi.set(__self__, "build_status", build_status)
        if definition_name is not None:
            pulumi.set(__self__, "definition_name", definition_name)

    @_builtins.property
    @pulumi.getter(name="buildStatus")
    def build_status(self) -> Optional[_builtins.str]:
        """
        Include only events for completed builds that have a specific completion status. Valid values: `Succeeded`, `PartiallySucceeded`, `Failed`, `Stopped`.
        """
        return pulumi.get(self, "build_status")

    @_builtins.property
    @pulumi.getter(name="definitionName")
    def definition_name(self) -> Optional[_builtins.str]:
        """
        Include only events for completed builds for a specific pipeline.
        """
        return pulumi.get(self, "definition_name")


@pulumi.output_type
class ServicehookWebhookTfsGitPullRequestCommented(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "repositoryId":
            suggest = "repository_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ServicehookWebhookTfsGitPullRequestCommented. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ServicehookWebhookTfsGitPullRequestCommented.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ServicehookWebhookTfsGitPullRequestCommented.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 branch: Optional[_builtins.str] = None,
                 repository_id: Optional[_builtins.str] = None):
        """
        :param _builtins.str branch: Include only events for pull requests in a specific branch.
        :param _builtins.str repository_id: Include only events for pull requests in a specific repository (repository ID). If not specified, all repositories in the project will trigger the event.
        """
        if branch is not None:
            pulumi.set(__self__, "branch", branch)
        if repository_id is not None:
            pulumi.set(__self__, "repository_id", repository_id)

    @_builtins.property
    @pulumi.getter
    def branch(self) -> Optional[_builtins.str]:
        """
        Include only events for pull requests in a specific branch.
        """
        return pulumi.get(self, "branch")

    @_builtins.property
    @pulumi.getter(name="repositoryId")
    def repository_id(self) -> Optional[_builtins.str]:
        """
        Include only events for pull requests in a specific repository (repository ID). If not specified, all repositories in the project will trigger the event.
        """
        return pulumi.get(self, "repository_id")


@pulumi.output_type
class ServicehookWebhookTfsGitPullRequestCreated(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "pullRequestCreatedBy":
            suggest = "pull_request_created_by"
        elif key == "pullRequestReviewersContains":
            suggest = "pull_request_reviewers_contains"
        elif key == "repositoryId":
            suggest = "repository_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ServicehookWebhookTfsGitPullRequestCreated. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ServicehookWebhookTfsGitPullRequestCreated.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ServicehookWebhookTfsGitPullRequestCreated.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 branch: Optional[_builtins.str] = None,
                 pull_request_created_by: Optional[_builtins.str] = None,
                 pull_request_reviewers_contains: Optional[_builtins.str] = None,
                 repository_id: Optional[_builtins.str] = None):
        """
        :param _builtins.str branch: Include only events for pull requests in a specific branch.
        :param _builtins.str pull_request_created_by: Include only events for pull requests created by users in a specific group.
        :param _builtins.str pull_request_reviewers_contains: Include only events for pull requests with reviewers in a specific group.
        :param _builtins.str repository_id: Include only events for pull requests in a specific repository (repository ID). If not specified, all repositories in the project will trigger the event.
        """
        if branch is not None:
            pulumi.set(__self__, "branch", branch)
        if pull_request_created_by is not None:
            pulumi.set(__self__, "pull_request_created_by", pull_request_created_by)
        if pull_request_reviewers_contains is not None:
            pulumi.set(__self__, "pull_request_reviewers_contains", pull_request_reviewers_contains)
        if repository_id is not None:
            pulumi.set(__self__, "repository_id", repository_id)

    @_builtins.property
    @pulumi.getter
    def branch(self) -> Optional[_builtins.str]:
        """
        Include only events for pull requests in a specific branch.
        """
        return pulumi.get(self, "branch")

    @_builtins.property
    @pulumi.getter(name="pullRequestCreatedBy")
    def pull_request_created_by(self) -> Optional[_builtins.str]:
        """
        Include only events for pull requests created by users in a specific group.
        """
        return pulumi.get(self, "pull_request_created_by")

    @_builtins.property
    @pulumi.getter(name="pullRequestReviewersContains")
    def pull_request_reviewers_contains(self) -> Optional[_builtins.str]:
        """
        Include only events for pull requests with reviewers in a specific group.
        """
        return pulumi.get(self, "pull_request_reviewers_contains")

    @_builtins.property
    @pulumi.getter(name="repositoryId")
    def repository_id(self) -> Optional[_builtins.str]:
        """
        Include only events for pull requests in a specific repository (repository ID). If not specified, all repositories in the project will trigger the event.
        """
        return pulumi.get(self, "repository_id")


@pulumi.output_type
class ServicehookWebhookTfsGitPullRequestMergeAttempted(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "mergeResult":
            suggest = "merge_result"
        elif key == "pullRequestCreatedBy":
            suggest = "pull_request_created_by"
        elif key == "pullRequestReviewersContains":
            suggest = "pull_request_reviewers_contains"
        elif key == "repositoryId":
            suggest = "repository_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ServicehookWebhookTfsGitPullRequestMergeAttempted. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ServicehookWebhookTfsGitPullRequestMergeAttempted.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ServicehookWebhookTfsGitPullRequestMergeAttempted.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 branch: Optional[_builtins.str] = None,
                 merge_result: Optional[_builtins.str] = None,
                 pull_request_created_by: Optional[_builtins.str] = None,
                 pull_request_reviewers_contains: Optional[_builtins.str] = None,
                 repository_id: Optional[_builtins.str] = None):
        """
        :param _builtins.str branch: Include only events for pull requests in a specific branch.
        :param _builtins.str merge_result: Include only events for pull requests with a specific merge result. Valid values: `Succeeded`, `Unsuccessful`, `Conflicts`, `Failure`, `RejectedByPolicy`.
        :param _builtins.str pull_request_created_by: Include only events for pull requests created by users in a specific group.
        :param _builtins.str pull_request_reviewers_contains: Include only events for pull requests with reviewers in a specific group.
        :param _builtins.str repository_id: Include only events for pull requests in a specific repository (repository ID). If not specified, all repositories in the project will trigger the event.
        """
        if branch is not None:
            pulumi.set(__self__, "branch", branch)
        if merge_result is not None:
            pulumi.set(__self__, "merge_result", merge_result)
        if pull_request_created_by is not None:
            pulumi.set(__self__, "pull_request_created_by", pull_request_created_by)
        if pull_request_reviewers_contains is not None:
            pulumi.set(__self__, "pull_request_reviewers_contains", pull_request_reviewers_contains)
        if repository_id is not None:
            pulumi.set(__self__, "repository_id", repository_id)

    @_builtins.property
    @pulumi.getter
    def branch(self) -> Optional[_builtins.str]:
        """
        Include only events for pull requests in a specific branch.
        """
        return pulumi.get(self, "branch")

    @_builtins.property
    @pulumi.getter(name="mergeResult")
    def merge_result(self) -> Optional[_builtins.str]:
        """
        Include only events for pull requests with a specific merge result. Valid values: `Succeeded`, `Unsuccessful`, `Conflicts`, `Failure`, `RejectedByPolicy`.
        """
        return pulumi.get(self, "merge_result")

    @_builtins.property
    @pulumi.getter(name="pullRequestCreatedBy")
    def pull_request_created_by(self) -> Optional[_builtins.str]:
        """
        Include only events for pull requests created by users in a specific group.
        """
        return pulumi.get(self, "pull_request_created_by")

    @_builtins.property
    @pulumi.getter(name="pullRequestReviewersContains")
    def pull_request_reviewers_contains(self) -> Optional[_builtins.str]:
        """
        Include only events for pull requests with reviewers in a specific group.
        """
        return pulumi.get(self, "pull_request_reviewers_contains")

    @_builtins.property
    @pulumi.getter(name="repositoryId")
    def repository_id(self) -> Optional[_builtins.str]:
        """
        Include only events for pull requests in a specific repository (repository ID). If not specified, all repositories in the project will trigger the event.
        """
        return pulumi.get(self, "repository_id")


@pulumi.output_type
class ServicehookWebhookTfsGitPullRequestUpdated(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "notificationType":
            suggest = "notification_type"
        elif key == "pullRequestCreatedBy":
            suggest = "pull_request_created_by"
        elif key == "pullRequestReviewersContains":
            suggest = "pull_request_reviewers_contains"
        elif key == "repositoryId":
            suggest = "repository_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ServicehookWebhookTfsGitPullRequestUpdated. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ServicehookWebhookTfsGitPullRequestUpdated.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ServicehookWebhookTfsGitPullRequestUpdated.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 branch: Optional[_builtins.str] = None,
                 notification_type: Optional[_builtins.str] = None,
                 pull_request_created_by: Optional[_builtins.str] = None,
                 pull_request_reviewers_contains: Optional[_builtins.str] = None,
                 repository_id: Optional[_builtins.str] = None):
        """
        :param _builtins.str branch: Include only events for pull requests in a specific branch.
        :param _builtins.str notification_type: Include only events for pull requests with a specific change. Valid values: `PushNotification`, `ReviewersUpdateNotification`, `StatusUpdateNotification`, `ReviewerVoteNotification`.
        :param _builtins.str pull_request_created_by: Include only events for pull requests created by users in a specific group.
        :param _builtins.str pull_request_reviewers_contains: Include only events for pull requests with reviewers in a specific group.
        :param _builtins.str repository_id: Include only events for pull requests in a specific repository (repository ID). If not specified, all repositories in the project will trigger the event.
        """
        if branch is not None:
            pulumi.set(__self__, "branch", branch)
        if notification_type is not None:
            pulumi.set(__self__, "notification_type", notification_type)
        if pull_request_created_by is not None:
            pulumi.set(__self__, "pull_request_created_by", pull_request_created_by)
        if pull_request_reviewers_contains is not None:
            pulumi.set(__self__, "pull_request_reviewers_contains", pull_request_reviewers_contains)
        if repository_id is not None:
            pulumi.set(__self__, "repository_id", repository_id)

    @_builtins.property
    @pulumi.getter
    def branch(self) -> Optional[_builtins.str]:
        """
        Include only events for pull requests in a specific branch.
        """
        return pulumi.get(self, "branch")

    @_builtins.property
    @pulumi.getter(name="notificationType")
    def notification_type(self) -> Optional[_builtins.str]:
        """
        Include only events for pull requests with a specific change. Valid values: `PushNotification`, `ReviewersUpdateNotification`, `StatusUpdateNotification`, `ReviewerVoteNotification`.
        """
        return pulumi.get(self, "notification_type")

    @_builtins.property
    @pulumi.getter(name="pullRequestCreatedBy")
    def pull_request_created_by(self) -> Optional[_builtins.str]:
        """
        Include only events for pull requests created by users in a specific group.
        """
        return pulumi.get(self, "pull_request_created_by")

    @_builtins.property
    @pulumi.getter(name="pullRequestReviewersContains")
    def pull_request_reviewers_contains(self) -> Optional[_builtins.str]:
        """
        Include only events for pull requests with reviewers in a specific group.
        """
        return pulumi.get(self, "pull_request_reviewers_contains")

    @_builtins.property
    @pulumi.getter(name="repositoryId")
    def repository_id(self) -> Optional[_builtins.str]:
        """
        Include only events for pull requests in a specific repository (repository ID). If not specified, all repositories in the project will trigger the event.
        """
        return pulumi.get(self, "repository_id")


@pulumi.output_type
class ServicehookWebhookTfsGitPush(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "pushedBy":
            suggest = "pushed_by"
        elif key == "repositoryId":
            suggest = "repository_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ServicehookWebhookTfsGitPush. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ServicehookWebhookTfsGitPush.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ServicehookWebhookTfsGitPush.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 branch: Optional[_builtins.str] = None,
                 pushed_by: Optional[_builtins.str] = None,
                 repository_id: Optional[_builtins.str] = None):
        """
        :param _builtins.str branch: Include only events for code pushes to a specific branch.
        :param _builtins.str pushed_by: Include only events for code pushes by users in a specific group.
        :param _builtins.str repository_id: Include only events for code pushes to a specific repository (repository ID). If not specified, all repositories in the project will trigger the event.
        """
        if branch is not None:
            pulumi.set(__self__, "branch", branch)
        if pushed_by is not None:
            pulumi.set(__self__, "pushed_by", pushed_by)
        if repository_id is not None:
            pulumi.set(__self__, "repository_id", repository_id)

    @_builtins.property
    @pulumi.getter
    def branch(self) -> Optional[_builtins.str]:
        """
        Include only events for code pushes to a specific branch.
        """
        return pulumi.get(self, "branch")

    @_builtins.property
    @pulumi.getter(name="pushedBy")
    def pushed_by(self) -> Optional[_builtins.str]:
        """
        Include only events for code pushes by users in a specific group.
        """
        return pulumi.get(self, "pushed_by")

    @_builtins.property
    @pulumi.getter(name="repositoryId")
    def repository_id(self) -> Optional[_builtins.str]:
        """
        Include only events for code pushes to a specific repository (repository ID). If not specified, all repositories in the project will trigger the event.
        """
        return pulumi.get(self, "repository_id")


@pulumi.output_type
class ServicehookWebhookTfsRepositoryCreated(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "projectId":
            suggest = "project_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ServicehookWebhookTfsRepositoryCreated. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ServicehookWebhookTfsRepositoryCreated.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ServicehookWebhookTfsRepositoryCreated.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 project_id: Optional[_builtins.str] = None):
        """
        :param _builtins.str project_id: Include only events for repositories created in a specific project.
        """
        if project_id is not None:
            pulumi.set(__self__, "project_id", project_id)

    @_builtins.property
    @pulumi.getter(name="projectId")
    def project_id(self) -> Optional[_builtins.str]:
        """
        Include only events for repositories created in a specific project.
        """
        return pulumi.get(self, "project_id")


@pulumi.output_type
class ServicehookWebhookTfsRepositoryDeleted(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "repositoryId":
            suggest = "repository_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ServicehookWebhookTfsRepositoryDeleted. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ServicehookWebhookTfsRepositoryDeleted.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ServicehookWebhookTfsRepositoryDeleted.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 repository_id: Optional[_builtins.str] = None):
        """
        :param _builtins.str repository_id: Include only events for repositories with a specific repository ID.
        """
        if repository_id is not None:
            pulumi.set(__self__, "repository_id", repository_id)

    @_builtins.property
    @pulumi.getter(name="repositoryId")
    def repository_id(self) -> Optional[_builtins.str]:
        """
        Include only events for repositories with a specific repository ID.
        """
        return pulumi.get(self, "repository_id")


@pulumi.output_type
class ServicehookWebhookTfsRepositoryForked(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "repositoryId":
            suggest = "repository_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ServicehookWebhookTfsRepositoryForked. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ServicehookWebhookTfsRepositoryForked.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ServicehookWebhookTfsRepositoryForked.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 repository_id: Optional[_builtins.str] = None):
        """
        :param _builtins.str repository_id: Include only events for repositories with a specific repository ID.
        """
        if repository_id is not None:
            pulumi.set(__self__, "repository_id", repository_id)

    @_builtins.property
    @pulumi.getter(name="repositoryId")
    def repository_id(self) -> Optional[_builtins.str]:
        """
        Include only events for repositories with a specific repository ID.
        """
        return pulumi.get(self, "repository_id")


@pulumi.output_type
class ServicehookWebhookTfsRepositoryRenamed(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "repositoryId":
            suggest = "repository_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ServicehookWebhookTfsRepositoryRenamed. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ServicehookWebhookTfsRepositoryRenamed.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ServicehookWebhookTfsRepositoryRenamed.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 repository_id: Optional[_builtins.str] = None):
        """
        :param _builtins.str repository_id: Include only events for repositories with a specific repository ID.
        """
        if repository_id is not None:
            pulumi.set(__self__, "repository_id", repository_id)

    @_builtins.property
    @pulumi.getter(name="repositoryId")
    def repository_id(self) -> Optional[_builtins.str]:
        """
        Include only events for repositories with a specific repository ID.
        """
        return pulumi.get(self, "repository_id")


@pulumi.output_type
class ServicehookWebhookTfsRepositoryStatusChanged(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "repositoryId":
            suggest = "repository_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ServicehookWebhookTfsRepositoryStatusChanged. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ServicehookWebhookTfsRepositoryStatusChanged.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ServicehookWebhookTfsRepositoryStatusChanged.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 repository_id: Optional[_builtins.str] = None):
        """
        :param _builtins.str repository_id: Include only events for repositories with a specific repository ID.
        """
        if repository_id is not None:
            pulumi.set(__self__, "repository_id", repository_id)

    @_builtins.property
    @pulumi.getter(name="repositoryId")
    def repository_id(self) -> Optional[_builtins.str]:
        """
        Include only events for repositories with a specific repository ID.
        """
        return pulumi.get(self, "repository_id")


@pulumi.output_type
class ServicehookWebhookTfsServiceConnectionCreated(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "projectId":
            suggest = "project_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ServicehookWebhookTfsServiceConnectionCreated. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ServicehookWebhookTfsServiceConnectionCreated.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ServicehookWebhookTfsServiceConnectionCreated.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 project_id: Optional[_builtins.str] = None):
        """
        :param _builtins.str project_id: Include only events for service connections created in a specific project.
        """
        if project_id is not None:
            pulumi.set(__self__, "project_id", project_id)

    @_builtins.property
    @pulumi.getter(name="projectId")
    def project_id(self) -> Optional[_builtins.str]:
        """
        Include only events for service connections created in a specific project.
        """
        return pulumi.get(self, "project_id")


@pulumi.output_type
class ServicehookWebhookTfsServiceConnectionUpdated(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "projectId":
            suggest = "project_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ServicehookWebhookTfsServiceConnectionUpdated. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ServicehookWebhookTfsServiceConnectionUpdated.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ServicehookWebhookTfsServiceConnectionUpdated.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 project_id: Optional[_builtins.str] = None):
        """
        :param _builtins.str project_id: Include only events for service connections updated in a specific project.
        """
        if project_id is not None:
            pulumi.set(__self__, "project_id", project_id)

    @_builtins.property
    @pulumi.getter(name="projectId")
    def project_id(self) -> Optional[_builtins.str]:
        """
        Include only events for service connections updated in a specific project.
        """
        return pulumi.get(self, "project_id")


@pulumi.output_type
class ServicehookWebhookTfsTfvcCheckin(dict):
    def __init__(__self__, *,
                 path: _builtins.str):
        """
        :param _builtins.str path: Include only events for check-ins that change files under a specific path.
        """
        pulumi.set(__self__, "path", path)

    @_builtins.property
    @pulumi.getter
    def path(self) -> _builtins.str:
        """
        Include only events for check-ins that change files under a specific path.
        """
        return pulumi.get(self, "path")


@pulumi.output_type
class ServicehookWebhookTfsWorkItemCommented(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "areaPath":
            suggest = "area_path"
        elif key == "commentPattern":
            suggest = "comment_pattern"
        elif key == "workItemType":
            suggest = "work_item_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ServicehookWebhookTfsWorkItemCommented. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ServicehookWebhookTfsWorkItemCommented.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ServicehookWebhookTfsWorkItemCommented.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 area_path: Optional[_builtins.str] = None,
                 comment_pattern: Optional[_builtins.str] = None,
                 tag: Optional[_builtins.str] = None,
                 work_item_type: Optional[_builtins.str] = None):
        """
        :param _builtins.str area_path: Include only events for work items under a specific area path.
        :param _builtins.str comment_pattern: Include only events for work items with a comment that contains a specific string.
        :param _builtins.str tag: Include only events for work items that contain a specific tag.
        :param _builtins.str work_item_type: Include only events for work items of a specific type.
        """
        if area_path is not None:
            pulumi.set(__self__, "area_path", area_path)
        if comment_pattern is not None:
            pulumi.set(__self__, "comment_pattern", comment_pattern)
        if tag is not None:
            pulumi.set(__self__, "tag", tag)
        if work_item_type is not None:
            pulumi.set(__self__, "work_item_type", work_item_type)

    @_builtins.property
    @pulumi.getter(name="areaPath")
    def area_path(self) -> Optional[_builtins.str]:
        """
        Include only events for work items under a specific area path.
        """
        return pulumi.get(self, "area_path")

    @_builtins.property
    @pulumi.getter(name="commentPattern")
    def comment_pattern(self) -> Optional[_builtins.str]:
        """
        Include only events for work items with a comment that contains a specific string.
        """
        return pulumi.get(self, "comment_pattern")

    @_builtins.property
    @pulumi.getter
    def tag(self) -> Optional[_builtins.str]:
        """
        Include only events for work items that contain a specific tag.
        """
        return pulumi.get(self, "tag")

    @_builtins.property
    @pulumi.getter(name="workItemType")
    def work_item_type(self) -> Optional[_builtins.str]:
        """
        Include only events for work items of a specific type.
        """
        return pulumi.get(self, "work_item_type")


@pulumi.output_type
class ServicehookWebhookTfsWorkItemCreated(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "areaPath":
            suggest = "area_path"
        elif key == "linksChanged":
            suggest = "links_changed"
        elif key == "workItemType":
            suggest = "work_item_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ServicehookWebhookTfsWorkItemCreated. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ServicehookWebhookTfsWorkItemCreated.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ServicehookWebhookTfsWorkItemCreated.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 area_path: Optional[_builtins.str] = None,
                 links_changed: Optional[_builtins.bool] = None,
                 tag: Optional[_builtins.str] = None,
                 work_item_type: Optional[_builtins.str] = None):
        """
        :param _builtins.str area_path: Include only events for work items under a specific area path.
        :param _builtins.bool links_changed: Include only events for work items with one or more links added or removed.
        :param _builtins.str tag: Include only events for work items that contain a specific tag.
        :param _builtins.str work_item_type: Include only events for work items of a specific type.
        """
        if area_path is not None:
            pulumi.set(__self__, "area_path", area_path)
        if links_changed is not None:
            pulumi.set(__self__, "links_changed", links_changed)
        if tag is not None:
            pulumi.set(__self__, "tag", tag)
        if work_item_type is not None:
            pulumi.set(__self__, "work_item_type", work_item_type)

    @_builtins.property
    @pulumi.getter(name="areaPath")
    def area_path(self) -> Optional[_builtins.str]:
        """
        Include only events for work items under a specific area path.
        """
        return pulumi.get(self, "area_path")

    @_builtins.property
    @pulumi.getter(name="linksChanged")
    def links_changed(self) -> Optional[_builtins.bool]:
        """
        Include only events for work items with one or more links added or removed.
        """
        return pulumi.get(self, "links_changed")

    @_builtins.property
    @pulumi.getter
    def tag(self) -> Optional[_builtins.str]:
        """
        Include only events for work items that contain a specific tag.
        """
        return pulumi.get(self, "tag")

    @_builtins.property
    @pulumi.getter(name="workItemType")
    def work_item_type(self) -> Optional[_builtins.str]:
        """
        Include only events for work items of a specific type.
        """
        return pulumi.get(self, "work_item_type")


@pulumi.output_type
class ServicehookWebhookTfsWorkItemDeleted(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "areaPath":
            suggest = "area_path"
        elif key == "workItemType":
            suggest = "work_item_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ServicehookWebhookTfsWorkItemDeleted. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ServicehookWebhookTfsWorkItemDeleted.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ServicehookWebhookTfsWorkItemDeleted.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 area_path: Optional[_builtins.str] = None,
                 tag: Optional[_builtins.str] = None,
                 work_item_type: Optional[_builtins.str] = None):
        """
        :param _builtins.str area_path: Include only events for work items under a specific area path.
        :param _builtins.str tag: Include only events for work items that contain a specific tag.
        :param _builtins.str work_item_type: Include only events for work items of a specific type.
        """
        if area_path is not None:
            pulumi.set(__self__, "area_path", area_path)
        if tag is not None:
            pulumi.set(__self__, "tag", tag)
        if work_item_type is not None:
            pulumi.set(__self__, "work_item_type", work_item_type)

    @_builtins.property
    @pulumi.getter(name="areaPath")
    def area_path(self) -> Optional[_builtins.str]:
        """
        Include only events for work items under a specific area path.
        """
        return pulumi.get(self, "area_path")

    @_builtins.property
    @pulumi.getter
    def tag(self) -> Optional[_builtins.str]:
        """
        Include only events for work items that contain a specific tag.
        """
        return pulumi.get(self, "tag")

    @_builtins.property
    @pulumi.getter(name="workItemType")
    def work_item_type(self) -> Optional[_builtins.str]:
        """
        Include only events for work items of a specific type.
        """
        return pulumi.get(self, "work_item_type")


@pulumi.output_type
class ServicehookWebhookTfsWorkItemRestored(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "areaPath":
            suggest = "area_path"
        elif key == "workItemType":
            suggest = "work_item_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ServicehookWebhookTfsWorkItemRestored. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ServicehookWebhookTfsWorkItemRestored.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ServicehookWebhookTfsWorkItemRestored.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 area_path: Optional[_builtins.str] = None,
                 tag: Optional[_builtins.str] = None,
                 work_item_type: Optional[_builtins.str] = None):
        """
        :param _builtins.str area_path: Include only events for work items under a specific area path.
        :param _builtins.str tag: Include only events for work items that contain a specific tag.
        :param _builtins.str work_item_type: Include only events for work items of a specific type.
        """
        if area_path is not None:
            pulumi.set(__self__, "area_path", area_path)
        if tag is not None:
            pulumi.set(__self__, "tag", tag)
        if work_item_type is not None:
            pulumi.set(__self__, "work_item_type", work_item_type)

    @_builtins.property
    @pulumi.getter(name="areaPath")
    def area_path(self) -> Optional[_builtins.str]:
        """
        Include only events for work items under a specific area path.
        """
        return pulumi.get(self, "area_path")

    @_builtins.property
    @pulumi.getter
    def tag(self) -> Optional[_builtins.str]:
        """
        Include only events for work items that contain a specific tag.
        """
        return pulumi.get(self, "tag")

    @_builtins.property
    @pulumi.getter(name="workItemType")
    def work_item_type(self) -> Optional[_builtins.str]:
        """
        Include only events for work items of a specific type.
        """
        return pulumi.get(self, "work_item_type")


@pulumi.output_type
class ServicehookWebhookTfsWorkItemUpdated(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "areaPath":
            suggest = "area_path"
        elif key == "changedFields":
            suggest = "changed_fields"
        elif key == "linksChanged":
            suggest = "links_changed"
        elif key == "workItemType":
            suggest = "work_item_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ServicehookWebhookTfsWorkItemUpdated. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ServicehookWebhookTfsWorkItemUpdated.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ServicehookWebhookTfsWorkItemUpdated.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 area_path: Optional[_builtins.str] = None,
                 changed_fields: Optional[_builtins.str] = None,
                 links_changed: Optional[_builtins.bool] = None,
                 tag: Optional[_builtins.str] = None,
                 work_item_type: Optional[_builtins.str] = None):
        """
        :param _builtins.str area_path: Include only events for work items under a specific area path.
        :param _builtins.str changed_fields: Include only events for work items with a change in a specific field.
        :param _builtins.bool links_changed: Include only events for work items with one or more links added or removed.
        :param _builtins.str tag: Include only events for work items that contain a specific tag.
        :param _builtins.str work_item_type: Include only events for work items of a specific type.
        """
        if area_path is not None:
            pulumi.set(__self__, "area_path", area_path)
        if changed_fields is not None:
            pulumi.set(__self__, "changed_fields", changed_fields)
        if links_changed is not None:
            pulumi.set(__self__, "links_changed", links_changed)
        if tag is not None:
            pulumi.set(__self__, "tag", tag)
        if work_item_type is not None:
            pulumi.set(__self__, "work_item_type", work_item_type)

    @_builtins.property
    @pulumi.getter(name="areaPath")
    def area_path(self) -> Optional[_builtins.str]:
        """
        Include only events for work items under a specific area path.
        """
        return pulumi.get(self, "area_path")

    @_builtins.property
    @pulumi.getter(name="changedFields")
    def changed_fields(self) -> Optional[_builtins.str]:
        """
        Include only events for work items with a change in a specific field.
        """
        return pulumi.get(self, "changed_fields")

    @_builtins.property
    @pulumi.getter(name="linksChanged")
    def links_changed(self) -> Optional[_builtins.bool]:
        """
        Include only events for work items with one or more links added or removed.
        """
        return pulumi.get(self, "links_changed")

    @_builtins.property
    @pulumi.getter
    def tag(self) -> Optional[_builtins.str]:
        """
        Include only events for work items that contain a specific tag.
        """
        return pulumi.get(self, "tag")

    @_builtins.property
    @pulumi.getter(name="workItemType")
    def work_item_type(self) -> Optional[_builtins.str]:
        """
        Include only events for work items of a specific type.
        """
        return pulumi.get(self, "work_item_type")


@pulumi.output_type
class VariableGroupKeyVault(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "serviceEndpointId":
            suggest = "service_endpoint_id"
        elif key == "searchDepth":
            suggest = "search_depth"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in VariableGroupKeyVault. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        VariableGroupKeyVault.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        VariableGroupKeyVault.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 name: _builtins.str,
                 service_endpoint_id: _builtins.str,
                 search_depth: Optional[_builtins.int] = None):
        """
        :param _builtins.str name: The name of the Azure key vault to link secrets from as variables.
        :param _builtins.str service_endpoint_id: The id of the Azure subscription endpoint to access the key vault.
        :param _builtins.int search_depth: Set the Azure Key Vault Secret search depth. Defaults to `20`.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "service_endpoint_id", service_endpoint_id)
        if search_depth is not None:
            pulumi.set(__self__, "search_depth", search_depth)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        The name of the Azure key vault to link secrets from as variables.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter(name="serviceEndpointId")
    def service_endpoint_id(self) -> _builtins.str:
        """
        The id of the Azure subscription endpoint to access the key vault.
        """
        return pulumi.get(self, "service_endpoint_id")

    @_builtins.property
    @pulumi.getter(name="searchDepth")
    def search_depth(self) -> Optional[_builtins.int]:
        """
        Set the Azure Key Vault Secret search depth. Defaults to `20`.
        """
        return pulumi.get(self, "search_depth")


@pulumi.output_type
class VariableGroupVariable(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "contentType":
            suggest = "content_type"
        elif key == "isSecret":
            suggest = "is_secret"
        elif key == "secretValue":
            suggest = "secret_value"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in VariableGroupVariable. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        VariableGroupVariable.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        VariableGroupVariable.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 name: _builtins.str,
                 content_type: Optional[_builtins.str] = None,
                 enabled: Optional[_builtins.bool] = None,
                 expires: Optional[_builtins.str] = None,
                 is_secret: Optional[_builtins.bool] = None,
                 secret_value: Optional[_builtins.str] = None,
                 value: Optional[_builtins.str] = None):
        """
        :param _builtins.str name: The key value used for the variable. Must be unique within the Variable Group.
        :param _builtins.bool is_secret: A boolean flag describing if the variable value is sensitive. Defaults to `false`.
        :param _builtins.str secret_value: The secret value of the variable. If omitted, it will default to empty string. Used when `is_secret` set to `true`.
        :param _builtins.str value: The value of the variable. If omitted, it will default to empty string.
        """
        pulumi.set(__self__, "name", name)
        if content_type is not None:
            pulumi.set(__self__, "content_type", content_type)
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if expires is not None:
            pulumi.set(__self__, "expires", expires)
        if is_secret is not None:
            pulumi.set(__self__, "is_secret", is_secret)
        if secret_value is not None:
            pulumi.set(__self__, "secret_value", secret_value)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        The key value used for the variable. Must be unique within the Variable Group.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter(name="contentType")
    def content_type(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "content_type")

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "enabled")

    @_builtins.property
    @pulumi.getter
    def expires(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "expires")

    @_builtins.property
    @pulumi.getter(name="isSecret")
    def is_secret(self) -> Optional[_builtins.bool]:
        """
        A boolean flag describing if the variable value is sensitive. Defaults to `false`.
        """
        return pulumi.get(self, "is_secret")

    @_builtins.property
    @pulumi.getter(name="secretValue")
    def secret_value(self) -> Optional[_builtins.str]:
        """
        The secret value of the variable. If omitted, it will default to empty string. Used when `is_secret` set to `true`.
        """
        return pulumi.get(self, "secret_value")

    @_builtins.property
    @pulumi.getter
    def value(self) -> Optional[_builtins.str]:
        """
        The value of the variable. If omitted, it will default to empty string.
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class WorkitemRelation(dict):
    def __init__(__self__, *,
                 rel: Optional[_builtins.str] = None,
                 url: Optional[_builtins.str] = None):
        """
        :param _builtins.str rel: The type of relationship. For example: `System.LinkTypes.Hierarchy-Reverse` is a parent relationship. More details [item link type](https://learn.microsoft.com/en-us/azure/devops/boards/queries/link-type-reference?view=azure-devops#example).
        :param _builtins.str url: The URL of the Work Item.
        """
        if rel is not None:
            pulumi.set(__self__, "rel", rel)
        if url is not None:
            pulumi.set(__self__, "url", url)

    @_builtins.property
    @pulumi.getter
    def rel(self) -> Optional[_builtins.str]:
        """
        The type of relationship. For example: `System.LinkTypes.Hierarchy-Reverse` is a parent relationship. More details [item link type](https://learn.microsoft.com/en-us/azure/devops/boards/queries/link-type-reference?view=azure-devops#example).
        """
        return pulumi.get(self, "rel")

    @_builtins.property
    @pulumi.getter
    def url(self) -> Optional[_builtins.str]:
        """
        The URL of the Work Item.
        """
        return pulumi.get(self, "url")


@pulumi.output_type
class GetAreaChildrenResult(dict):
    def __init__(__self__, *,
                 has_children: _builtins.bool,
                 id: _builtins.str,
                 name: _builtins.str,
                 path: _builtins.str,
                 project_id: _builtins.str):
        """
        :param _builtins.bool has_children: Indicator if the child Area node has child nodes
        :param _builtins.str id: The ID of the child Area node
        :param _builtins.str name: The name of the child Area node
        :param _builtins.str path: The path to the Area; _Format_: URL relative; if omitted, or value `"/"` is used, the root Area will be returned
        :param _builtins.str project_id: The project ID.
        """
        pulumi.set(__self__, "has_children", has_children)
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "path", path)
        pulumi.set(__self__, "project_id", project_id)

    @_builtins.property
    @pulumi.getter(name="hasChildren")
    def has_children(self) -> _builtins.bool:
        """
        Indicator if the child Area node has child nodes
        """
        return pulumi.get(self, "has_children")

    @_builtins.property
    @pulumi.getter
    def id(self) -> _builtins.str:
        """
        The ID of the child Area node
        """
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        The name of the child Area node
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def path(self) -> _builtins.str:
        """
        The path to the Area; _Format_: URL relative; if omitted, or value `"/"` is used, the root Area will be returned
        """
        return pulumi.get(self, "path")

    @_builtins.property
    @pulumi.getter(name="projectId")
    def project_id(self) -> _builtins.str:
        """
        The project ID.
        """
        return pulumi.get(self, "project_id")


@pulumi.output_type
class GetBuildDefinitionCiTriggerResult(dict):
    def __init__(__self__, *,
                 overrides: Sequence['outputs.GetBuildDefinitionCiTriggerOverrideResult'],
                 use_yaml: _builtins.bool):
        """
        :param Sequence['GetBuildDefinitionCiTriggerOverrideArgs'] overrides: A `override` block as defined below.
        :param _builtins.bool use_yaml: Use the azure-pipeline file for the build configuration.
        """
        pulumi.set(__self__, "overrides", overrides)
        pulumi.set(__self__, "use_yaml", use_yaml)

    @_builtins.property
    @pulumi.getter
    def overrides(self) -> Sequence['outputs.GetBuildDefinitionCiTriggerOverrideResult']:
        """
        A `override` block as defined below.
        """
        return pulumi.get(self, "overrides")

    @_builtins.property
    @pulumi.getter(name="useYaml")
    def use_yaml(self) -> _builtins.bool:
        """
        Use the azure-pipeline file for the build configuration.
        """
        return pulumi.get(self, "use_yaml")


@pulumi.output_type
class GetBuildDefinitionCiTriggerOverrideResult(dict):
    def __init__(__self__, *,
                 batch: _builtins.bool,
                 branch_filters: Sequence['outputs.GetBuildDefinitionCiTriggerOverrideBranchFilterResult'],
                 max_concurrent_builds_per_branch: _builtins.int,
                 path_filters: Sequence['outputs.GetBuildDefinitionCiTriggerOverridePathFilterResult'],
                 polling_interval: _builtins.int,
                 polling_job_id: _builtins.str):
        """
        :param _builtins.bool batch: If batch is true, when a pipeline is running, the system waits until the run is completed, then starts another run with all changes that have not yet been built.
        :param Sequence['GetBuildDefinitionCiTriggerOverrideBranchFilterArgs'] branch_filters: A `branch_filter` block as defined above.
        :param _builtins.int max_concurrent_builds_per_branch: The number of max builds per branch.
        :param Sequence['GetBuildDefinitionCiTriggerOverridePathFilterArgs'] path_filters: The file paths to include or exclude. A `path_filter` block as defined above.
        :param _builtins.int polling_interval: How often the external repository is polled.
        :param _builtins.str polling_job_id: This is the ID of the polling job that polls the external repository. Once the build definition is saved/updated, this value is set.
        """
        pulumi.set(__self__, "batch", batch)
        pulumi.set(__self__, "branch_filters", branch_filters)
        pulumi.set(__self__, "max_concurrent_builds_per_branch", max_concurrent_builds_per_branch)
        pulumi.set(__self__, "path_filters", path_filters)
        pulumi.set(__self__, "polling_interval", polling_interval)
        pulumi.set(__self__, "polling_job_id", polling_job_id)

    @_builtins.property
    @pulumi.getter
    def batch(self) -> _builtins.bool:
        """
        If batch is true, when a pipeline is running, the system waits until the run is completed, then starts another run with all changes that have not yet been built.
        """
        return pulumi.get(self, "batch")

    @_builtins.property
    @pulumi.getter(name="branchFilters")
    def branch_filters(self) -> Sequence['outputs.GetBuildDefinitionCiTriggerOverrideBranchFilterResult']:
        """
        A `branch_filter` block as defined above.
        """
        return pulumi.get(self, "branch_filters")

    @_builtins.property
    @pulumi.getter(name="maxConcurrentBuildsPerBranch")
    def max_concurrent_builds_per_branch(self) -> _builtins.int:
        """
        The number of max builds per branch.
        """
        return pulumi.get(self, "max_concurrent_builds_per_branch")

    @_builtins.property
    @pulumi.getter(name="pathFilters")
    def path_filters(self) -> Sequence['outputs.GetBuildDefinitionCiTriggerOverridePathFilterResult']:
        """
        The file paths to include or exclude. A `path_filter` block as defined above.
        """
        return pulumi.get(self, "path_filters")

    @_builtins.property
    @pulumi.getter(name="pollingInterval")
    def polling_interval(self) -> _builtins.int:
        """
        How often the external repository is polled.
        """
        return pulumi.get(self, "polling_interval")

    @_builtins.property
    @pulumi.getter(name="pollingJobId")
    def polling_job_id(self) -> _builtins.str:
        """
        This is the ID of the polling job that polls the external repository. Once the build definition is saved/updated, this value is set.
        """
        return pulumi.get(self, "polling_job_id")


@pulumi.output_type
class GetBuildDefinitionCiTriggerOverrideBranchFilterResult(dict):
    def __init__(__self__, *,
                 excludes: Sequence[_builtins.str],
                 includes: Sequence[_builtins.str]):
        """
        :param Sequence[_builtins.str] excludes: (Optional) List of path patterns to exclude.
        :param Sequence[_builtins.str] includes: (Optional) List of path patterns to include.
        """
        pulumi.set(__self__, "excludes", excludes)
        pulumi.set(__self__, "includes", includes)

    @_builtins.property
    @pulumi.getter
    def excludes(self) -> Sequence[_builtins.str]:
        """
        (Optional) List of path patterns to exclude.
        """
        return pulumi.get(self, "excludes")

    @_builtins.property
    @pulumi.getter
    def includes(self) -> Sequence[_builtins.str]:
        """
        (Optional) List of path patterns to include.
        """
        return pulumi.get(self, "includes")


@pulumi.output_type
class GetBuildDefinitionCiTriggerOverridePathFilterResult(dict):
    def __init__(__self__, *,
                 excludes: Sequence[_builtins.str],
                 includes: Sequence[_builtins.str]):
        """
        :param Sequence[_builtins.str] excludes: (Optional) List of path patterns to exclude.
        :param Sequence[_builtins.str] includes: (Optional) List of path patterns to include.
        """
        pulumi.set(__self__, "excludes", excludes)
        pulumi.set(__self__, "includes", includes)

    @_builtins.property
    @pulumi.getter
    def excludes(self) -> Sequence[_builtins.str]:
        """
        (Optional) List of path patterns to exclude.
        """
        return pulumi.get(self, "excludes")

    @_builtins.property
    @pulumi.getter
    def includes(self) -> Sequence[_builtins.str]:
        """
        (Optional) List of path patterns to include.
        """
        return pulumi.get(self, "includes")


@pulumi.output_type
class GetBuildDefinitionJobResult(dict):
    def __init__(__self__, *,
                 allow_scripts_auth_access_option: _builtins.bool,
                 condition: _builtins.str,
                 dependencies: Sequence['outputs.GetBuildDefinitionJobDependencyResult'],
                 job_authorization_scope: _builtins.str,
                 job_cancel_timeout_in_minutes: _builtins.int,
                 job_timeout_in_minutes: _builtins.int,
                 name: _builtins.str,
                 ref_name: _builtins.str,
                 targets: Sequence['outputs.GetBuildDefinitionJobTargetResult']):
        """
        :param _builtins.bool allow_scripts_auth_access_option: Enables scripts and other processes launched by tasks to access the OAuth token through the `System.AccessToken` variable.
        :param _builtins.str condition: Specifies when this job should run. Can **Custom conditions** to specify more complex conditions. More details: [Pipeline conditions](https://learn.microsoft.com/en-us/azure/devops/pipelines/process/conditions?view=azure-devops)
        :param Sequence['GetBuildDefinitionJobDependencyArgs'] dependencies: A `dependencies` blocks as documented below. Define the job dependencies.
        :param _builtins.str job_authorization_scope: The job authorization scope for builds queued against this definition.
        :param _builtins.int job_cancel_timeout_in_minutes: The job cancel timeout (in minutes) for builds cancelled by user for this definition.
        :param _builtins.int job_timeout_in_minutes: The job execution timeout (in minutes) for builds queued against this definition.
        :param _builtins.str name: The name of this Build Definition.
        :param _builtins.str ref_name: The reference name of the job, can be used to define the job dependencies.
        :param Sequence['GetBuildDefinitionJobTargetArgs'] targets: A `target` blocks as documented below.
        """
        pulumi.set(__self__, "allow_scripts_auth_access_option", allow_scripts_auth_access_option)
        pulumi.set(__self__, "condition", condition)
        pulumi.set(__self__, "dependencies", dependencies)
        pulumi.set(__self__, "job_authorization_scope", job_authorization_scope)
        pulumi.set(__self__, "job_cancel_timeout_in_minutes", job_cancel_timeout_in_minutes)
        pulumi.set(__self__, "job_timeout_in_minutes", job_timeout_in_minutes)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "ref_name", ref_name)
        pulumi.set(__self__, "targets", targets)

    @_builtins.property
    @pulumi.getter(name="allowScriptsAuthAccessOption")
    def allow_scripts_auth_access_option(self) -> _builtins.bool:
        """
        Enables scripts and other processes launched by tasks to access the OAuth token through the `System.AccessToken` variable.
        """
        return pulumi.get(self, "allow_scripts_auth_access_option")

    @_builtins.property
    @pulumi.getter
    def condition(self) -> _builtins.str:
        """
        Specifies when this job should run. Can **Custom conditions** to specify more complex conditions. More details: [Pipeline conditions](https://learn.microsoft.com/en-us/azure/devops/pipelines/process/conditions?view=azure-devops)
        """
        return pulumi.get(self, "condition")

    @_builtins.property
    @pulumi.getter
    def dependencies(self) -> Sequence['outputs.GetBuildDefinitionJobDependencyResult']:
        """
        A `dependencies` blocks as documented below. Define the job dependencies.
        """
        return pulumi.get(self, "dependencies")

    @_builtins.property
    @pulumi.getter(name="jobAuthorizationScope")
    def job_authorization_scope(self) -> _builtins.str:
        """
        The job authorization scope for builds queued against this definition.
        """
        return pulumi.get(self, "job_authorization_scope")

    @_builtins.property
    @pulumi.getter(name="jobCancelTimeoutInMinutes")
    def job_cancel_timeout_in_minutes(self) -> _builtins.int:
        """
        The job cancel timeout (in minutes) for builds cancelled by user for this definition.
        """
        return pulumi.get(self, "job_cancel_timeout_in_minutes")

    @_builtins.property
    @pulumi.getter(name="jobTimeoutInMinutes")
    def job_timeout_in_minutes(self) -> _builtins.int:
        """
        The job execution timeout (in minutes) for builds queued against this definition.
        """
        return pulumi.get(self, "job_timeout_in_minutes")

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        The name of this Build Definition.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter(name="refName")
    def ref_name(self) -> _builtins.str:
        """
        The reference name of the job, can be used to define the job dependencies.
        """
        return pulumi.get(self, "ref_name")

    @_builtins.property
    @pulumi.getter
    def targets(self) -> Sequence['outputs.GetBuildDefinitionJobTargetResult']:
        """
        A `target` blocks as documented below.
        """
        return pulumi.get(self, "targets")


@pulumi.output_type
class GetBuildDefinitionJobDependencyResult(dict):
    def __init__(__self__, *,
                 scope: _builtins.str):
        """
        :param _builtins.str scope: The job reference name that depends on. Reference to `jobs.ref_name`
        """
        pulumi.set(__self__, "scope", scope)

    @_builtins.property
    @pulumi.getter
    def scope(self) -> _builtins.str:
        """
        The job reference name that depends on. Reference to `jobs.ref_name`
        """
        return pulumi.get(self, "scope")


@pulumi.output_type
class GetBuildDefinitionJobTargetResult(dict):
    def __init__(__self__, *,
                 demands: Sequence[_builtins.str],
                 execution_options: Sequence['outputs.GetBuildDefinitionJobTargetExecutionOptionResult'],
                 type: _builtins.str):
        """
        :param Sequence[_builtins.str] demands: A list of demands that represents the agent capabilities required by this build. Example: `git`
        :param Sequence['GetBuildDefinitionJobTargetExecutionOptionArgs'] execution_options: A `execution_options` blocks as documented below.
        :param _builtins.str type: The execution type of the Job.
        """
        pulumi.set(__self__, "demands", demands)
        pulumi.set(__self__, "execution_options", execution_options)
        pulumi.set(__self__, "type", type)

    @_builtins.property
    @pulumi.getter
    def demands(self) -> Sequence[_builtins.str]:
        """
        A list of demands that represents the agent capabilities required by this build. Example: `git`
        """
        return pulumi.get(self, "demands")

    @_builtins.property
    @pulumi.getter(name="executionOptions")
    def execution_options(self) -> Sequence['outputs.GetBuildDefinitionJobTargetExecutionOptionResult']:
        """
        A `execution_options` blocks as documented below.
        """
        return pulumi.get(self, "execution_options")

    @_builtins.property
    @pulumi.getter
    def type(self) -> _builtins.str:
        """
        The execution type of the Job.
        """
        return pulumi.get(self, "type")


@pulumi.output_type
class GetBuildDefinitionJobTargetExecutionOptionResult(dict):
    def __init__(__self__, *,
                 continue_on_error: _builtins.bool,
                 max_concurrency: _builtins.int,
                 multipliers: _builtins.str,
                 type: _builtins.str):
        """
        :param _builtins.bool continue_on_error: Whether to continue the job when an error occurs.
        :param _builtins.int max_concurrency: Limit the number of agents to be used. If job type is `AgentlessJob`, the concurrency is not configurable and is fixed to 50.
        :param _builtins.str multipliers: A list of comma separated configuration variables to use. These are defined on the Variables tab. For example, OperatingSystem, Browser will run the tasks for both variables.
        :param _builtins.str type: The execution type of the Job.
        """
        pulumi.set(__self__, "continue_on_error", continue_on_error)
        pulumi.set(__self__, "max_concurrency", max_concurrency)
        pulumi.set(__self__, "multipliers", multipliers)
        pulumi.set(__self__, "type", type)

    @_builtins.property
    @pulumi.getter(name="continueOnError")
    def continue_on_error(self) -> _builtins.bool:
        """
        Whether to continue the job when an error occurs.
        """
        return pulumi.get(self, "continue_on_error")

    @_builtins.property
    @pulumi.getter(name="maxConcurrency")
    def max_concurrency(self) -> _builtins.int:
        """
        Limit the number of agents to be used. If job type is `AgentlessJob`, the concurrency is not configurable and is fixed to 50.
        """
        return pulumi.get(self, "max_concurrency")

    @_builtins.property
    @pulumi.getter
    def multipliers(self) -> _builtins.str:
        """
        A list of comma separated configuration variables to use. These are defined on the Variables tab. For example, OperatingSystem, Browser will run the tasks for both variables.
        """
        return pulumi.get(self, "multipliers")

    @_builtins.property
    @pulumi.getter
    def type(self) -> _builtins.str:
        """
        The execution type of the Job.
        """
        return pulumi.get(self, "type")


@pulumi.output_type
class GetBuildDefinitionPullRequestTriggerResult(dict):
    def __init__(__self__, *,
                 comment_required: _builtins.str,
                 forks: Sequence['outputs.GetBuildDefinitionPullRequestTriggerForkResult'],
                 initial_branch: _builtins.str,
                 overrides: Sequence['outputs.GetBuildDefinitionPullRequestTriggerOverrideResult'],
                 use_yaml: _builtins.bool):
        """
        :param _builtins.str comment_required: Is a comment required on the PR?
        :param Sequence['GetBuildDefinitionPullRequestTriggerForkArgs'] forks: A `forks` block as defined above.
        :param _builtins.str initial_branch: When use_yaml is true set this to the name of the branch that the azure-pipelines.yml exists on.
        :param Sequence['GetBuildDefinitionPullRequestTriggerOverrideArgs'] overrides: A `override` block as defined below.
        :param _builtins.bool use_yaml: Use the azure-pipeline file for the build configuration.
        """
        pulumi.set(__self__, "comment_required", comment_required)
        pulumi.set(__self__, "forks", forks)
        pulumi.set(__self__, "initial_branch", initial_branch)
        pulumi.set(__self__, "overrides", overrides)
        pulumi.set(__self__, "use_yaml", use_yaml)

    @_builtins.property
    @pulumi.getter(name="commentRequired")
    def comment_required(self) -> _builtins.str:
        """
        Is a comment required on the PR?
        """
        return pulumi.get(self, "comment_required")

    @_builtins.property
    @pulumi.getter
    def forks(self) -> Sequence['outputs.GetBuildDefinitionPullRequestTriggerForkResult']:
        """
        A `forks` block as defined above.
        """
        return pulumi.get(self, "forks")

    @_builtins.property
    @pulumi.getter(name="initialBranch")
    def initial_branch(self) -> _builtins.str:
        """
        When use_yaml is true set this to the name of the branch that the azure-pipelines.yml exists on.
        """
        return pulumi.get(self, "initial_branch")

    @_builtins.property
    @pulumi.getter
    def overrides(self) -> Sequence['outputs.GetBuildDefinitionPullRequestTriggerOverrideResult']:
        """
        A `override` block as defined below.
        """
        return pulumi.get(self, "overrides")

    @_builtins.property
    @pulumi.getter(name="useYaml")
    def use_yaml(self) -> _builtins.bool:
        """
        Use the azure-pipeline file for the build configuration.
        """
        return pulumi.get(self, "use_yaml")


@pulumi.output_type
class GetBuildDefinitionPullRequestTriggerForkResult(dict):
    def __init__(__self__, *,
                 enabled: _builtins.bool,
                 share_secrets: _builtins.bool):
        """
        :param _builtins.bool enabled: Build pull requests from forks of this repository.
        :param _builtins.bool share_secrets: Make secrets available to builds of forks.
        """
        pulumi.set(__self__, "enabled", enabled)
        pulumi.set(__self__, "share_secrets", share_secrets)

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> _builtins.bool:
        """
        Build pull requests from forks of this repository.
        """
        return pulumi.get(self, "enabled")

    @_builtins.property
    @pulumi.getter(name="shareSecrets")
    def share_secrets(self) -> _builtins.bool:
        """
        Make secrets available to builds of forks.
        """
        return pulumi.get(self, "share_secrets")


@pulumi.output_type
class GetBuildDefinitionPullRequestTriggerOverrideResult(dict):
    def __init__(__self__, *,
                 auto_cancel: _builtins.bool,
                 branch_filters: Sequence['outputs.GetBuildDefinitionPullRequestTriggerOverrideBranchFilterResult'],
                 path_filters: Sequence['outputs.GetBuildDefinitionPullRequestTriggerOverridePathFilterResult']):
        """
        :param _builtins.bool auto_cancel: Should further updates to a PR cancel an in progress validation?
        :param Sequence['GetBuildDefinitionPullRequestTriggerOverrideBranchFilterArgs'] branch_filters: A `branch_filter` block as defined above.
        :param Sequence['GetBuildDefinitionPullRequestTriggerOverridePathFilterArgs'] path_filters: The file paths to include or exclude. A `path_filter` block as defined above.
        """
        pulumi.set(__self__, "auto_cancel", auto_cancel)
        pulumi.set(__self__, "branch_filters", branch_filters)
        pulumi.set(__self__, "path_filters", path_filters)

    @_builtins.property
    @pulumi.getter(name="autoCancel")
    def auto_cancel(self) -> _builtins.bool:
        """
        Should further updates to a PR cancel an in progress validation?
        """
        return pulumi.get(self, "auto_cancel")

    @_builtins.property
    @pulumi.getter(name="branchFilters")
    def branch_filters(self) -> Sequence['outputs.GetBuildDefinitionPullRequestTriggerOverrideBranchFilterResult']:
        """
        A `branch_filter` block as defined above.
        """
        return pulumi.get(self, "branch_filters")

    @_builtins.property
    @pulumi.getter(name="pathFilters")
    def path_filters(self) -> Sequence['outputs.GetBuildDefinitionPullRequestTriggerOverridePathFilterResult']:
        """
        The file paths to include or exclude. A `path_filter` block as defined above.
        """
        return pulumi.get(self, "path_filters")


@pulumi.output_type
class GetBuildDefinitionPullRequestTriggerOverrideBranchFilterResult(dict):
    def __init__(__self__, *,
                 excludes: Sequence[_builtins.str],
                 includes: Sequence[_builtins.str]):
        """
        :param Sequence[_builtins.str] excludes: (Optional) List of path patterns to exclude.
        :param Sequence[_builtins.str] includes: (Optional) List of path patterns to include.
        """
        pulumi.set(__self__, "excludes", excludes)
        pulumi.set(__self__, "includes", includes)

    @_builtins.property
    @pulumi.getter
    def excludes(self) -> Sequence[_builtins.str]:
        """
        (Optional) List of path patterns to exclude.
        """
        return pulumi.get(self, "excludes")

    @_builtins.property
    @pulumi.getter
    def includes(self) -> Sequence[_builtins.str]:
        """
        (Optional) List of path patterns to include.
        """
        return pulumi.get(self, "includes")


@pulumi.output_type
class GetBuildDefinitionPullRequestTriggerOverridePathFilterResult(dict):
    def __init__(__self__, *,
                 excludes: Sequence[_builtins.str],
                 includes: Sequence[_builtins.str]):
        """
        :param Sequence[_builtins.str] excludes: (Optional) List of path patterns to exclude.
        :param Sequence[_builtins.str] includes: (Optional) List of path patterns to include.
        """
        pulumi.set(__self__, "excludes", excludes)
        pulumi.set(__self__, "includes", includes)

    @_builtins.property
    @pulumi.getter
    def excludes(self) -> Sequence[_builtins.str]:
        """
        (Optional) List of path patterns to exclude.
        """
        return pulumi.get(self, "excludes")

    @_builtins.property
    @pulumi.getter
    def includes(self) -> Sequence[_builtins.str]:
        """
        (Optional) List of path patterns to include.
        """
        return pulumi.get(self, "includes")


@pulumi.output_type
class GetBuildDefinitionRepositoryResult(dict):
    def __init__(__self__, *,
                 branch_name: _builtins.str,
                 github_enterprise_url: _builtins.str,
                 repo_id: _builtins.str,
                 repo_type: _builtins.str,
                 report_build_status: _builtins.bool,
                 service_connection_id: _builtins.str,
                 url: _builtins.str,
                 yml_path: _builtins.str):
        """
        :param _builtins.str branch_name: The branch name for which builds are triggered.
        :param _builtins.str github_enterprise_url: The Github Enterprise URL.
        :param _builtins.str repo_id: The id of the repository.
        :param _builtins.str repo_type: The repository type.
        :param _builtins.bool report_build_status: Report build status.
        :param _builtins.str service_connection_id: The service connection ID.
        :param _builtins.str yml_path: The path of the Yaml file describing the build definition.
        """
        pulumi.set(__self__, "branch_name", branch_name)
        pulumi.set(__self__, "github_enterprise_url", github_enterprise_url)
        pulumi.set(__self__, "repo_id", repo_id)
        pulumi.set(__self__, "repo_type", repo_type)
        pulumi.set(__self__, "report_build_status", report_build_status)
        pulumi.set(__self__, "service_connection_id", service_connection_id)
        pulumi.set(__self__, "url", url)
        pulumi.set(__self__, "yml_path", yml_path)

    @_builtins.property
    @pulumi.getter(name="branchName")
    def branch_name(self) -> _builtins.str:
        """
        The branch name for which builds are triggered.
        """
        return pulumi.get(self, "branch_name")

    @_builtins.property
    @pulumi.getter(name="githubEnterpriseUrl")
    def github_enterprise_url(self) -> _builtins.str:
        """
        The Github Enterprise URL.
        """
        return pulumi.get(self, "github_enterprise_url")

    @_builtins.property
    @pulumi.getter(name="repoId")
    def repo_id(self) -> _builtins.str:
        """
        The id of the repository.
        """
        return pulumi.get(self, "repo_id")

    @_builtins.property
    @pulumi.getter(name="repoType")
    def repo_type(self) -> _builtins.str:
        """
        The repository type.
        """
        return pulumi.get(self, "repo_type")

    @_builtins.property
    @pulumi.getter(name="reportBuildStatus")
    def report_build_status(self) -> _builtins.bool:
        """
        Report build status.
        """
        return pulumi.get(self, "report_build_status")

    @_builtins.property
    @pulumi.getter(name="serviceConnectionId")
    def service_connection_id(self) -> _builtins.str:
        """
        The service connection ID.
        """
        return pulumi.get(self, "service_connection_id")

    @_builtins.property
    @pulumi.getter
    def url(self) -> _builtins.str:
        return pulumi.get(self, "url")

    @_builtins.property
    @pulumi.getter(name="ymlPath")
    def yml_path(self) -> _builtins.str:
        """
        The path of the Yaml file describing the build definition.
        """
        return pulumi.get(self, "yml_path")


@pulumi.output_type
class GetBuildDefinitionScheduleResult(dict):
    def __init__(__self__, *,
                 branch_filters: Sequence['outputs.GetBuildDefinitionScheduleBranchFilterResult'],
                 days_to_builds: Sequence[_builtins.str],
                 schedule_job_id: _builtins.str,
                 schedule_only_with_changes: _builtins.bool,
                 start_hours: _builtins.int,
                 start_minutes: _builtins.int,
                 time_zone: _builtins.str):
        """
        :param Sequence['GetBuildDefinitionScheduleBranchFilterArgs'] branch_filters: A `branch_filter` block as defined above.
        :param Sequence[_builtins.str] days_to_builds: A list of days to build on.
        :param _builtins.str schedule_job_id: The ID of the schedule job.
        :param _builtins.bool schedule_only_with_changes: Schedule builds if the source or pipeline has changed.
        :param _builtins.int start_hours: Build start hour.
        :param _builtins.int start_minutes: Build start minute.
        :param _builtins.str time_zone: Build time zone.
        """
        pulumi.set(__self__, "branch_filters", branch_filters)
        pulumi.set(__self__, "days_to_builds", days_to_builds)
        pulumi.set(__self__, "schedule_job_id", schedule_job_id)
        pulumi.set(__self__, "schedule_only_with_changes", schedule_only_with_changes)
        pulumi.set(__self__, "start_hours", start_hours)
        pulumi.set(__self__, "start_minutes", start_minutes)
        pulumi.set(__self__, "time_zone", time_zone)

    @_builtins.property
    @pulumi.getter(name="branchFilters")
    def branch_filters(self) -> Sequence['outputs.GetBuildDefinitionScheduleBranchFilterResult']:
        """
        A `branch_filter` block as defined above.
        """
        return pulumi.get(self, "branch_filters")

    @_builtins.property
    @pulumi.getter(name="daysToBuilds")
    def days_to_builds(self) -> Sequence[_builtins.str]:
        """
        A list of days to build on.
        """
        return pulumi.get(self, "days_to_builds")

    @_builtins.property
    @pulumi.getter(name="scheduleJobId")
    def schedule_job_id(self) -> _builtins.str:
        """
        The ID of the schedule job.
        """
        return pulumi.get(self, "schedule_job_id")

    @_builtins.property
    @pulumi.getter(name="scheduleOnlyWithChanges")
    def schedule_only_with_changes(self) -> _builtins.bool:
        """
        Schedule builds if the source or pipeline has changed.
        """
        return pulumi.get(self, "schedule_only_with_changes")

    @_builtins.property
    @pulumi.getter(name="startHours")
    def start_hours(self) -> _builtins.int:
        """
        Build start hour.
        """
        return pulumi.get(self, "start_hours")

    @_builtins.property
    @pulumi.getter(name="startMinutes")
    def start_minutes(self) -> _builtins.int:
        """
        Build start minute.
        """
        return pulumi.get(self, "start_minutes")

    @_builtins.property
    @pulumi.getter(name="timeZone")
    def time_zone(self) -> _builtins.str:
        """
        Build time zone.
        """
        return pulumi.get(self, "time_zone")


@pulumi.output_type
class GetBuildDefinitionScheduleBranchFilterResult(dict):
    def __init__(__self__, *,
                 excludes: Sequence[_builtins.str],
                 includes: Sequence[_builtins.str]):
        """
        :param Sequence[_builtins.str] excludes: (Optional) List of path patterns to exclude.
        :param Sequence[_builtins.str] includes: (Optional) List of path patterns to include.
        """
        pulumi.set(__self__, "excludes", excludes)
        pulumi.set(__self__, "includes", includes)

    @_builtins.property
    @pulumi.getter
    def excludes(self) -> Sequence[_builtins.str]:
        """
        (Optional) List of path patterns to exclude.
        """
        return pulumi.get(self, "excludes")

    @_builtins.property
    @pulumi.getter
    def includes(self) -> Sequence[_builtins.str]:
        """
        (Optional) List of path patterns to include.
        """
        return pulumi.get(self, "includes")


@pulumi.output_type
class GetBuildDefinitionVariableResult(dict):
    def __init__(__self__, *,
                 allow_override: _builtins.bool,
                 is_secret: _builtins.bool,
                 name: _builtins.str,
                 secret_value: _builtins.str,
                 value: _builtins.str):
        """
        :param _builtins.bool allow_override: `true` if the variable can be overridden.
        :param _builtins.bool is_secret: `true` if the variable is a secret.
        :param _builtins.str name: The name of this Build Definition.
        :param _builtins.str secret_value: The secret value of the variable.
        :param _builtins.str value: The value of the variable.
        """
        pulumi.set(__self__, "allow_override", allow_override)
        pulumi.set(__self__, "is_secret", is_secret)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "secret_value", secret_value)
        pulumi.set(__self__, "value", value)

    @_builtins.property
    @pulumi.getter(name="allowOverride")
    def allow_override(self) -> _builtins.bool:
        """
        `true` if the variable can be overridden.
        """
        return pulumi.get(self, "allow_override")

    @_builtins.property
    @pulumi.getter(name="isSecret")
    def is_secret(self) -> _builtins.bool:
        """
        `true` if the variable is a secret.
        """
        return pulumi.get(self, "is_secret")

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        The name of this Build Definition.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter(name="secretValue")
    def secret_value(self) -> _builtins.str:
        """
        The secret value of the variable.
        """
        return pulumi.get(self, "secret_value")

    @_builtins.property
    @pulumi.getter
    def value(self) -> _builtins.str:
        """
        The value of the variable.
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class GetGroupsGroupResult(dict):
    def __init__(__self__, *,
                 descriptor: _builtins.str,
                 domain: _builtins.str,
                 id: _builtins.str,
                 origin: _builtins.str,
                 principal_name: _builtins.str,
                 url: _builtins.str,
                 description: Optional[_builtins.str] = None,
                 display_name: Optional[_builtins.str] = None,
                 mail_address: Optional[_builtins.str] = None,
                 origin_id: Optional[_builtins.str] = None):
        """
        :param _builtins.str descriptor: The descriptor is the primary way to reference the graph subject while the system is running. This field will uniquely identify the same graph subject across both Accounts and Organizations.
        :param _builtins.str domain: This represents the name of the container of origin for a graph member. (For MSA this is "Windows Live ID", for AD the name of the domain, for AAD the tenantID of the directory, for VSTS groups the ScopeId, etc)
        :param _builtins.str id: The ID(UUID format) of the group.
        :param _builtins.str origin: The type of source provider for the origin identifier (ex:AD, AAD, MSA)
        :param _builtins.str principal_name: This is the PrincipalName of this graph member from the source provider. The source provider may change this field over time and it is not guaranteed to be immutable for the life of the graph member by VSTS.
        :param _builtins.str url: This url is the full route to the source resource of this graph subject.
        :param _builtins.str description: A short phrase to help human readers disambiguate groups with similar names
        :param _builtins.str display_name: This is the non-unique display name of the graph subject. To change this field, you must alter its value in the source provider.
        :param _builtins.str mail_address: The email address of record for a given graph member. This may be different than the principal name.
        :param _builtins.str origin_id: The unique identifier from the system of origin. Typically a sid, object id or Guid. Linking and unlinking operations can cause this value to change for a user because the user is not backed by a different provider and has a different unique id in the new provider.
        """
        pulumi.set(__self__, "descriptor", descriptor)
        pulumi.set(__self__, "domain", domain)
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "origin", origin)
        pulumi.set(__self__, "principal_name", principal_name)
        pulumi.set(__self__, "url", url)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if display_name is not None:
            pulumi.set(__self__, "display_name", display_name)
        if mail_address is not None:
            pulumi.set(__self__, "mail_address", mail_address)
        if origin_id is not None:
            pulumi.set(__self__, "origin_id", origin_id)

    @_builtins.property
    @pulumi.getter
    def descriptor(self) -> _builtins.str:
        """
        The descriptor is the primary way to reference the graph subject while the system is running. This field will uniquely identify the same graph subject across both Accounts and Organizations.
        """
        return pulumi.get(self, "descriptor")

    @_builtins.property
    @pulumi.getter
    def domain(self) -> _builtins.str:
        """
        This represents the name of the container of origin for a graph member. (For MSA this is "Windows Live ID", for AD the name of the domain, for AAD the tenantID of the directory, for VSTS groups the ScopeId, etc)
        """
        return pulumi.get(self, "domain")

    @_builtins.property
    @pulumi.getter
    def id(self) -> _builtins.str:
        """
        The ID(UUID format) of the group.
        """
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter
    def origin(self) -> _builtins.str:
        """
        The type of source provider for the origin identifier (ex:AD, AAD, MSA)
        """
        return pulumi.get(self, "origin")

    @_builtins.property
    @pulumi.getter(name="principalName")
    def principal_name(self) -> _builtins.str:
        """
        This is the PrincipalName of this graph member from the source provider. The source provider may change this field over time and it is not guaranteed to be immutable for the life of the graph member by VSTS.
        """
        return pulumi.get(self, "principal_name")

    @_builtins.property
    @pulumi.getter
    def url(self) -> _builtins.str:
        """
        This url is the full route to the source resource of this graph subject.
        """
        return pulumi.get(self, "url")

    @_builtins.property
    @pulumi.getter
    def description(self) -> Optional[_builtins.str]:
        """
        A short phrase to help human readers disambiguate groups with similar names
        """
        return pulumi.get(self, "description")

    @_builtins.property
    @pulumi.getter(name="displayName")
    def display_name(self) -> Optional[_builtins.str]:
        """
        This is the non-unique display name of the graph subject. To change this field, you must alter its value in the source provider.
        """
        return pulumi.get(self, "display_name")

    @_builtins.property
    @pulumi.getter(name="mailAddress")
    def mail_address(self) -> Optional[_builtins.str]:
        """
        The email address of record for a given graph member. This may be different than the principal name.
        """
        return pulumi.get(self, "mail_address")

    @_builtins.property
    @pulumi.getter(name="originId")
    def origin_id(self) -> Optional[_builtins.str]:
        """
        The unique identifier from the system of origin. Typically a sid, object id or Guid. Linking and unlinking operations can cause this value to change for a user because the user is not backed by a different provider and has a different unique id in the new provider.
        """
        return pulumi.get(self, "origin_id")


@pulumi.output_type
class GetIdentityGroupsGroupResult(dict):
    def __init__(__self__, *,
                 descriptor: _builtins.str,
                 id: _builtins.str,
                 name: _builtins.str,
                 subject_descriptor: _builtins.str):
        """
        :param _builtins.str descriptor: The descriptor of the Identity Group.
        :param _builtins.str id: The ID of the Identity Group.
        :param _builtins.str name: This is the non-unique display name of the identity subject.
        :param _builtins.str subject_descriptor: The subject descriptor of the identity group.
        """
        pulumi.set(__self__, "descriptor", descriptor)
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "subject_descriptor", subject_descriptor)

    @_builtins.property
    @pulumi.getter
    def descriptor(self) -> _builtins.str:
        """
        The descriptor of the Identity Group.
        """
        return pulumi.get(self, "descriptor")

    @_builtins.property
    @pulumi.getter
    def id(self) -> _builtins.str:
        """
        The ID of the Identity Group.
        """
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        This is the non-unique display name of the identity subject.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter(name="subjectDescriptor")
    def subject_descriptor(self) -> _builtins.str:
        """
        The subject descriptor of the identity group.
        """
        return pulumi.get(self, "subject_descriptor")


@pulumi.output_type
class GetIterationChildrenResult(dict):
    def __init__(__self__, *,
                 has_children: _builtins.bool,
                 id: _builtins.str,
                 name: _builtins.str,
                 path: _builtins.str,
                 project_id: _builtins.str):
        """
        :param _builtins.bool has_children: Indicator if the child Iteration node has child nodes
        :param _builtins.str id: The ID of the child Iteration node
        :param _builtins.str name: The name of the child Iteration node
        :param _builtins.str path: The path to the Iteration, _Format_: URL relative; if omitted, or value `"/"` is used, the root Iteration will be returned
        :param _builtins.str project_id: The project ID.
        """
        pulumi.set(__self__, "has_children", has_children)
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "path", path)
        pulumi.set(__self__, "project_id", project_id)

    @_builtins.property
    @pulumi.getter(name="hasChildren")
    def has_children(self) -> _builtins.bool:
        """
        Indicator if the child Iteration node has child nodes
        """
        return pulumi.get(self, "has_children")

    @_builtins.property
    @pulumi.getter
    def id(self) -> _builtins.str:
        """
        The ID of the child Iteration node
        """
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        The name of the child Iteration node
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def path(self) -> _builtins.str:
        """
        The path to the Iteration, _Format_: URL relative; if omitted, or value `"/"` is used, the root Iteration will be returned
        """
        return pulumi.get(self, "path")

    @_builtins.property
    @pulumi.getter(name="projectId")
    def project_id(self) -> _builtins.str:
        """
        The project ID.
        """
        return pulumi.get(self, "project_id")


@pulumi.output_type
class GetPoolsAgentPoolResult(dict):
    def __init__(__self__, *,
                 auto_provision: _builtins.bool,
                 auto_update: _builtins.bool,
                 id: _builtins.int,
                 name: _builtins.str,
                 pool_type: _builtins.str):
        """
        :param _builtins.bool auto_provision: Specifies whether or not a queue should be automatically provisioned for each project collection.
        :param _builtins.bool auto_update: Specifies whether or not agents within the pool should be automatically updated.
        :param _builtins.int id: The ID of the agent pool.
        :param _builtins.str name: The name of the agent pool.
        :param _builtins.str pool_type: Specifies whether the agent pool type is Automation or Deployment.
        """
        pulumi.set(__self__, "auto_provision", auto_provision)
        pulumi.set(__self__, "auto_update", auto_update)
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "pool_type", pool_type)

    @_builtins.property
    @pulumi.getter(name="autoProvision")
    def auto_provision(self) -> _builtins.bool:
        """
        Specifies whether or not a queue should be automatically provisioned for each project collection.
        """
        return pulumi.get(self, "auto_provision")

    @_builtins.property
    @pulumi.getter(name="autoUpdate")
    def auto_update(self) -> _builtins.bool:
        """
        Specifies whether or not agents within the pool should be automatically updated.
        """
        return pulumi.get(self, "auto_update")

    @_builtins.property
    @pulumi.getter
    def id(self) -> _builtins.int:
        """
        The ID of the agent pool.
        """
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        The name of the agent pool.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter(name="poolType")
    def pool_type(self) -> _builtins.str:
        """
        Specifies whether the agent pool type is Automation or Deployment.
        """
        return pulumi.get(self, "pool_type")


@pulumi.output_type
class GetProjectsProjectResult(dict):
    def __init__(__self__, *,
                 name: _builtins.str,
                 project_id: _builtins.str,
                 project_url: _builtins.str,
                 state: _builtins.str):
        """
        :param _builtins.str name: Name of the Project, if not specified all projects will be returned.
        :param _builtins.str project_id: The ID of the Project.
        :param _builtins.str project_url: The Url to the full version of the object.
        :param _builtins.str state: State of the Project, if not specified all projects will be returned. Valid values are `all`, `deleting`, `new`, `wellFormed`, `createPending`, `unchanged`,`deleted`.
               
               > **NOTE:** DataSource without specifying any arguments will return all projects.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "project_id", project_id)
        pulumi.set(__self__, "project_url", project_url)
        pulumi.set(__self__, "state", state)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        Name of the Project, if not specified all projects will be returned.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter(name="projectId")
    def project_id(self) -> _builtins.str:
        """
        The ID of the Project.
        """
        return pulumi.get(self, "project_id")

    @_builtins.property
    @pulumi.getter(name="projectUrl")
    def project_url(self) -> _builtins.str:
        """
        The Url to the full version of the object.
        """
        return pulumi.get(self, "project_url")

    @_builtins.property
    @pulumi.getter
    def state(self) -> _builtins.str:
        """
        State of the Project, if not specified all projects will be returned. Valid values are `all`, `deleting`, `new`, `wellFormed`, `createPending`, `unchanged`,`deleted`.

        > **NOTE:** DataSource without specifying any arguments will return all projects.
        """
        return pulumi.get(self, "state")


@pulumi.output_type
class GetRepositoriesRepositoryResult(dict):
    def __init__(__self__, *,
                 default_branch: _builtins.str,
                 disabled: _builtins.bool,
                 id: _builtins.str,
                 name: _builtins.str,
                 project_id: _builtins.str,
                 remote_url: _builtins.str,
                 size: _builtins.int,
                 ssh_url: _builtins.str,
                 url: _builtins.str,
                 web_url: _builtins.str):
        """
        :param _builtins.str default_branch: The ref of the default branch.
        :param _builtins.bool disabled: Is the repository disabled?
        :param _builtins.str id: Git repository identifier.
        :param _builtins.str name: Name of the Git repository to retrieve; requires `project_id` to be specified as well
        :param _builtins.str project_id: ID of project to list Git repositories
        :param _builtins.str remote_url: HTTPS Url to clone the Git repository
        :param _builtins.int size: Compressed size (bytes) of the repository.
        :param _builtins.str ssh_url: SSH Url to clone the Git repository
        :param _builtins.str url: Details REST API endpoint for the Git Repository.
        :param _builtins.str web_url: Url of the Git repository web view
        """
        pulumi.set(__self__, "default_branch", default_branch)
        pulumi.set(__self__, "disabled", disabled)
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "project_id", project_id)
        pulumi.set(__self__, "remote_url", remote_url)
        pulumi.set(__self__, "size", size)
        pulumi.set(__self__, "ssh_url", ssh_url)
        pulumi.set(__self__, "url", url)
        pulumi.set(__self__, "web_url", web_url)

    @_builtins.property
    @pulumi.getter(name="defaultBranch")
    def default_branch(self) -> _builtins.str:
        """
        The ref of the default branch.
        """
        return pulumi.get(self, "default_branch")

    @_builtins.property
    @pulumi.getter
    def disabled(self) -> _builtins.bool:
        """
        Is the repository disabled?
        """
        return pulumi.get(self, "disabled")

    @_builtins.property
    @pulumi.getter
    def id(self) -> _builtins.str:
        """
        Git repository identifier.
        """
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        Name of the Git repository to retrieve; requires `project_id` to be specified as well
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter(name="projectId")
    def project_id(self) -> _builtins.str:
        """
        ID of project to list Git repositories
        """
        return pulumi.get(self, "project_id")

    @_builtins.property
    @pulumi.getter(name="remoteUrl")
    def remote_url(self) -> _builtins.str:
        """
        HTTPS Url to clone the Git repository
        """
        return pulumi.get(self, "remote_url")

    @_builtins.property
    @pulumi.getter
    def size(self) -> _builtins.int:
        """
        Compressed size (bytes) of the repository.
        """
        return pulumi.get(self, "size")

    @_builtins.property
    @pulumi.getter(name="sshUrl")
    def ssh_url(self) -> _builtins.str:
        """
        SSH Url to clone the Git repository
        """
        return pulumi.get(self, "ssh_url")

    @_builtins.property
    @pulumi.getter
    def url(self) -> _builtins.str:
        """
        Details REST API endpoint for the Git Repository.
        """
        return pulumi.get(self, "url")

    @_builtins.property
    @pulumi.getter(name="webUrl")
    def web_url(self) -> _builtins.str:
        """
        Url of the Git repository web view
        """
        return pulumi.get(self, "web_url")


@pulumi.output_type
class GetSecurityroleDefinitionsDefinitionResult(dict):
    def __init__(__self__, *,
                 allow_permissions: _builtins.int,
                 description: _builtins.str,
                 display_name: _builtins.str,
                 identifier: _builtins.str,
                 name: _builtins.str,
                 scope: _builtins.str,
                 deny_permissions: Optional[_builtins.int] = None):
        """
        :param _builtins.int allow_permissions: The mask of allowed permissions of the Security Role Definition.
        :param _builtins.str description: The description of the Security Role Definition.
        :param _builtins.str display_name: The display name of the Security Role Definition.
        :param _builtins.str identifier: The identifier of the Security Role Definition.
        :param _builtins.str name: The name of the Security Role Definition.
        :param _builtins.str scope: Name of the Scope for which Security Role Definitions will be returned.
               
               > **NOTE:** DataSource without specifying any arguments will return all projects.
        :param _builtins.int deny_permissions: The mask of the denied permissions of the Security Role Definition.
        """
        pulumi.set(__self__, "allow_permissions", allow_permissions)
        pulumi.set(__self__, "description", description)
        pulumi.set(__self__, "display_name", display_name)
        pulumi.set(__self__, "identifier", identifier)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "scope", scope)
        if deny_permissions is not None:
            pulumi.set(__self__, "deny_permissions", deny_permissions)

    @_builtins.property
    @pulumi.getter(name="allowPermissions")
    def allow_permissions(self) -> _builtins.int:
        """
        The mask of allowed permissions of the Security Role Definition.
        """
        return pulumi.get(self, "allow_permissions")

    @_builtins.property
    @pulumi.getter
    def description(self) -> _builtins.str:
        """
        The description of the Security Role Definition.
        """
        return pulumi.get(self, "description")

    @_builtins.property
    @pulumi.getter(name="displayName")
    def display_name(self) -> _builtins.str:
        """
        The display name of the Security Role Definition.
        """
        return pulumi.get(self, "display_name")

    @_builtins.property
    @pulumi.getter
    def identifier(self) -> _builtins.str:
        """
        The identifier of the Security Role Definition.
        """
        return pulumi.get(self, "identifier")

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        The name of the Security Role Definition.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def scope(self) -> _builtins.str:
        """
        Name of the Scope for which Security Role Definitions will be returned.

        > **NOTE:** DataSource without specifying any arguments will return all projects.
        """
        return pulumi.get(self, "scope")

    @_builtins.property
    @pulumi.getter(name="denyPermissions")
    def deny_permissions(self) -> Optional[_builtins.int]:
        """
        The mask of the denied permissions of the Security Role Definition.
        """
        return pulumi.get(self, "deny_permissions")


@pulumi.output_type
class GetTeamsTeamResult(dict):
    def __init__(__self__, *,
                 administrators: Sequence[_builtins.str],
                 description: _builtins.str,
                 id: _builtins.str,
                 members: Sequence[_builtins.str],
                 name: _builtins.str,
                 project_id: _builtins.str):
        """
        :param Sequence[_builtins.str] administrators: List of subject descriptors for `administrators` of the team.
        :param _builtins.str description: Team description.
        :param _builtins.str id: The ID of the Team.
        :param Sequence[_builtins.str] members: List of subject descriptors for `members` of the team.
        :param _builtins.str name: The name of the team.
        :param _builtins.str project_id: The Project ID. If no project ID all teams of the organization will be returned.
        """
        pulumi.set(__self__, "administrators", administrators)
        pulumi.set(__self__, "description", description)
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "members", members)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "project_id", project_id)

    @_builtins.property
    @pulumi.getter
    def administrators(self) -> Sequence[_builtins.str]:
        """
        List of subject descriptors for `administrators` of the team.
        """
        return pulumi.get(self, "administrators")

    @_builtins.property
    @pulumi.getter
    def description(self) -> _builtins.str:
        """
        Team description.
        """
        return pulumi.get(self, "description")

    @_builtins.property
    @pulumi.getter
    def id(self) -> _builtins.str:
        """
        The ID of the Team.
        """
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter
    def members(self) -> Sequence[_builtins.str]:
        """
        List of subject descriptors for `members` of the team.
        """
        return pulumi.get(self, "members")

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        The name of the team.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter(name="projectId")
    def project_id(self) -> _builtins.str:
        """
        The Project ID. If no project ID all teams of the organization will be returned.
        """
        return pulumi.get(self, "project_id")


@pulumi.output_type
class GetUsersFeaturesResult(dict):
    def __init__(__self__, *,
                 concurrent_workers: Optional[_builtins.int] = None):
        """
        :param _builtins.int concurrent_workers: Number of workers to process user data concurrently.
               
               > **Note** Setting `concurrent_workers` to a value greater than 1 can greatly decrease the time it takes to read the data source.
        """
        if concurrent_workers is not None:
            pulumi.set(__self__, "concurrent_workers", concurrent_workers)

    @_builtins.property
    @pulumi.getter(name="concurrentWorkers")
    def concurrent_workers(self) -> Optional[_builtins.int]:
        """
        Number of workers to process user data concurrently.

        > **Note** Setting `concurrent_workers` to a value greater than 1 can greatly decrease the time it takes to read the data source.
        """
        return pulumi.get(self, "concurrent_workers")


@pulumi.output_type
class GetUsersUserResult(dict):
    def __init__(__self__, *,
                 descriptor: _builtins.str,
                 display_name: _builtins.str,
                 id: _builtins.str,
                 mail_address: _builtins.str,
                 origin: _builtins.str,
                 principal_name: _builtins.str,
                 origin_id: Optional[_builtins.str] = None):
        """
        :param _builtins.str descriptor: The descriptor is the primary way to reference the graph subject while the system is running. This field will uniquely identify the same graph subject across both Accounts and Organizations.
        :param _builtins.str display_name: This is the non-unique display name of the graph subject. To change this field, you must alter its value in the source provider.
        :param _builtins.str id: The ID of the User.
        :param _builtins.str mail_address: The email address of record for a given graph member. This may be different than the principal name.
        :param _builtins.str origin: The type of source provider for the `origin_id` parameter (ex:AD, AAD, MSA) The supported origins are listed below.
               <pre>List of possible origins
               ```hcl
               ActiveDirectory          = "ad"   # Windows Active Directory
               AzureActiveDirectory     = "aad"  # Azure Active Directory
               MicrosoftAccount         = "msa"  # Windows Live Account
               VisualStudioTeamServices = "vsts" # DevOps
               GitHubDirectory          = "ghb"  # GitHub
               ```
               </pre>
        :param _builtins.str principal_name: The PrincipalName of this graph member from the source provider.
        :param _builtins.str origin_id: The unique identifier from the system of origin.
        """
        pulumi.set(__self__, "descriptor", descriptor)
        pulumi.set(__self__, "display_name", display_name)
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "mail_address", mail_address)
        pulumi.set(__self__, "origin", origin)
        pulumi.set(__self__, "principal_name", principal_name)
        if origin_id is not None:
            pulumi.set(__self__, "origin_id", origin_id)

    @_builtins.property
    @pulumi.getter
    def descriptor(self) -> _builtins.str:
        """
        The descriptor is the primary way to reference the graph subject while the system is running. This field will uniquely identify the same graph subject across both Accounts and Organizations.
        """
        return pulumi.get(self, "descriptor")

    @_builtins.property
    @pulumi.getter(name="displayName")
    def display_name(self) -> _builtins.str:
        """
        This is the non-unique display name of the graph subject. To change this field, you must alter its value in the source provider.
        """
        return pulumi.get(self, "display_name")

    @_builtins.property
    @pulumi.getter
    def id(self) -> _builtins.str:
        """
        The ID of the User.
        """
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter(name="mailAddress")
    def mail_address(self) -> _builtins.str:
        """
        The email address of record for a given graph member. This may be different than the principal name.
        """
        return pulumi.get(self, "mail_address")

    @_builtins.property
    @pulumi.getter
    def origin(self) -> _builtins.str:
        """
        The type of source provider for the `origin_id` parameter (ex:AD, AAD, MSA) The supported origins are listed below.
        <pre>List of possible origins
        ```hcl
        ActiveDirectory          = "ad"   # Windows Active Directory
        AzureActiveDirectory     = "aad"  # Azure Active Directory
        MicrosoftAccount         = "msa"  # Windows Live Account
        VisualStudioTeamServices = "vsts" # DevOps
        GitHubDirectory          = "ghb"  # GitHub
        ```
        </pre>
        """
        return pulumi.get(self, "origin")

    @_builtins.property
    @pulumi.getter(name="principalName")
    def principal_name(self) -> _builtins.str:
        """
        The PrincipalName of this graph member from the source provider.
        """
        return pulumi.get(self, "principal_name")

    @_builtins.property
    @pulumi.getter(name="originId")
    def origin_id(self) -> Optional[_builtins.str]:
        """
        The unique identifier from the system of origin.
        """
        return pulumi.get(self, "origin_id")


@pulumi.output_type
class GetVariableGroupKeyVaultResult(dict):
    def __init__(__self__, *,
                 name: _builtins.str,
                 service_endpoint_id: _builtins.str):
        """
        :param _builtins.str name: The name of the Variable Group to retrieve.
        :param _builtins.str service_endpoint_id: The id of the Azure subscription endpoint to access the key vault.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "service_endpoint_id", service_endpoint_id)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        The name of the Variable Group to retrieve.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter(name="serviceEndpointId")
    def service_endpoint_id(self) -> _builtins.str:
        """
        The id of the Azure subscription endpoint to access the key vault.
        """
        return pulumi.get(self, "service_endpoint_id")


@pulumi.output_type
class GetVariableGroupVariableResult(dict):
    def __init__(__self__, *,
                 content_type: _builtins.str,
                 enabled: _builtins.bool,
                 expires: _builtins.str,
                 is_secret: _builtins.bool,
                 name: _builtins.str,
                 secret_value: _builtins.str,
                 value: _builtins.str):
        """
        :param _builtins.bool is_secret: A boolean flag describing if the variable value is sensitive.
        :param _builtins.str name: The name of the Variable Group to retrieve.
        :param _builtins.str secret_value: The secret value of the variable.
        :param _builtins.str value: The value of the variable.
        """
        pulumi.set(__self__, "content_type", content_type)
        pulumi.set(__self__, "enabled", enabled)
        pulumi.set(__self__, "expires", expires)
        pulumi.set(__self__, "is_secret", is_secret)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "secret_value", secret_value)
        pulumi.set(__self__, "value", value)

    @_builtins.property
    @pulumi.getter(name="contentType")
    def content_type(self) -> _builtins.str:
        return pulumi.get(self, "content_type")

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> _builtins.bool:
        return pulumi.get(self, "enabled")

    @_builtins.property
    @pulumi.getter
    def expires(self) -> _builtins.str:
        return pulumi.get(self, "expires")

    @_builtins.property
    @pulumi.getter(name="isSecret")
    def is_secret(self) -> _builtins.bool:
        """
        A boolean flag describing if the variable value is sensitive.
        """
        return pulumi.get(self, "is_secret")

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        The name of the Variable Group to retrieve.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter(name="secretValue")
    def secret_value(self) -> _builtins.str:
        """
        The secret value of the variable.
        """
        return pulumi.get(self, "secret_value")

    @_builtins.property
    @pulumi.getter
    def value(self) -> _builtins.str:
        """
        The value of the variable.
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class GetWorkitemtrackingprocessProcessProjectResult(dict):
    def __init__(__self__, *,
                 description: _builtins.str,
                 id: _builtins.str,
                 name: _builtins.str,
                 url: _builtins.str):
        """
        :param _builtins.str description: Description of the project.
        :param _builtins.str id: The ID of the process.
        :param _builtins.str name: Name of the project.
        :param _builtins.str url: Url of the project.
        """
        pulumi.set(__self__, "description", description)
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "url", url)

    @_builtins.property
    @pulumi.getter
    def description(self) -> _builtins.str:
        """
        Description of the project.
        """
        return pulumi.get(self, "description")

    @_builtins.property
    @pulumi.getter
    def id(self) -> _builtins.str:
        """
        The ID of the process.
        """
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        Name of the project.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def url(self) -> _builtins.str:
        """
        Url of the project.
        """
        return pulumi.get(self, "url")


@pulumi.output_type
class GetWorkitemtrackingprocessProcessesProcessResult(dict):
    def __init__(__self__, *,
                 customization_type: _builtins.str,
                 description: _builtins.str,
                 id: _builtins.str,
                 is_default: _builtins.bool,
                 is_enabled: _builtins.bool,
                 name: _builtins.str,
                 parent_process_type_id: _builtins.str,
                 projects: Sequence['outputs.GetWorkitemtrackingprocessProcessesProcessProjectResult'],
                 reference_name: _builtins.str):
        """
        :param _builtins.str customization_type: Indicates the type of customization on this process. System Process is default process. Inherited Process is modified process that was System process before.
        :param _builtins.str description: Description of the project.
        :param _builtins.str id: The ID of the project.
        :param _builtins.bool is_default: Is the process default?
        :param _builtins.bool is_enabled: Is the process enabled?
        :param _builtins.str name: Name of the project.
        :param _builtins.str parent_process_type_id: ID of the parent process.
        :param Sequence['GetWorkitemtrackingprocessProcessesProcessProjectArgs'] projects: A `projects` block as defined below. Returns associated projects when using the 'projects' expand option.
        :param _builtins.str reference_name: Reference name of process being created. If not specified, server will assign a unique reference name.
        """
        pulumi.set(__self__, "customization_type", customization_type)
        pulumi.set(__self__, "description", description)
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "is_default", is_default)
        pulumi.set(__self__, "is_enabled", is_enabled)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "parent_process_type_id", parent_process_type_id)
        pulumi.set(__self__, "projects", projects)
        pulumi.set(__self__, "reference_name", reference_name)

    @_builtins.property
    @pulumi.getter(name="customizationType")
    def customization_type(self) -> _builtins.str:
        """
        Indicates the type of customization on this process. System Process is default process. Inherited Process is modified process that was System process before.
        """
        return pulumi.get(self, "customization_type")

    @_builtins.property
    @pulumi.getter
    def description(self) -> _builtins.str:
        """
        Description of the project.
        """
        return pulumi.get(self, "description")

    @_builtins.property
    @pulumi.getter
    def id(self) -> _builtins.str:
        """
        The ID of the project.
        """
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter(name="isDefault")
    def is_default(self) -> _builtins.bool:
        """
        Is the process default?
        """
        return pulumi.get(self, "is_default")

    @_builtins.property
    @pulumi.getter(name="isEnabled")
    def is_enabled(self) -> _builtins.bool:
        """
        Is the process enabled?
        """
        return pulumi.get(self, "is_enabled")

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        Name of the project.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter(name="parentProcessTypeId")
    def parent_process_type_id(self) -> _builtins.str:
        """
        ID of the parent process.
        """
        return pulumi.get(self, "parent_process_type_id")

    @_builtins.property
    @pulumi.getter
    def projects(self) -> Sequence['outputs.GetWorkitemtrackingprocessProcessesProcessProjectResult']:
        """
        A `projects` block as defined below. Returns associated projects when using the 'projects' expand option.
        """
        return pulumi.get(self, "projects")

    @_builtins.property
    @pulumi.getter(name="referenceName")
    def reference_name(self) -> _builtins.str:
        """
        Reference name of process being created. If not specified, server will assign a unique reference name.
        """
        return pulumi.get(self, "reference_name")


@pulumi.output_type
class GetWorkitemtrackingprocessProcessesProcessProjectResult(dict):
    def __init__(__self__, *,
                 description: _builtins.str,
                 id: _builtins.str,
                 name: _builtins.str,
                 url: _builtins.str):
        """
        :param _builtins.str description: Description of the project.
        :param _builtins.str id: The ID of the project.
        :param _builtins.str name: Name of the project.
        :param _builtins.str url: Url of the project.
        """
        pulumi.set(__self__, "description", description)
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "url", url)

    @_builtins.property
    @pulumi.getter
    def description(self) -> _builtins.str:
        """
        Description of the project.
        """
        return pulumi.get(self, "description")

    @_builtins.property
    @pulumi.getter
    def id(self) -> _builtins.str:
        """
        The ID of the project.
        """
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        Name of the project.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def url(self) -> _builtins.str:
        """
        Url of the project.
        """
        return pulumi.get(self, "url")


