// *** WARNING: this file was generated by the Pulumi Terraform Bridge (tfgen) Tool. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

import * as pulumi from "@pulumi/pulumi";
import { input as inputs, output as outputs } from "../types";

export interface BranchPolicyAutoReviewersSettings {
    /**
     * Required reviewers ids. Supports multiples user Ids.
     */
    autoReviewerIds: string[];
    /**
     * Activity feed message, Message will appear in the activity feed of pull requests with automatically added reviewers.
     */
    message?: string;
    /**
     * Filter path(s) on which the policy is applied. Supports absolute paths, wildcards and multiple paths. Example: /WebApp/Models/Data.cs, /WebApp/* or *.cs,/WebApp/Models/Data.cs;ClientApp/Models/Data.cs.
     */
    pathFilters?: string[];
    /**
     * Controls which repositories and branches the policy will be enabled for. This block must be defined at least once.
     */
    scopes: outputs.BranchPolicyAutoReviewersSettingsScope[];
    /**
     * Controls whether or not the submitter's vote counts. Defaults to `false`.
     */
    submitterCanVote?: boolean;
}

export interface BranchPolicyAutoReviewersSettingsScope {
    /**
     * The match type to use when applying the policy. Supported values are `Exact` (default) or `Prefix`.
     */
    matchType?: string;
    /**
     * The repository ID. Needed only if the scope of the policy will be limited to a single repository.
     */
    repositoryId?: string;
    /**
     * The ref pattern to use for the match. If `matchType` is `Exact`, this should be a qualified ref such as `refs/heads/master`. If `matchType` is `Prefix`, this should be a ref path such as `refs/heads/releases`.
     */
    repositoryRef?: string;
}

export interface BranchPolicyBuildValidationSettings {
    /**
     * The ID of the build to monitor for the policy.
     */
    buildDefinitionId: number;
    /**
     * The display name for the policy.
     */
    displayName: string;
    /**
     * If a path filter is set, the policy will only apply when files which match the filter are changes. Not setting this field means that the policy will always apply. You can specify absolute paths and wildcards. Example: `["/WebApp/Models/Data.cs", "/WebApp/*", "*.cs"]`. Paths prefixed with "!" are excluded. Example: `["/WebApp/*", "!/WebApp/Tests/*"]`. Order is significant.
     */
    filenamePatterns?: string[];
    /**
     * If set to true, the build will need to be manually queued. Defaults to `false`
     */
    manualQueueOnly?: boolean;
    /**
     * True if the build should queue on source updates only. Defaults to `true`.
     */
    queueOnSourceUpdateOnly?: boolean;
    /**
     * Controls which repositories and branches the policy will be enabled for. This block must be defined at least once.
     */
    scopes: outputs.BranchPolicyBuildValidationSettingsScope[];
    /**
     * The number of minutes for which the build is valid. If `0`, the build will not expire. Defaults to `720` (12 hours).
     */
    validDuration?: number;
}

export interface BranchPolicyBuildValidationSettingsScope {
    /**
     * The match type to use when applying the policy. Supported values are `Exact` (default) or `Prefix`.
     */
    matchType?: string;
    /**
     * The repository ID. Needed only if the scope of the policy will be limited to a single repository.
     */
    repositoryId?: string;
    /**
     * The ref pattern to use for the match. If `matchType` is `Exact`, this should be a qualified ref such as `refs/heads/master`. If `matchType` is `Prefix`, this should be a ref path such as `refs/heads/releases`.
     */
    repositoryRef?: string;
}

export interface BranchPolicyCommentResolutionSettings {
    /**
     * Controls which repositories and branches the policy will be enabled for. This block must be defined at least once.
     */
    scopes: outputs.BranchPolicyCommentResolutionSettingsScope[];
}

export interface BranchPolicyCommentResolutionSettingsScope {
    /**
     * The match type to use when applying the policy. Supported values are `Exact` (default) or `Prefix`.
     */
    matchType?: string;
    /**
     * The repository ID. Needed only if the scope of the policy will be limited to a single repository.
     */
    repositoryId?: string;
    /**
     * The ref pattern to use for the match. If `matchType` is `Exact`, this should be a qualified ref such as `refs/heads/master`. If `matchType` is `Prefix`, this should be a ref path such as `refs/heads/releases`.
     */
    repositoryRef?: string;
}

export interface BranchPolicyMergeTypesSettings {
    /**
     * Allow basic merge with no fast forward. Defaults to `false`.
     */
    allowBasicNoFastForward?: boolean;
    /**
     * Allow rebase with fast forward. Defaults to `false`.
     */
    allowRebaseAndFastForward?: boolean;
    /**
     * Allow rebase with merge commit. Defaults to `false`.
     */
    allowRebaseWithMerge?: boolean;
    /**
     * Allow squash merge. Defaults to `false`
     */
    allowSquash?: boolean;
    /**
     * Controls which repositories and branches the policy will be enabled for. This block must be defined at least once.
     */
    scopes: outputs.BranchPolicyMergeTypesSettingsScope[];
}

export interface BranchPolicyMergeTypesSettingsScope {
    /**
     * The match type to use when applying the policy. Supported values are `Exact` (default) or `Prefix`.
     */
    matchType?: string;
    /**
     * The repository ID. Needed only if the scope of the policy will be limited to a single repository.
     */
    repositoryId?: string;
    /**
     * The ref pattern to use for the match. If `matchType` is `Exact`, this should be a qualified ref such as `refs/heads/master`. If `matchType` is `Prefix`, this should be a ref path such as `refs/heads/releases`.
     */
    repositoryRef?: string;
}

export interface BranchPolicyMinReviewersSettings {
    /**
     * Allow completion even if some reviewers vote to wait or reject. Defaults to `false`.
     */
    allowCompletionWithRejectsOrWaits?: boolean;
    /**
     * Prohibit the most recent pusher from approving their own changes. Defaults to `false`.
     */
    lastPusherCannotApprove?: boolean;
    /**
     * On last iteration require vote. Defaults to `false`.
     */
    onLastIterationRequireVote?: boolean;
    /**
     * When new changes are pushed reset all code reviewer votes. Defaults to `false`.
     */
    onPushResetAllVotes?: boolean;
    /**
     * When new changes are pushed reset all approval votes (does not reset votes to reject or wait). Defaults to `false`.
     */
    onPushResetApprovedVotes?: boolean;
    /**
     * The number of reviewers needed to approve.
     */
    reviewerCount?: number;
    /**
     * Controls which repositories and branches the policy will be enabled for. This block must be defined at least once.
     */
    scopes: outputs.BranchPolicyMinReviewersSettingsScope[];
    /**
     * Allow requesters to approve their own changes. Defaults to `false`.
     */
    submitterCanVote?: boolean;
}

export interface BranchPolicyMinReviewersSettingsScope {
    /**
     * The match type to use when applying the policy. Supported values are `Exact` (default) or `Prefix`.
     */
    matchType?: string;
    /**
     * The repository ID. Needed only if the scope of the policy will be limited to a single repository.
     */
    repositoryId?: string;
    /**
     * The ref pattern to use for the match. If `matchType` is `Exact`, this should be a qualified ref such as `refs/heads/master`. If `matchType` is `Prefix`, this should be a ref path such as `refs/heads/releases`.
     */
    repositoryRef?: string;
}

export interface BranchPolicyStatusCheckSettings {
    /**
     * Policy applicability. If policy `applicability` is `default`, apply unless "Not Applicable" 
     * status is posted to the pull request. If policy `applicability` is `conditional`, policy is applied only after a status
     * is posted to the pull request.
     */
    applicability?: string;
    /**
     * The authorized user can post the status.
     */
    authorId?: string;
    /**
     * The display name.
     */
    displayName?: string;
    /**
     * If a path filter is set, the policy will only apply when files which match the filter are changes. Not setting this field means that the policy will always apply. You can specify absolute paths and wildcards. Example: `["/WebApp/Models/Data.cs", "/WebApp/*", "*.cs"]`. Paths prefixed with "!" are excluded. Example: `["/WebApp/*", "!/WebApp/Tests/*"]`. Order is significant.
     */
    filenamePatterns?: string[];
    /**
     * The genre of the status to check (see [Microsoft Documentation](https://docs.microsoft.com/en-us/azure/devops/repos/git/pull-request-status?view=azure-devops#status-policy))
     */
    genre?: string;
    /**
     * Reset status whenever there are new changes.
     */
    invalidateOnUpdate?: boolean;
    /**
     * The status name to check.
     */
    name: string;
    /**
     * Controls which repositories and branches the policy will be enabled for. This block must be defined
     * at least once.
     */
    scopes: outputs.BranchPolicyStatusCheckSettingsScope[];
}

export interface BranchPolicyStatusCheckSettingsScope {
    /**
     * The match type to use when applying the policy. Supported values are `Exact` (default)
     * or `Prefix`.
     */
    matchType?: string;
    /**
     * The repository ID. Needed only if the scope of the policy will be limited to a single
     * repository.
     */
    repositoryId?: string;
    /**
     * The ref pattern to use for the match. If `matchType` is `Exact`, this should be a
     * qualified ref such as `refs/heads/master`. If `matchType` is `Prefix`, this should be a ref path such
     * as `refs/heads/releases`.
     */
    repositoryRef?: string;
}

export interface BranchPolicyWorkItemLinkingSettings {
    /**
     * Controls which repositories and branches the policy will be enabled for. This block must be defined at least once.
     */
    scopes: outputs.BranchPolicyWorkItemLinkingSettingsScope[];
}

export interface BranchPolicyWorkItemLinkingSettingsScope {
    /**
     * The match type to use when applying the policy. Supported values are `Exact` (default) or `Prefix`.
     */
    matchType?: string;
    /**
     * The repository ID. Needed only if the scope of the policy will be limited to a single repository.
     */
    repositoryId?: string;
    /**
     * The ref pattern to use for the match. If `matchType` is `Exact`, this should be a qualified ref such as `refs/heads/master`. If `matchType` is `Prefix`, this should be a ref path such as `refs/heads/releases`.
     */
    repositoryRef?: string;
}

export interface BuildDefinitionCiTrigger {
    /**
     * Override the azure-pipeline file and use a this configuration for all builds.
     */
    override?: outputs.BuildDefinitionCiTriggerOverride;
    /**
     * Use the azure-pipeline file for the build configuration. Defaults to `false`.
     */
    useYaml?: boolean;
}

export interface BuildDefinitionCiTriggerOverride {
    /**
     * If you set batch to true, when a pipeline is running, the system waits until the run is completed, then starts another run with all changes that have not yet been built. Defaults to `true`.
     */
    batch?: boolean;
    /**
     * The branches to include and exclude from the trigger.
     */
    branchFilters?: outputs.BuildDefinitionCiTriggerOverrideBranchFilter[];
    /**
     * The number of max builds per branch. Defaults to `1`.
     */
    maxConcurrentBuildsPerBranch?: number;
    /**
     * Specify file paths to include or exclude. Note that the wildcard syntax is different between branches/tags and file paths.
     */
    pathFilters?: outputs.BuildDefinitionCiTriggerOverridePathFilter[];
    /**
     * How often the external repository is polled. Defaults to `0`.
     */
    pollingInterval?: number;
    /**
     * This is the ID of the polling job that polls the external repository. Once the build definition is saved/updated, this value is set.
     */
    pollingJobId: string;
}

export interface BuildDefinitionCiTriggerOverrideBranchFilter {
    /**
     * List of branch patterns to exclude.
     */
    excludes?: string[];
    /**
     * List of branch patterns to include.
     */
    includes?: string[];
}

export interface BuildDefinitionCiTriggerOverridePathFilter {
    /**
     * List of branch patterns to exclude.
     */
    excludes?: string[];
    /**
     * List of branch patterns to include.
     */
    includes?: string[];
}

export interface BuildDefinitionPullRequestTrigger {
    commentRequired?: string;
    /**
     * Set permissions for Forked repositories.
     */
    forks: outputs.BuildDefinitionPullRequestTriggerForks;
    initialBranch?: string;
    /**
     * Override the azure-pipeline file and use this configuration for all builds.
     */
    override?: outputs.BuildDefinitionPullRequestTriggerOverride;
    /**
     * Use the azure-pipeline file for the build configuration. Defaults to `false`.
     */
    useYaml?: boolean;
}

export interface BuildDefinitionPullRequestTriggerForks {
    /**
     * Build pull requests form forms of this repository.
     */
    enabled: boolean;
    /**
     * Make secrets available to builds of forks.
     */
    shareSecrets: boolean;
}

export interface BuildDefinitionPullRequestTriggerOverride {
    /**
     * . Defaults to `true`.
     */
    autoCancel?: boolean;
    /**
     * The branches to include and exclude from the trigger.
     */
    branchFilters?: outputs.BuildDefinitionPullRequestTriggerOverrideBranchFilter[];
    /**
     * Specify file paths to include or exclude. Note that the wildcard syntax is different between branches/tags and file paths.
     */
    pathFilters?: outputs.BuildDefinitionPullRequestTriggerOverridePathFilter[];
}

export interface BuildDefinitionPullRequestTriggerOverrideBranchFilter {
    /**
     * List of branch patterns to exclude.
     */
    excludes?: string[];
    /**
     * List of branch patterns to include.
     */
    includes?: string[];
}

export interface BuildDefinitionPullRequestTriggerOverridePathFilter {
    /**
     * List of branch patterns to exclude.
     */
    excludes?: string[];
    /**
     * List of branch patterns to include.
     */
    includes?: string[];
}

export interface BuildDefinitionRepository {
    /**
     * The branch name for which builds are triggered. Defaults to `master`.
     */
    branchName?: string;
    /**
     * The Github Enterprise URL. Used if `repoType` is `GithubEnterprise`.
     */
    githubEnterpriseUrl?: string;
    /**
     * The id of the repository. For `TfsGit` repos, this is simply the ID of the repository. For `Github` repos, this will take the form of `<GitHub Org>/<Repo Name>`. For `Bitbucket` repos, this will take the form of `<Workspace ID>/<Repo Name>`.
     */
    repoId: string;
    /**
     * The repository type. Valid values: `GitHub` or `TfsGit` or `Bitbucket` or `GitHub Enterprise`. Defaults to `GitHub`. If `repoType` is `GitHubEnterprise`, must use existing project and GitHub Enterprise service connection.
     */
    repoType: string;
    /**
     * Report build status. Default is true.
     */
    reportBuildStatus?: boolean;
    /**
     * The service connection ID. Used if the `repoType` is `GitHub` or `GitHubEnterprise`.
     */
    serviceConnectionId?: string;
    /**
     * The path of the Yaml file describing the build definition.
     */
    ymlPath: string;
}

export interface BuildDefinitionSchedule {
    /**
     * block supports the following:
     */
    branchFilters?: outputs.BuildDefinitionScheduleBranchFilter[];
    daysToBuilds: string[];
    /**
     * The ID of the schedule job
     */
    scheduleJobId: string;
    scheduleOnlyWithChanges?: boolean;
    startHours?: number;
    startMinutes?: number;
    timeZone?: string;
}

export interface BuildDefinitionScheduleBranchFilter {
    /**
     * List of branch patterns to exclude.
     */
    excludes?: string[];
    /**
     * List of branch patterns to include.
     */
    includes?: string[];
}

export interface BuildDefinitionVariable {
    /**
     * True if the variable can be overridden. Defaults to `true`.
     */
    allowOverride?: boolean;
    /**
     * True if the variable is a secret. Defaults to `false`.
     */
    isSecret?: boolean;
    /**
     * The name of the variable.
     */
    name: string;
    /**
     * The secret value of the variable. Used when `isSecret` set to `true`.
     */
    secretValue?: string;
    /**
     * The value of the variable.
     */
    value?: string;
}

export interface GetAreaChildren {
    /**
     * Indicator if the child Area node has child nodes
     */
    hasChildren: boolean;
    /**
     * The id of the child Area node
     */
    id: string;
    /**
     * The name of the child Area node
     */
    name: string;
    /**
     * The path to the Area; _Format_: URL relative; if omitted, or value `"/"` is used, the root Area will be returned
     */
    path: string;
    /**
     * The project ID.
     */
    projectId: string;
}

export interface GetGroupsGroup {
    /**
     * A short phrase to help human readers disambiguate groups with similar names
     */
    description?: string;
    /**
     * The descriptor is the primary way to reference the graph subject while the system is running. This field will uniquely identify the same graph subject across both Accounts and Organizations.
     */
    descriptor: string;
    /**
     * This is the non-unique display name of the graph subject. To change this field, you must alter its value in the source provider.
     */
    displayName?: string;
    /**
     * This represents the name of the container of origin for a graph member. (For MSA this is "Windows Live ID", for AD the name of the domain, for AAD the tenantID of the directory, for VSTS groups the ScopeId, etc)
     */
    domain: string;
    /**
     * The email address of record for a given graph member. This may be different than the principal name.
     */
    mailAddress?: string;
    /**
     * The type of source provider for the origin identifier (ex:AD, AAD, MSA)
     */
    origin: string;
    /**
     * The unique identifier from the system of origin. Typically a sid, object id or Guid. Linking and unlinking operations can cause this value to change for a user because the user is not backed by a different provider and has a different unique id in the new provider.
     */
    originId?: string;
    /**
     * This is the PrincipalName of this graph member from the source provider. The source provider may change this field over time and it is not guaranteed to be immutable for the life of the graph member by VSTS.
     */
    principalName: string;
    /**
     * This url is the full route to the source resource of this graph subject.
     */
    url: string;
}

export interface GetIterationChildren {
    /**
     * Indicator if the child Iteration node has child nodes
     */
    hasChildren: boolean;
    /**
     * The id of the child Iteration node
     */
    id: string;
    /**
     * The name of the child Iteration node
     */
    name: string;
    /**
     * The path to the Iteration, _Format_: URL relative; if omitted, or value `"/"` is used, the root Iteration will be returned
     */
    path: string;
    /**
     * The project ID.
     */
    projectId: string;
}

export interface GetPoolsAgentPool {
    /**
     * Specifies whether or not a queue should be automatically provisioned for each project collection.
     */
    autoProvision: boolean;
    id: number;
    /**
     * The name of the agent pool
     */
    name: string;
    /**
     * Specifies whether the agent pool type is Automation or Deployment.
     */
    poolType: string;
}

export interface GetProjectsProject {
    /**
     * Name of the Project, if not specified all projects will be returned.
     */
    name: string;
    /**
     * Project identifier.
     */
    projectId: string;
    /**
     * Url to the full version of the object.
     */
    projectUrl: string;
    /**
     * State of the Project, if not specified all projects will be returned. Valid values are `all`, `deleting`, `new`, `wellFormed`, `createPending`, `unchanged`,`deleted`.
     */
    state: string;
}

export interface GetRepositoriesRepository {
    /**
     * The ref of the default branch.
     */
    defaultBranch: string;
    /**
     * Git repository identifier.
     */
    id: string;
    /**
     * Name of the Git repository to retrieve; requires `projectId` to be specified as well
     */
    name: string;
    /**
     * ID of project to list Git repositories
     */
    projectId: string;
    /**
     * HTTPS Url to clone the Git repository
     */
    remoteUrl: string;
    /**
     * Compressed size (bytes) of the repository.
     */
    size: number;
    /**
     * SSH Url to clone the Git repository
     */
    sshUrl: string;
    /**
     * Details REST API endpoint for the Git Repository.
     */
    url: string;
    /**
     * Url of the Git repository web view
     */
    webUrl: string;
}

export interface GetTeamsTeam {
    administrators: string[];
    description: string;
    id: string;
    members: string[];
    name: string;
    projectId: string;
}

export interface GetUsersUser {
    /**
     * The descriptor is the primary way to reference the graph subject while the system is running. This field will uniquely identify the same graph subject across both Accounts and Organizations.
     */
    descriptor: string;
    /**
     * This is the non-unique display name of the graph subject. To change this field, you must alter its value in the source provider.
     */
    displayName: string;
    /**
     * The user ID.
     */
    id: string;
    /**
     * The email address of record for a given graph member. This may be different than the principal name.
     */
    mailAddress: string;
    /**
     * The type of source provider for the `originId` parameter (ex:AD, AAD, MSA) The supported origins are listed below.
     */
    origin: string;
    /**
     * The unique identifier from the system of origin.
     */
    originId?: string;
    /**
     * The PrincipalName of this graph member from the source provider.
     */
    principalName: string;
}

export interface GetVariableGroupKeyVault {
    /**
     * The name of the Variable Group to retrieve.
     */
    name: string;
    /**
     * The id of the Azure subscription endpoint to access the key vault.
     */
    serviceEndpointId: string;
}

export interface GetVariableGroupVariable {
    contentType: string;
    enabled: boolean;
    expires: string;
    /**
     * A boolean flag describing if the variable value is sensitive.
     */
    isSecret: boolean;
    /**
     * The name of the Variable Group to retrieve.
     */
    name: string;
    /**
     * The secret value of the variable.
     */
    secretValue: string;
    /**
     * The value of the variable.
     */
    value: string;
}

export interface GitInitialization {
    /**
     * The type of repository to create. Valid values: `Uninitialized`, `Clean` or `Import`.
     */
    initType: string;
    /**
     * The id of service connection used to authenticate to a private repository for import initialization.
     */
    serviceConnectionId?: string;
    /**
     * Type of the source repository. Used if the `initType` is `Import`. Valid values: `Git`.
     */
    sourceType?: string;
    /**
     * The URL of the source repository. Used if the `initType` is `Import`.
     */
    sourceUrl?: string;
}

export interface ServiceEndpointArtifactoryAuthenticationBasic {
    /**
     * Artifactory Password.
     */
    password: string;
    passwordHash: string;
    /**
     * Artifactory Username.
     */
    username: string;
    usernameHash: string;
}

export interface ServiceEndpointArtifactoryAuthenticationToken {
    /**
     * Authentication Token generated through Artifactory.
     * * `authenticationBasic`
     */
    token: string;
    tokenHash: string;
}

export interface ServiceEndpointAzureRMCredentials {
    /**
     * The service principal application Id
     */
    serviceprincipalid: string;
    /**
     * The service principal secret.
     */
    serviceprincipalkey: string;
    serviceprincipalkeyHash: string;
}

export interface ServiceEndpointGitHubAuthOauth {
    oauthConfigurationId: string;
}

export interface ServiceEndpointGitHubAuthPersonal {
    /**
     * The Personal Access Token for Github.
     */
    personalAccessToken: string;
    personalAccessTokenHash: string;
}

export interface ServiceEndpointGitHubEnterpriseAuthPersonal {
    /**
     * The Personal Access Token for Github.
     */
    personalAccessToken: string;
    personalAccessTokenHash: string;
}

export interface ServiceEndpointKubernetesAzureSubscription {
    /**
     * Azure environment refers to whether the public cloud offering or domestic (government) clouds are being used. Currently, only the public cloud is supported. The value must be AzureCloud. This is also the default-value.
     */
    azureEnvironment?: string;
    /**
     * Set this option to allow use cluster admin credentials.
     */
    clusterAdmin?: boolean;
    /**
     * The name of the Kubernetes cluster.
     */
    clusterName: string;
    /**
     * The Kubernetes namespace. Default value is "default".
     */
    namespace?: string;
    /**
     * The resource group name, to which the Kubernetes cluster is deployed.
     */
    resourcegroupId: string;
    /**
     * The id of the Azure subscription.
     */
    subscriptionId: string;
    /**
     * The name of the Azure subscription.
     */
    subscriptionName: string;
    /**
     * The id of the tenant used by the subscription.
     */
    tenantId: string;
}

export interface ServiceEndpointKubernetesKubeconfig {
    /**
     * Set this option to allow clients to accept a self-signed certificate.
     */
    acceptUntrustedCerts?: boolean;
    /**
     * Context within the kubeconfig file that is to be used for identifying the cluster. Default value is the current-context set in kubeconfig.
     */
    clusterContext?: string;
    /**
     * The content of the kubeconfig in yaml notation to be used to communicate with the API-Server of Kubernetes.
     */
    kubeConfig: string;
    kubeConfigHash: string;
}

export interface ServiceEndpointKubernetesServiceAccount {
    /**
     * The certificate from a Kubernetes secret object.
     */
    caCert: string;
    caCertHash: string;
    /**
     * The token from a Kubernetes secret object.
     */
    token: string;
    tokenHash: string;
}

export interface ServiceEndpointPipelineAuthPersonal {
    /**
     * The Personal Access Token for Azure DevOps Pipeline. It also can be set with AZDO_PERSONAL_ACCESS_TOKEN environment variable.
     */
    personalAccessToken: string;
    personalAccessTokenHash: string;
}

export interface ServiceEndpointServiceFabricAzureActiveDirectory {
    /**
     * - Password for the Azure Active Directory account.
     */
    password: string;
    passwordHash: string;
    /**
     * The common name(s) of the cluster's certificate(s). This is used to verify the identity of the cluster. This value overrides the publish profile. Separate multiple common names with a comma (',')
     */
    serverCertificateCommonName?: string;
    /**
     * Verification mode for the cluster. Possible values include `Thumbprint` or `CommonName`.
     */
    serverCertificateLookup: string;
    /**
     * The thumbprint(s) of the cluster's certificate(s). This is used to verify the identity of the cluster. This value overrides the publish profile. Separate multiple thumbprints with a comma (',')
     */
    serverCertificateThumbprint?: string;
    /**
     * - Specify an Azure Active Directory account.
     */
    username: string;
}

export interface ServiceEndpointServiceFabricCertificate {
    /**
     * Base64 encoding of the cluster's client certificate file.
     */
    clientCertificate: string;
    clientCertificateHash: string;
    /**
     * Password for the certificate.
     */
    clientCertificatePassword?: string;
    clientCertificatePasswordHash: string;
    /**
     * The common name(s) of the cluster's certificate(s). This is used to verify the identity of the cluster. This value overrides the publish profile. Separate multiple common names with a comma (',')
     */
    serverCertificateCommonName?: string;
    /**
     * Verification mode for the cluster. Possible values include `Thumbprint` or `CommonName`.
     */
    serverCertificateLookup: string;
    /**
     * The thumbprint(s) of the cluster's certificate(s). This is used to verify the identity of the cluster. This value overrides the publish profile. Separate multiple thumbprints with a comma (',')
     */
    serverCertificateThumbprint?: string;
}

export interface ServiceEndpointServiceFabricNone {
    /**
     * Fully qualified domain SPN for gMSA account. This is applicable only if `unsecured` option is disabled.
     */
    clusterSpn?: string;
    /**
     * Skip using windows security for authentication.
     */
    unsecured?: boolean;
}

export interface ServiceendpointArgocdAuthenticationBasic {
    /**
     * ArgoCD Password.
     */
    password: string;
    passwordHash: string;
    /**
     * ArgoCD Username.
     */
    username: string;
    usernameHash: string;
}

export interface ServiceendpointArgocdAuthenticationToken {
    /**
     * Authentication Token generated through ArgoCD.
     */
    token: string;
    tokenHash: string;
}

export interface VariableGroupKeyVault {
    /**
     * The name of the Variable Group.
     */
    name: string;
    serviceEndpointId: string;
}

export interface VariableGroupVariable {
    contentType: string;
    enabled: boolean;
    expires: string;
    /**
     * A boolean flag describing if the variable value is sensitive. Defaults to `false`.
     */
    isSecret?: boolean;
    /**
     * The key value used for the variable. Must be unique within the Variable Group.
     */
    name: string;
    /**
     * The secret value of the variable. If omitted, it will default to empty string. Used when `isSecret` set to `true`.
     */
    secretValue?: string;
    /**
     * The value of the variable. If omitted, it will default to empty string.
     */
    value?: string;
}

export namespace Agent {
    export interface GetPoolsAgentPool {
        /**
         * Specifies whether or not a queue should be automatically provisioned for each project collection.
         */
        autoProvision: boolean;
        id: number;
        /**
         * The name of the agent pool
         */
        name: string;
        /**
         * Specifies whether the agent pool type is Automation or Deployment.
         */
        poolType: string;
    }

}

export namespace Build {
    export interface BuildDefinitionCiTrigger {
        /**
         * Override the azure-pipeline file and use a this configuration for all builds.
         */
        override?: outputs.Build.BuildDefinitionCiTriggerOverride;
        /**
         * Use the azure-pipeline file for the build configuration. Defaults to `false`.
         */
        useYaml?: boolean;
    }

    export interface BuildDefinitionCiTriggerOverride {
        /**
         * If you set batch to true, when a pipeline is running, the system waits until the run is completed, then starts another run with all changes that have not yet been built. Defaults to `true`.
         */
        batch?: boolean;
        /**
         * The branches to include and exclude from the trigger.
         */
        branchFilters?: outputs.Build.BuildDefinitionCiTriggerOverrideBranchFilter[];
        /**
         * The number of max builds per branch. Defaults to `1`.
         */
        maxConcurrentBuildsPerBranch?: number;
        /**
         * Specify file paths to include or exclude. Note that the wildcard syntax is different between branches/tags and file paths.
         */
        pathFilters?: outputs.Build.BuildDefinitionCiTriggerOverridePathFilter[];
        /**
         * How often the external repository is polled. Defaults to `0`.
         */
        pollingInterval?: number;
        /**
         * This is the ID of the polling job that polls the external repository. Once the build definition is saved/updated, this value is set.
         */
        pollingJobId: string;
    }

    export interface BuildDefinitionCiTriggerOverrideBranchFilter {
        /**
         * List of branch patterns to exclude.
         */
        excludes?: string[];
        /**
         * List of branch patterns to include.
         */
        includes?: string[];
    }

    export interface BuildDefinitionCiTriggerOverridePathFilter {
        /**
         * List of branch patterns to exclude.
         */
        excludes?: string[];
        /**
         * List of branch patterns to include.
         */
        includes?: string[];
    }

    export interface BuildDefinitionPullRequestTrigger {
        commentRequired?: string;
        /**
         * Set permissions for Forked repositories.
         */
        forks: outputs.Build.BuildDefinitionPullRequestTriggerForks;
        initialBranch?: string;
        /**
         * Override the azure-pipeline file and use this configuration for all builds.
         */
        override?: outputs.Build.BuildDefinitionPullRequestTriggerOverride;
        /**
         * Use the azure-pipeline file for the build configuration. Defaults to `false`.
         */
        useYaml?: boolean;
    }

    export interface BuildDefinitionPullRequestTriggerForks {
        /**
         * Build pull requests form forms of this repository.
         */
        enabled: boolean;
        /**
         * Make secrets available to builds of forks.
         */
        shareSecrets: boolean;
    }

    export interface BuildDefinitionPullRequestTriggerOverride {
        /**
         * . Defaults to `true`.
         */
        autoCancel?: boolean;
        /**
         * The branches to include and exclude from the trigger.
         */
        branchFilters?: outputs.Build.BuildDefinitionPullRequestTriggerOverrideBranchFilter[];
        /**
         * Specify file paths to include or exclude. Note that the wildcard syntax is different between branches/tags and file paths.
         */
        pathFilters?: outputs.Build.BuildDefinitionPullRequestTriggerOverridePathFilter[];
    }

    export interface BuildDefinitionPullRequestTriggerOverrideBranchFilter {
        /**
         * List of branch patterns to exclude.
         */
        excludes?: string[];
        /**
         * List of branch patterns to include.
         */
        includes?: string[];
    }

    export interface BuildDefinitionPullRequestTriggerOverridePathFilter {
        /**
         * List of branch patterns to exclude.
         */
        excludes?: string[];
        /**
         * List of branch patterns to include.
         */
        includes?: string[];
    }

    export interface BuildDefinitionRepository {
        /**
         * The branch name for which builds are triggered. Defaults to `master`.
         */
        branchName?: string;
        /**
         * The Github Enterprise URL. Used if `repoType` is `GithubEnterprise`.
         */
        githubEnterpriseUrl?: string;
        /**
         * The id of the repository. For `TfsGit` repos, this is simply the ID of the repository. For `Github` repos, this will take the form of `<GitHub Org>/<Repo Name>`. For `Bitbucket` repos, this will take the form of `<Workspace ID>/<Repo Name>`.
         */
        repoId: string;
        /**
         * The repository type. Valid values: `GitHub` or `TfsGit` or `Bitbucket` or `GitHub Enterprise`. Defaults to `GitHub`. If `repoType` is `GitHubEnterprise`, must use existing project and GitHub Enterprise service connection.
         */
        repoType: string;
        /**
         * Report build status. Default is true.
         */
        reportBuildStatus?: boolean;
        /**
         * The service connection ID. Used if the `repoType` is `GitHub` or `GitHubEnterprise`.
         */
        serviceConnectionId?: string;
        /**
         * The path of the Yaml file describing the build definition.
         */
        ymlPath: string;
    }

    export interface BuildDefinitionSchedule {
        /**
         * block supports the following:
         */
        branchFilters?: outputs.Build.BuildDefinitionScheduleBranchFilter[];
        daysToBuilds: string[];
        /**
         * The ID of the schedule job
         */
        scheduleJobId: string;
        scheduleOnlyWithChanges?: boolean;
        startHours?: number;
        startMinutes?: number;
        timeZone?: string;
    }

    export interface BuildDefinitionScheduleBranchFilter {
        /**
         * List of branch patterns to exclude.
         */
        excludes?: string[];
        /**
         * List of branch patterns to include.
         */
        includes?: string[];
    }

    export interface BuildDefinitionVariable {
        /**
         * True if the variable can be overridden. Defaults to `true`.
         */
        allowOverride?: boolean;
        /**
         * True if the variable is a secret. Defaults to `false`.
         */
        isSecret?: boolean;
        /**
         * The name of the variable.
         */
        name: string;
        /**
         * The secret value of the variable. Used when `isSecret` set to `true`.
         */
        secretValue?: string;
        /**
         * The value of the variable.
         */
        value?: string;
    }

}

export namespace Core {
    export interface GetProjectsProject {
        /**
         * Name of the Project, if not specified all projects will be returned.
         */
        name: string;
        /**
         * Project identifier.
         */
        projectId: string;
        /**
         * Url to the full version of the object.
         */
        projectUrl: string;
        /**
         * State of the Project, if not specified all projects will be returned. Valid values are `all`, `deleting`, `new`, `wellFormed`, `createPending`, `unchanged`,`deleted`.
         */
        state: string;
    }

}

export namespace Identities {
    export interface GetUsersUser {
        /**
         * The descriptor is the primary way to reference the graph subject while the system is running. This field will uniquely identify the same graph subject across both Accounts and Organizations.
         */
        descriptor: string;
        /**
         * This is the non-unique display name of the graph subject. To change this field, you must alter its value in the source provider.
         */
        displayName: string;
        /**
         * The user ID.
         */
        id: string;
        /**
         * The email address of record for a given graph member. This may be different than the principal name.
         */
        mailAddress: string;
        /**
         * The type of source provider for the `originId` parameter (ex:AD, AAD, MSA) The supported origins are listed below.
         */
        origin: string;
        /**
         * The unique identifier from the system of origin.
         */
        originId?: string;
        /**
         * The PrincipalName of this graph member from the source provider.
         */
        principalName: string;
    }

}

export namespace Pipeline {
    export interface VariableGroupKeyVault {
        /**
         * The name of the Variable Group.
         */
        name: string;
        serviceEndpointId: string;
    }

    export interface VariableGroupVariable {
        contentType: string;
        enabled: boolean;
        expires: string;
        /**
         * A boolean flag describing if the variable value is sensitive. Defaults to `false`.
         */
        isSecret?: boolean;
        /**
         * The key value used for the variable. Must be unique within the Variable Group.
         */
        name: string;
        /**
         * The secret value of the variable. If omitted, it will default to empty string. Used when `isSecret` set to `true`.
         */
        secretValue?: string;
        /**
         * The value of the variable. If omitted, it will default to empty string.
         */
        value?: string;
    }

}

export namespace Policy {
    export interface BranchPolicyBuildValidationSettings {
        /**
         * The ID of the build to monitor for the policy.
         */
        buildDefinitionId: number;
        /**
         * The display name for the policy.
         */
        displayName: string;
        /**
         * If a path filter is set, the policy will only apply when files which match the filter are changes. Not setting this field means that the policy will always apply. You can specify absolute paths and wildcards. Example: `["/WebApp/Models/Data.cs", "/WebApp/*", "*.cs"]`. Paths prefixed with "!" are excluded. Example: `["/WebApp/*", "!/WebApp/Tests/*"]`. Order is significant.
         */
        filenamePatterns?: string[];
        /**
         * If set to true, the build will need to be manually queued. Defaults to `false`
         */
        manualQueueOnly?: boolean;
        /**
         * True if the build should queue on source updates only. Defaults to `true`.
         */
        queueOnSourceUpdateOnly?: boolean;
        /**
         * Controls which repositories and branches the policy will be enabled for. This block must be defined at least once.
         */
        scopes: outputs.Policy.BranchPolicyBuildValidationSettingsScope[];
        /**
         * The number of minutes for which the build is valid. If `0`, the build will not expire. Defaults to `720` (12 hours).
         */
        validDuration?: number;
    }

    export interface BranchPolicyBuildValidationSettingsScope {
        /**
         * The match type to use when applying the policy. Supported values are `Exact` (default) or `Prefix`.
         */
        matchType?: string;
        /**
         * The repository ID. Needed only if the scope of the policy will be limited to a single repository.
         */
        repositoryId?: string;
        /**
         * The ref pattern to use for the match. If `matchType` is `Exact`, this should be a qualified ref such as `refs/heads/master`. If `matchType` is `Prefix`, this should be a ref path such as `refs/heads/releases`.
         */
        repositoryRef?: string;
    }

    export interface BranchPolicyMinReviewersSettings {
        /**
         * Allow completion even if some reviewers vote to wait or reject. Defaults to `false`.
         */
        allowCompletionWithRejectsOrWaits?: boolean;
        /**
         * Prohibit the most recent pusher from approving their own changes. Defaults to `false`.
         */
        lastPusherCannotApprove?: boolean;
        /**
         * On last iteration require vote. Defaults to `false`.
         */
        onLastIterationRequireVote?: boolean;
        /**
         * When new changes are pushed reset all code reviewer votes. Defaults to `false`.
         */
        onPushResetAllVotes?: boolean;
        /**
         * When new changes are pushed reset all approval votes (does not reset votes to reject or wait). Defaults to `false`.
         */
        onPushResetApprovedVotes?: boolean;
        /**
         * The number of reviewers needed to approve.
         */
        reviewerCount?: number;
        /**
         * Controls which repositories and branches the policy will be enabled for. This block must be defined at least once.
         */
        scopes: outputs.Policy.BranchPolicyMinReviewersSettingsScope[];
        /**
         * Allow requesters to approve their own changes. Defaults to `false`.
         */
        submitterCanVote?: boolean;
    }

    export interface BranchPolicyMinReviewersSettingsScope {
        /**
         * The match type to use when applying the policy. Supported values are `Exact` (default) or `Prefix`.
         */
        matchType?: string;
        /**
         * The repository ID. Needed only if the scope of the policy will be limited to a single repository.
         */
        repositoryId?: string;
        /**
         * The ref pattern to use for the match. If `matchType` is `Exact`, this should be a qualified ref such as `refs/heads/master`. If `matchType` is `Prefix`, this should be a ref path such as `refs/heads/releases`.
         */
        repositoryRef?: string;
    }

}

export namespace Repository {
    export interface GetRepositoriesRepository {
        /**
         * The ref of the default branch.
         */
        defaultBranch: string;
        /**
         * Git repository identifier.
         */
        id: string;
        /**
         * Name of the Git repository to retrieve; requires `projectId` to be specified as well
         */
        name: string;
        /**
         * ID of project to list Git repositories
         */
        projectId: string;
        /**
         * HTTPS Url to clone the Git repository
         */
        remoteUrl: string;
        /**
         * Compressed size (bytes) of the repository.
         */
        size: number;
        /**
         * SSH Url to clone the Git repository
         */
        sshUrl: string;
        /**
         * Details REST API endpoint for the Git Repository.
         */
        url: string;
        /**
         * Url of the Git repository web view
         */
        webUrl: string;
    }

    export interface GitInitialization {
        /**
         * The type of repository to create. Valid values: `Uninitialized`, `Clean` or `Import`.
         */
        initType: string;
        /**
         * The id of service connection used to authenticate to a private repository for import initialization.
         */
        serviceConnectionId?: string;
        /**
         * Type of the source repository. Used if the `initType` is `Import`. Valid values: `Git`.
         */
        sourceType?: string;
        /**
         * The URL of the source repository. Used if the `initType` is `Import`.
         */
        sourceUrl?: string;
    }

}

export namespace ServiceEndpoint {
    export interface AzureRMCredentials {
        /**
         * The service principal application Id
         */
        serviceprincipalid: string;
        /**
         * The service principal secret.
         */
        serviceprincipalkey: string;
        serviceprincipalkeyHash: string;
    }

    export interface GitHubAuthOauth {
        oauthConfigurationId: string;
    }

    export interface GitHubAuthPersonal {
        /**
         * The Personal Access Token for Github.
         */
        personalAccessToken: string;
        personalAccessTokenHash: string;
    }

    export interface KubernetesAzureSubscription {
        /**
         * Azure environment refers to whether the public cloud offering or domestic (government) clouds are being used. Currently, only the public cloud is supported. The value must be AzureCloud. This is also the default-value.
         */
        azureEnvironment?: string;
        /**
         * Set this option to allow use cluster admin credentials.
         */
        clusterAdmin?: boolean;
        /**
         * The name of the Kubernetes cluster.
         */
        clusterName: string;
        /**
         * The Kubernetes namespace. Default value is "default".
         */
        namespace?: string;
        /**
         * The resource group name, to which the Kubernetes cluster is deployed.
         */
        resourcegroupId: string;
        /**
         * The id of the Azure subscription.
         */
        subscriptionId: string;
        /**
         * The name of the Azure subscription.
         */
        subscriptionName: string;
        /**
         * The id of the tenant used by the subscription.
         */
        tenantId: string;
    }

    export interface KubernetesKubeconfig {
        /**
         * Set this option to allow clients to accept a self-signed certificate.
         */
        acceptUntrustedCerts?: boolean;
        /**
         * Context within the kubeconfig file that is to be used for identifying the cluster. Default value is the current-context set in kubeconfig.
         */
        clusterContext?: string;
        /**
         * The content of the kubeconfig in yaml notation to be used to communicate with the API-Server of Kubernetes.
         */
        kubeConfig: string;
        kubeConfigHash: string;
    }

    export interface KubernetesServiceAccount {
        /**
         * The certificate from a Kubernetes secret object.
         */
        caCert: string;
        caCertHash: string;
        /**
         * The token from a Kubernetes secret object.
         */
        token: string;
        tokenHash: string;
    }

}
