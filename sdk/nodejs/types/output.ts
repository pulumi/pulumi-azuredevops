// *** WARNING: this file was generated by the Pulumi Terraform Bridge (tfgen) Tool. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

import * as pulumi from "@pulumi/pulumi";
import * as inputs from "../types/input";
import * as outputs from "../types/output";

export namespace Agent {
    export interface GetPoolsAgentPool {
        /**
         * Specifies whether or not a queue should be automatically provisioned for each project collection.
         */
        autoProvision: boolean;
        id: number;
        /**
         * The name of the agent pool
         */
        name: string;
        /**
         * Specifies whether the agent pool type is Automation or Deployment.
         */
        poolType: string;
    }
}

export namespace Build {
    export interface BuildDefinitionCiTrigger {
        /**
         * Override the azure-pipeline file and use a this configuration for all builds.
         */
        override?: outputs.Build.BuildDefinitionCiTriggerOverride;
        /**
         * Use the azure-pipeline file for the build configuration. Defaults to `false`.
         */
        useYaml?: boolean;
    }

    export interface BuildDefinitionCiTriggerOverride {
        /**
         * If you set batch to true, when a pipeline is running, the system waits until the run is completed, then starts another run with all changes that have not yet been built. Defaults to `true`.
         */
        batch?: boolean;
        /**
         * The branches to include and exclude from the trigger.
         */
        branchFilters?: outputs.Build.BuildDefinitionCiTriggerOverrideBranchFilter[];
        /**
         * The number of max builds per branch. Defaults to `1`.
         */
        maxConcurrentBuildsPerBranch?: number;
        /**
         * Specify file paths to include or exclude. Note that the wildcard syntax is different between branches/tags and file paths.
         */
        pathFilters?: outputs.Build.BuildDefinitionCiTriggerOverridePathFilter[];
        /**
         * How often the external repository is polled. Defaults to `0`.
         */
        pollingInterval?: number;
        /**
         * This is the ID of the polling job that polls the external repository. Once the build definition is saved/updated, this value is set.
         */
        pollingJobId: string;
    }

    export interface BuildDefinitionCiTriggerOverrideBranchFilter {
        /**
         * List of branch patterns to exclude.
         */
        excludes?: string[];
        /**
         * List of branch patterns to include.
         */
        includes?: string[];
    }

    export interface BuildDefinitionCiTriggerOverridePathFilter {
        /**
         * List of branch patterns to exclude.
         */
        excludes?: string[];
        /**
         * List of branch patterns to include.
         */
        includes?: string[];
    }

    export interface BuildDefinitionPullRequestTrigger {
        commentRequired?: string;
        /**
         * Set permissions for Forked repositories.
         */
        forks: outputs.Build.BuildDefinitionPullRequestTriggerForks;
        initialBranch?: string;
        /**
         * Override the azure-pipeline file and use a this configuration for all builds.
         */
        override?: outputs.Build.BuildDefinitionPullRequestTriggerOverride;
        /**
         * Use the azure-pipeline file for the build configuration. Defaults to `false`.
         */
        useYaml?: boolean;
    }

    export interface BuildDefinitionPullRequestTriggerForks {
        /**
         * Build pull requests form forms of this repository.
         */
        enabled: boolean;
        /**
         * Make secrets available to builds of forks.
         */
        shareSecrets: boolean;
    }

    export interface BuildDefinitionPullRequestTriggerOverride {
        /**
         * . Defaults to `true`.
         */
        autoCancel?: boolean;
        /**
         * The branches to include and exclude from the trigger.
         */
        branchFilters?: outputs.Build.BuildDefinitionPullRequestTriggerOverrideBranchFilter[];
        /**
         * Specify file paths to include or exclude. Note that the wildcard syntax is different between branches/tags and file paths.
         */
        pathFilters?: outputs.Build.BuildDefinitionPullRequestTriggerOverridePathFilter[];
    }

    export interface BuildDefinitionPullRequestTriggerOverrideBranchFilter {
        /**
         * List of branch patterns to exclude.
         */
        excludes?: string[];
        /**
         * List of branch patterns to include.
         */
        includes?: string[];
    }

    export interface BuildDefinitionPullRequestTriggerOverridePathFilter {
        /**
         * List of branch patterns to exclude.
         */
        excludes?: string[];
        /**
         * List of branch patterns to include.
         */
        includes?: string[];
    }

    export interface BuildDefinitionRepository {
        /**
         * The branch name for which builds are triggered. Defaults to `master`.
         */
        branchName?: string;
        /**
         * The id of the repository. For `TfsGit` repos, this is simply the ID of the repository. For `Github` repos, this will take the form of `<GitHub Org>/<Repo Name>`. For `Bitbucket` repos, this will take the form of `<Workspace ID>/<Repo Name>`.
         */
        repoId: string;
        /**
         * The repository type. Valid values: `GitHub` or `TfsGit` or `Bitbucket`. Defaults to `Github`.
         */
        repoType: string;
        /**
         * The service connection ID. Used if the `repoType` is `GitHub`.
         */
        serviceConnectionId?: string;
        /**
         * The path of the Yaml file describing the build definition.
         */
        ymlPath: string;
    }

    export interface BuildDefinitionVariable {
        /**
         * True if the variable can be overridden. Defaults to `true`.
         */
        allowOverride?: boolean;
        /**
         * True if the variable is a secret. Defaults to `false`.
         */
        isSecret?: boolean;
        /**
         * The name of the variable.
         */
        name: string;
        /**
         * The secret value of the variable. Used when `isSecret` set to `true`.
         */
        secretValue?: string;
        /**
         * The value of the variable.
         */
        value?: string;
    }
}

export namespace Core {
    export interface GetProjectsProject {
        /**
         * Project name.
         */
        name: string;
        /**
         * Project identifier.
         */
        projectId: string;
        /**
         * Url to the full version of the object.
         */
        projectUrl: string;
        /**
         * State of the Project, if not specified all projects will be returned. Valid values are `all`, `deleting`, `new`, `wellFormed`, `createPending`, `unchanged`,`deleted`.
         */
        state: string;
    }
}

export namespace Identities {
    export interface GetUsersUser {
        /**
         * The descriptor is the primary way to reference the graph subject while the system is running. This field will uniquely identify the same graph subject across both Accounts and Organizations.
         */
        descriptor: string;
        /**
         * This is the non-unique display name of the graph subject. To change this field, you must alter its value in the source provider.
         */
        displayName: string;
        /**
         * The email address of record for a given graph member. This may be different than the principal name.
         */
        mailAddress: string;
        /**
         * The type of source provider for the `originId` parameter (ex:AD, AAD, MSA) The supported origins are listed below.
         */
        origin: string;
        /**
         * The unique identifier from the system of origin.
         */
        originId?: string;
        /**
         * The PrincipalName of this graph member from the source provider.
         */
        principalName: string;
    }
}

export namespace Pipeline {
    export interface VariableGroupKeyVault {
        /**
         * The name of the Variable Group.
         */
        name: string;
        serviceEndpointId: string;
    }

    export interface VariableGroupVariable {
        contentType: string;
        enabled: boolean;
        expires: string;
        /**
         * A boolean flag describing if the variable value is sensitive. Defaults to `false`.
         */
        isSecret?: boolean;
        /**
         * The key value used for the variable. Must be unique within the Variable Group.
         */
        name: string;
        /**
         * The secret value of the variable. If omitted, it will default to empty string. Used when `isSecret` set to `true`.
         */
        secretValue?: string;
        /**
         * The value of the variable. If omitted, it will default to empty string.
         */
        value?: string;
    }
}

export namespace Policy {
    export interface BranchPolicyBuildValidationSettings {
        /**
         * The ID of the build to monitor for the policy.
         */
        buildDefinitionId: number;
        /**
         * The display name for the policy.
         */
        displayName: string;
        /**
         * If set to true, the build will need to be manually queued. Defaults to `false`
         */
        manualQueueOnly?: boolean;
        /**
         * True if the build should queue on source updates only. Defaults to `true`.
         */
        queueOnSourceUpdateOnly?: boolean;
        /**
         * Controls which repositories and branches the policy will be enabled for. This block must be defined at least once.
         */
        scopes: outputs.Policy.BranchPolicyBuildValidationSettingsScope[];
        /**
         * The number of minutes for which the build is valid. If `0`, the build will not expire. Defaults to `720` (12 hours).
         */
        validDuration?: number;
    }

    export interface BranchPolicyBuildValidationSettingsScope {
        /**
         * The match type to use when applying the policy. Supported values are `Exact` (default) or `Prefix`.
         */
        matchType?: string;
        /**
         * The repository ID. Needed only if the scope of the policy will be limited to a single repository.
         */
        repositoryId?: string;
        /**
         * The ref pattern to use for the match. If `matchType` is `Exact`, this should be a qualified ref such as `refs/heads/master`. If `matchType` is `Prefix`, this should be a ref path such as `refs/heads/releases`.
         */
        repositoryRef?: string;
    }

    export interface BranchPolicyMinReviewersSettings {
        /**
         * The number of reviewrs needed to approve.
         */
        reviewerCount: number;
        /**
         * Controls which repositories and branches the policy will be enabled for. This block must be defined at least once.
         */
        scopes: outputs.Policy.BranchPolicyMinReviewersSettingsScope[];
        /**
         * Controls whether or not the submitter's vote counts. Defaults to `false`.
         */
        submitterCanVote?: boolean;
    }

    export interface BranchPolicyMinReviewersSettingsScope {
        /**
         * The match type to use when applying the policy. Supported values are `Exact` (default) or `Prefix`.
         */
        matchType?: string;
        /**
         * The repository ID. Needed only if the scope of the policy will be limited to a single repository.
         */
        repositoryId?: string;
        /**
         * The ref pattern to use for the match. If `matchType` is `Exact`, this should be a qualified ref such as `refs/heads/master`. If `matchType` is `Prefix`, this should be a ref path such as `refs/heads/releases`.
         */
        repositoryRef?: string;
    }
}

export namespace Repository {
    export interface GetRepositoriesRepository {
        /**
         * The ref of the default branch.
         */
        defaultBranch: string;
        /**
         * Git repository identifier.
         */
        id: string;
        /**
         * Name of the Git repository to retrieve; requires `projectId` to be specified as well
         */
        name: string;
        /**
         * ID of project to list Git repositories
         */
        projectId: string;
        /**
         * HTTPS Url to clone the Git repository
         */
        remoteUrl: string;
        /**
         * Compressed size (bytes) of the repository.
         */
        size: number;
        /**
         * SSH Url to clone the Git repository
         */
        sshUrl: string;
        /**
         * Details REST API endpoint for the Git Repository.
         */
        url: string;
        /**
         * Url of the Git repository web view
         */
        webUrl: string;
    }

    export interface GitInitialization {
        /**
         * The type of repository to create. Valid values: `Uninitialized`, `Clean`, or `Import`. Defaults to `Uninitialized`.
         */
        initType: string;
        /**
         * Type type of the source repository. Used if the `initType` is `Import`.
         */
        sourceType?: string;
        /**
         * The URL of the source repository. Used if the `initType` is `Import`.
         */
        sourceUrl?: string;
    }
}

export namespace ServiceEndpoint {
    export interface AzureRMCredentials {
        /**
         * The service principal application Id
         */
        serviceprincipalid: string;
        /**
         * The service principal secret.
         */
        serviceprincipalkey: string;
        serviceprincipalkeyHash: string;
    }

    export interface GitHubAuthOauth {
        oauthConfigurationId: string;
    }

    export interface GitHubAuthPersonal {
        /**
         * The Personal Access Token for Github.
         */
        personalAccessToken: string;
        personalAccessTokenHash: string;
    }

    export interface KubernetesAzureSubscription {
        /**
         * Azure environment refers to whether the public cloud offering or domestic (government) clouds are being used. Currently, only the public cloud is supported. The value must be AzureCloud. This is also the default-value.
         */
        azureEnvironment?: string;
        /**
         * The name of the Kubernetes cluster.
         */
        clusterName: string;
        /**
         * The Kubernetes namespace. Default value is "default".
         */
        namespace?: string;
        /**
         * The resource group id, to which the Kubernetes cluster is deployed.
         */
        resourcegroupId: string;
        /**
         * The id of the Azure subscription.
         */
        subscriptionId: string;
        /**
         * The name of the Azure subscription.
         */
        subscriptionName: string;
        /**
         * The id of the tenant used by the subscription.
         */
        tenantId: string;
    }

    export interface KubernetesKubeconfig {
        /**
         * Set this option to allow clients to accept a self-signed certificate.
         */
        acceptUntrustedCerts?: boolean;
        /**
         * Context within the kubeconfig file that is to be used for identifying the cluster. Default value is the current-context set in kubeconfig.
         */
        clusterContext?: string;
        /**
         * The content of the kubeconfig in yaml notation to be used to communicate with the API-Server of Kubernetes.
         */
        kubeConfig: string;
        kubeConfigHash: string;
    }

    export interface KubernetesServiceAccount {
        /**
         * The certificate from a Kubernetes secret object.
         */
        caCert: string;
        caCertHash: string;
        /**
         * The token from a Kubernetes secret object.
         */
        token: string;
        tokenHash: string;
    }
}

